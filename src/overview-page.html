<html><head></head><body><div hidden="" by-polymer-bundler=""><script>// This is left only for backward compatibility with projects
// that incorrectly relied on unscoped global [hidden] rules;
// removing would be a breaking change, but new projects
// should never rely on this.
(function(){var style=document.createElement("style");style.textContent="[hidden] { display: none !important; }";document.head.appendChild(style)})();</script><custom-style><style is="custom-style">[hidden]{display:none !important;}</style></custom-style><custom-style><style is="custom-style">html{--layout:{display:-ms-flexbox;display:-webkit-flex;display:flex;};--layout-inline:{display:-ms-inline-flexbox;display:-webkit-inline-flex;display:inline-flex;};--layout-horizontal:{@apply --layout;-ms-flex-direction:row;-webkit-flex-direction:row;flex-direction:row;};--layout-horizontal-reverse:{@apply --layout;-ms-flex-direction:row-reverse;-webkit-flex-direction:row-reverse;flex-direction:row-reverse;};--layout-vertical:{@apply --layout;-ms-flex-direction:column;-webkit-flex-direction:column;flex-direction:column;};--layout-vertical-reverse:{@apply --layout;-ms-flex-direction:column-reverse;-webkit-flex-direction:column-reverse;flex-direction:column-reverse;};--layout-wrap:{-ms-flex-wrap:wrap;-webkit-flex-wrap:wrap;flex-wrap:wrap;};--layout-wrap-reverse:{-ms-flex-wrap:wrap-reverse;-webkit-flex-wrap:wrap-reverse;flex-wrap:wrap-reverse;};--layout-flex-auto:{-ms-flex:1 1 auto;-webkit-flex:1 1 auto;flex:1 1 auto;};--layout-flex-none:{-ms-flex:none;-webkit-flex:none;flex:none;};--layout-flex:{-ms-flex:1 1 0.000000001px;-webkit-flex:1;flex:1;-webkit-flex-basis:0.000000001px;flex-basis:0.000000001px;};--layout-flex-2:{-ms-flex:2;-webkit-flex:2;flex:2;};--layout-flex-3:{-ms-flex:3;-webkit-flex:3;flex:3;};--layout-flex-4:{-ms-flex:4;-webkit-flex:4;flex:4;};--layout-flex-5:{-ms-flex:5;-webkit-flex:5;flex:5;};--layout-flex-6:{-ms-flex:6;-webkit-flex:6;flex:6;};--layout-flex-7:{-ms-flex:7;-webkit-flex:7;flex:7;};--layout-flex-8:{-ms-flex:8;-webkit-flex:8;flex:8;};--layout-flex-9:{-ms-flex:9;-webkit-flex:9;flex:9;};--layout-flex-10:{-ms-flex:10;-webkit-flex:10;flex:10;};--layout-flex-11:{-ms-flex:11;-webkit-flex:11;flex:11;};--layout-flex-12:{-ms-flex:12;-webkit-flex:12;flex:12;};--layout-start:{-ms-flex-align:start;-webkit-align-items:flex-start;align-items:flex-start;};--layout-center:{-ms-flex-align:center;-webkit-align-items:center;align-items:center;};--layout-end:{-ms-flex-align:end;-webkit-align-items:flex-end;align-items:flex-end;};--layout-baseline:{-ms-flex-align:baseline;-webkit-align-items:baseline;align-items:baseline;};--layout-start-justified:{-ms-flex-pack:start;-webkit-justify-content:flex-start;justify-content:flex-start;};--layout-center-justified:{-ms-flex-pack:center;-webkit-justify-content:center;justify-content:center;};--layout-end-justified:{-ms-flex-pack:end;-webkit-justify-content:flex-end;justify-content:flex-end;};--layout-around-justified:{-ms-flex-pack:distribute;-webkit-justify-content:space-around;justify-content:space-around;};--layout-justified:{-ms-flex-pack:justify;-webkit-justify-content:space-between;justify-content:space-between;};--layout-center-center:{@apply --layout-center;@apply --layout-center-justified;};--layout-self-start:{-ms-align-self:flex-start;-webkit-align-self:flex-start;align-self:flex-start;};--layout-self-center:{-ms-align-self:center;-webkit-align-self:center;align-self:center;};--layout-self-end:{-ms-align-self:flex-end;-webkit-align-self:flex-end;align-self:flex-end;};--layout-self-stretch:{-ms-align-self:stretch;-webkit-align-self:stretch;align-self:stretch;};--layout-self-baseline:{-ms-align-self:baseline;-webkit-align-self:baseline;align-self:baseline;};--layout-start-aligned:{-ms-flex-line-pack:start;-ms-align-content:flex-start;-webkit-align-content:flex-start;align-content:flex-start;};--layout-end-aligned:{-ms-flex-line-pack:end;-ms-align-content:flex-end;-webkit-align-content:flex-end;align-content:flex-end;};--layout-center-aligned:{-ms-flex-line-pack:center;-ms-align-content:center;-webkit-align-content:center;align-content:center;};--layout-between-aligned:{-ms-flex-line-pack:justify;-ms-align-content:space-between;-webkit-align-content:space-between;align-content:space-between;};--layout-around-aligned:{-ms-flex-line-pack:distribute;-ms-align-content:space-around;-webkit-align-content:space-around;align-content:space-around;};--layout-block:{display:block;};--layout-invisible:{visibility:hidden !important;};--layout-relative:{position:relative;};--layout-fit:{position:absolute;top:0;right:0;bottom:0;left:0;};--layout-scroll:{-webkit-overflow-scrolling:touch;overflow:auto;};--layout-fullbleed:{margin:0;height:100vh;};--layout-fixed-top:{position:fixed;top:0;left:0;right:0;};--layout-fixed-right:{position:fixed;top:0;right:0;bottom:0;};--layout-fixed-bottom:{position:fixed;right:0;bottom:0;left:0;};--layout-fixed-left:{position:fixed;top:0;bottom:0;left:0;};}</style></custom-style><script>(function(){// Contains all connected resizables that do not have a parent.
var ORPHANS=new Set;/**
   * `IronResizableBehavior` is a behavior that can be used in Polymer elements to
   * coordinate the flow of resize events between "resizers" (elements that
   *control the size or hidden state of their children) and "resizables" (elements
   *that need to be notified when they are resized or un-hidden by their parents
   *in order to take action on their new measurements).
   *
   * Elements that perform measurement should add the `IronResizableBehavior`
   *behavior to their element definition and listen for the `iron-resize` event on
   *themselves. This event will be fired when they become showing after having
   *been hidden, when they are resized explicitly by another resizable, or when
   *the window has been resized.
   *
   * Note, the `iron-resize` event is non-bubbling.
   *
   * @polymerBehavior Polymer.IronResizableBehavior
   * @demo demo/index.html
   **/Polymer.IronResizableBehavior={properties:{/**
       * The closest ancestor element that implements `IronResizableBehavior`.
       */_parentResizable:{type:Object,observer:"_parentResizableChanged"},/**
       * True if this element is currently notifying its descendant elements of
       * resize.
       */_notifyingDescendant:{type:Boolean,value:!1}},listeners:{"iron-request-resize-notifications":"_onIronRequestResizeNotifications"},created:function(){// We don't really need property effects on these, and also we want them
// to be created before the `_parentResizable` observer fires:
this._interestedResizables=[];this._boundNotifyResize=this.notifyResize.bind(this)},attached:function(){this._requestResizeNotifications()},detached:function(){if(this._parentResizable){this._parentResizable.stopResizeNotificationsFor(this)}else{ORPHANS.delete(this);window.removeEventListener("resize",this._boundNotifyResize)}this._parentResizable=null},/**
     * Can be called to manually notify a resizable and its descendant
     * resizables of a resize change.
     */notifyResize:function(){if(!this.isAttached){return}this._interestedResizables.forEach(function(resizable){if(this.resizerShouldNotify(resizable)){this._notifyDescendant(resizable)}},this);this._fireResize()},/**
     * Used to assign the closest resizable ancestor to this resizable
     * if the ancestor detects a request for notifications.
     */assignParentResizable:function(parentResizable){if(this._parentResizable){this._parentResizable.stopResizeNotificationsFor(this)}this._parentResizable=parentResizable;if(parentResizable&&-1===parentResizable._interestedResizables.indexOf(this)){parentResizable._interestedResizables.push(this);parentResizable.listen(this,"iron-resize","_onDescendantIronResize")}},/**
     * Used to remove a resizable descendant from the list of descendants
     * that should be notified of a resize change.
     */stopResizeNotificationsFor:function(target){var index=this._interestedResizables.indexOf(target);if(-1<index){this._interestedResizables.splice(index,1);this.unlisten(target,"iron-resize","_onDescendantIronResize")}},/**
     * This method can be overridden to filter nested elements that should or
     * should not be notified by the current element. Return true if an element
     * should be notified, or false if it should not be notified.
     *
     * @param {HTMLElement} element A candidate descendant element that
     * implements `IronResizableBehavior`.
     * @return {boolean} True if the `element` should be notified of resize.
     */resizerShouldNotify:function(element){return!0},_onDescendantIronResize:function(event){if(this._notifyingDescendant){event.stopPropagation();return}// NOTE(cdata): In ShadowDOM, event retargeting makes echoing of the
// otherwise non-bubbling event "just work." We do it manually here for
// the case where Polymer is not using shadow roots for whatever reason:
if(!Polymer.Settings.useShadow){this._fireResize()}},_fireResize:function(){this.fire("iron-resize",null,{node:this,bubbles:!1})},_onIronRequestResizeNotifications:function(event){var target=/** @type {!EventTarget} */Polymer.dom(event).rootTarget;if(target===this){return}target.assignParentResizable(this);this._notifyDescendant(target);event.stopPropagation()},_parentResizableChanged:function(parentResizable){if(parentResizable){window.removeEventListener("resize",this._boundNotifyResize)}},_notifyDescendant:function(descendant){// NOTE(cdata): In IE10, attached is fired on children first, so it's
// important not to notify them if the parent is not attached yet (or
// else they will get redundantly notified when the parent attaches).
if(!this.isAttached){return}this._notifyingDescendant=!0;descendant.notifyResize();this._notifyingDescendant=!1},_requestResizeNotifications:function(){if(!this.isAttached)return;// NOTE(valdrin) In CustomElements v1 with native HTMLImports, the order
// of imports affects the order of `attached` callbacks (see
// webcomponents/custom-elements#15). This might cause a child to notify
// parents too early (as the parent still has to be upgraded), resulting in
// a parent not able to keep track of the `_interestedResizables`. To solve
// this, we wait for the document to be done loading before firing the
// event.
if("loading"===document.readyState){var _requestResizeNotifications=this._requestResizeNotifications.bind(this);document.addEventListener("readystatechange",function readystatechanged(){document.removeEventListener("readystatechange",readystatechanged);_requestResizeNotifications()})}else{this._findParent();if(!this._parentResizable){// If this resizable is an orphan, tell other orphans to try to find
// their parent again, in case it's this resizable.
ORPHANS.forEach(function(orphan){if(orphan!==this){orphan._findParent()}},this);window.addEventListener("resize",this._boundNotifyResize);this.notifyResize()}else{// If this resizable has a parent, tell other child resizables of
// that parent to try finding their parent again, in case it's this
// resizable.
this._parentResizable._interestedResizables.forEach(function(resizable){if(resizable!==this){resizable._findParent()}},this)}}},_findParent:function(){this.assignParentResizable(null);this.fire("iron-request-resize-notifications",null,{node:this,bubbles:!0,cancelable:!0});if(!this._parentResizable){ORPHANS.add(this)}else{ORPHANS.delete(this)}}}})();</script><script>/**
   * @polymerBehavior Polymer.AppLayoutBehavior
   **/Polymer.AppLayoutBehavior=[Polymer.IronResizableBehavior,{listeners:{"app-reset-layout":"_appResetLayoutHandler","iron-resize":"resetLayout"},attached:function(){this.fire("app-reset-layout")},_appResetLayoutHandler:function(e){if(Polymer.dom(e).path[0]===this){return}this.resetLayout();e.stopPropagation()},_updateLayoutStates:function(){console.error("unimplemented")},/**
       * Resets the layout. If you changed the size of this element via CSS
       * you can notify the changes by either firing the `iron-resize` event
       * or calling `resetLayout` directly.
       *
       * @method resetLayout
       */resetLayout:function(){// Polymer v2.x
var self=this,cb=this._updateLayoutStates.bind(this);if(Polymer.Async&&Polymer.Async.animationFrame){this._layoutDebouncer=Polymer.Debouncer.debounce(this._layoutDebouncer,Polymer.Async.animationFrame,cb);Polymer.enqueueDebouncer(this._layoutDebouncer)}// Polymer v1.x
else{this.debounce("resetLayout",cb)}this._notifyDescendantResize()},_notifyLayoutChanged:function(){var self=this;// TODO: the event `app-reset-layout` can be fired synchronously
// as long as `_updateLayoutStates` waits for all the microtasks after
// rAF. E.g. requestAnimationFrame(setTimeOut())
requestAnimationFrame(function(){self.fire("app-reset-layout")})},_notifyDescendantResize:function(){if(!this.isAttached){return}this._interestedResizables.forEach(function(resizable){if(this.resizerShouldNotify(resizable)){this._notifyDescendant(resizable)}},this)}}];</script><dom-module id="app-header-layout" assetpath="../bower_components/app-layout/app-header-layout/"><template><style>:host{display:block;position:relative;z-index:0;}#wrapper ::slotted([slot=header]){@apply --layout-fixed-top;z-index:1;}#wrapper.initializing ::slotted([slot=header]){position:relative;}:host([has-scrolling-region]){height:100%;}:host([has-scrolling-region]) #wrapper ::slotted([slot=header]){position:absolute;}:host([has-scrolling-region]) #wrapper.initializing ::slotted([slot=header]){position:relative;}:host([has-scrolling-region]) #wrapper #contentContainer{@apply --layout-fit;overflow-y:auto;-webkit-overflow-scrolling:touch;}:host([has-scrolling-region]) #wrapper.initializing #contentContainer{position:relative;}:host([fullbleed]){@apply --layout-vertical;@apply --layout-fit;}:host([fullbleed]) #wrapper,
      :host([fullbleed]) #wrapper #contentContainer{@apply --layout-vertical;@apply --layout-flex;}#contentContainer{position:relative;z-index:0;}@media print{:host([has-scrolling-region]) #wrapper #contentContainer{overflow-y:visible;}}</style><div id="wrapper" class="initializing"><slot id="headerSlot" name="header"></slot><div id="contentContainer"><slot></slot></div></div></template><script>Polymer({is:"app-header-layout",behaviors:[Polymer.AppLayoutBehavior],properties:{/**
         * If true, the current element will have its own scrolling region.
         * Otherwise, it will use the document scroll to control the header.
         */hasScrollingRegion:{type:Boolean,value:!1,reflectToAttribute:!0}},observers:["resetLayout(isAttached, hasScrollingRegion)"],/**
       * A reference to the app-header element.
       *
       * @property header
       */get header(){return Polymer.dom(this.$.headerSlot).getDistributedNodes()[0]},_updateLayoutStates:function(){var header=this.header;if(!this.isAttached||!header){return}// Remove the initializing class, which staticly positions the header and
// the content until the height of the header can be read.
this.$.wrapper.classList.remove("initializing");// Update scroll target.
header.scrollTarget=this.hasScrollingRegion?this.$.contentContainer:this.ownerDocument.documentElement;// Get header height here so that style reads are batched together before
// style writes (i.e. getBoundingClientRect() below).
var headerHeight=header.offsetHeight;// Update the header position.
if(!this.hasScrollingRegion){requestAnimationFrame(function(){var rect=this.getBoundingClientRect(),rightOffset=document.documentElement.clientWidth-rect.right;header.style.left=rect.left+"px";header.style.right=rightOffset+"px"}.bind(this))}else{header.style.left="";header.style.right=""}// Update the content container position.
var containerStyle=this.$.contentContainer.style;if(header.fixed&&!header.condenses&&this.hasScrollingRegion){// If the header size does not change and we're using a scrolling region,
// exclude the header area from the scrolling region so that the header
// doesn't overlap the scrollbar.
containerStyle.marginTop=headerHeight+"px";containerStyle.paddingTop=""}else{containerStyle.paddingTop=headerHeight+"px";containerStyle.marginTop=""}}});</script></dom-module><script>/**
   * `Polymer.IronScrollTargetBehavior` allows an element to respond to scroll
   * events from a designated scroll target.
   *
   * Elements that consume this behavior can override the `_scrollHandler`
   * method to add logic on the scroll event.
   *
   * @demo demo/scrolling-region.html Scrolling Region
   * @demo demo/document.html Document Element
   * @polymerBehavior
   */Polymer.IronScrollTargetBehavior={properties:{/**
       * Specifies the element that will handle the scroll event
       * on the behalf of the current element. This is typically a reference to an
       *element, but there are a few more posibilities:
       *
       * ### Elements id
       *
       *```html
       * <div id="scrollable-element" style="overflow: auto;">
       *  <x-element scroll-target="scrollable-element">
       *    <!-- Content-->
       *  </x-element>
       * </div>
       *```
       * In this case, the `scrollTarget` will point to the outer div element.
       *
       * ### Document scrolling
       *
       * For document scrolling, you can use the reserved word `document`:
       *
       *```html
       * <x-element scroll-target="document">
       *   <!-- Content -->
       * </x-element>
       *```
       *
       * ### Elements reference
       *
       *```js
       * appHeader.scrollTarget = document.querySelector('#scrollable-element');
       *```
       *
       * @type {HTMLElement}
       * @default document
       */scrollTarget:{type:HTMLElement,value:function(){return this._defaultScrollTarget}}},observers:["_scrollTargetChanged(scrollTarget, isAttached)"],/**
     * True if the event listener should be installed.
     */_shouldHaveListener:!0,_scrollTargetChanged:function(scrollTarget,isAttached){var eventTarget;if(this._oldScrollTarget){this._toggleScrollListener(!1,this._oldScrollTarget);this._oldScrollTarget=null}if(!isAttached){return}// Support element id references
if("document"===scrollTarget){this.scrollTarget=this._doc}else if("string"===typeof scrollTarget){var domHost=this.domHost;this.scrollTarget=domHost&&domHost.$?domHost.$[scrollTarget]:Polymer.dom(this.ownerDocument).querySelector("#"+scrollTarget)}else if(this._isValidScrollTarget()){this._oldScrollTarget=scrollTarget;this._toggleScrollListener(this._shouldHaveListener,scrollTarget)}},/**
     * Runs on every scroll event. Consumer of this behavior may override this
     * method.
     *
     * @protected
     */_scrollHandler:function scrollHandler(){},/**
     * The default scroll target. Consumers of this behavior may want to customize
     * the default scroll target.
     *
     * @type {Element}
     */get _defaultScrollTarget(){return this._doc},/**
     * Shortcut for the document element
     *
     * @type {Element}
     */get _doc(){return this.ownerDocument.documentElement},/**
     * Gets the number of pixels that the content of an element is scrolled
     * upward.
     *
     * @type {number}
     */get _scrollTop(){if(this._isValidScrollTarget()){return this.scrollTarget===this._doc?window.pageYOffset:this.scrollTarget.scrollTop}return 0},/**
     * Gets the number of pixels that the content of an element is scrolled to the
     * left.
     *
     * @type {number}
     */get _scrollLeft(){if(this._isValidScrollTarget()){return this.scrollTarget===this._doc?window.pageXOffset:this.scrollTarget.scrollLeft}return 0},/**
     * Sets the number of pixels that the content of an element is scrolled
     * upward.
     *
     * @type {number}
     */set _scrollTop(top){if(this.scrollTarget===this._doc){window.scrollTo(window.pageXOffset,top)}else if(this._isValidScrollTarget()){this.scrollTarget.scrollTop=top}},/**
     * Sets the number of pixels that the content of an element is scrolled to the
     * left.
     *
     * @type {number}
     */set _scrollLeft(left){if(this.scrollTarget===this._doc){window.scrollTo(left,window.pageYOffset)}else if(this._isValidScrollTarget()){this.scrollTarget.scrollLeft=left}},/**
     * Scrolls the content to a particular place.
     *
     * @method scroll
     * @param {number|!{left: number, top: number}} leftOrOptions The left position or scroll options
     * @param {number=} top The top position
     * @return {void}
     */scroll:function(leftOrOptions,top){var left;if("object"===typeof leftOrOptions){left=leftOrOptions.left;top=leftOrOptions.top}else{left=leftOrOptions}left=left||0;top=top||0;if(this.scrollTarget===this._doc){window.scrollTo(left,top)}else if(this._isValidScrollTarget()){this.scrollTarget.scrollLeft=left;this.scrollTarget.scrollTop=top}},/**
     * Gets the width of the scroll target.
     *
     * @type {number}
     */get _scrollTargetWidth(){if(this._isValidScrollTarget()){return this.scrollTarget===this._doc?window.innerWidth:this.scrollTarget.offsetWidth}return 0},/**
     * Gets the height of the scroll target.
     *
     * @type {number}
     */get _scrollTargetHeight(){if(this._isValidScrollTarget()){return this.scrollTarget===this._doc?window.innerHeight:this.scrollTarget.offsetHeight}return 0},/**
     * Returns true if the scroll target is a valid HTMLElement.
     *
     * @return {boolean}
     */_isValidScrollTarget:function(){return this.scrollTarget instanceof HTMLElement},_toggleScrollListener:function(yes,scrollTarget){var eventTarget=scrollTarget===this._doc?window:scrollTarget;if(yes){if(!this._boundScrollHandler){this._boundScrollHandler=this._scrollHandler.bind(this);eventTarget.addEventListener("scroll",this._boundScrollHandler)}}else{if(this._boundScrollHandler){eventTarget.removeEventListener("scroll",this._boundScrollHandler);this._boundScrollHandler=null}}},/**
     * Enables or disables the scroll event listener.
     *
     * @param {boolean} yes True to add the event, False to remove it.
     */toggleScrollListener:function(yes){this._shouldHaveListener=yes;this._toggleScrollListener(yes,this.scrollTarget)}};</script><script>/** @namespace */Polymer.AppLayout=Polymer.AppLayout||{};Polymer.AppLayout._scrollEffects={};Polymer.AppLayout._scrollTimer=null;Polymer.AppLayout.scrollTimingFunction=function easeOutQuad(t,b,c,d){t/=d;return-c*t*(t-2)+b};/**
   * Registers a scroll effect to be used in elements that implement the
   * `Polymer.AppScrollEffectsBehavior` behavior.
   *
   * @param {string} effectName The effect name.
   * @param {Object} effectDef The effect definition.
   */Polymer.AppLayout.registerEffect=function registerEffect(effectName,effectDef){if(null!=Polymer.AppLayout._scrollEffects[effectName]){throw new Error("effect `"+effectName+"` is already registered.")}Polymer.AppLayout._scrollEffects[effectName]=effectDef};Polymer.AppLayout.queryAllRoot=function(selector,root){var queue=[root],matches=[];while(0<queue.length){var node=queue.shift();matches.push.apply(matches,node.querySelectorAll(selector));for(var i=0;node.children[i];i++){if(node.children[i].shadowRoot){queue.push(node.children[i].shadowRoot)}}}return matches};/**
   * Scrolls to a particular set of coordinates in a scroll target.
   * If the scroll target is not defined, then it would use the main document as
   * the target.
   *
   * To scroll in a smooth fashion, you can set the option `behavior: 'smooth'`.
   * e.g.
   *
   * ```js
   * Polymer.AppLayout.scroll({top: 0, behavior: 'smooth'});
   * ```
   *
   * To scroll in a silent mode, without notifying scroll changes to any
   * app-layout elements, you can set the option `behavior: 'silent'`. This is
   * particularly useful we you are using `app-header` and you desire to scroll to
   * the top of a scrolling region without running scroll effects. e.g.
   *
   * ```js
   * Polymer.AppLayout.scroll({top: 0, behavior: 'silent'});
   * ```
   *
   * @param {Object} options {top: Number, left: Number, behavior: String(smooth | silent)}
   */Polymer.AppLayout.scroll=function scroll(options){options=options||{};var docEl=document.documentElement,target=options.target||docEl,hasNativeScrollBehavior="scrollBehavior"in target.style&&target.scroll,scrollClassName="app-layout-silent-scroll",scrollTop=options.top||0,scrollLeft=options.left||0,scrollTo=target===docEl?window.scrollTo:function scrollTo(scrollLeft,scrollTop){target.scrollLeft=scrollLeft;target.scrollTop=scrollTop};if("smooth"===options.behavior){if(hasNativeScrollBehavior){target.scroll(options)}else{var timingFn=Polymer.AppLayout.scrollTimingFunction,startTime=Date.now(),currentScrollTop=target===docEl?window.pageYOffset:target.scrollTop,currentScrollLeft=target===docEl?window.pageXOffset:target.scrollLeft,deltaScrollTop=scrollTop-currentScrollTop,deltaScrollLeft=scrollLeft-currentScrollLeft,duration=300,updateFrame=function updateFrame(){var now=Date.now(),elapsedTime=now-startTime;if(elapsedTime<duration){scrollTo(timingFn(elapsedTime,currentScrollLeft,deltaScrollLeft,duration),timingFn(elapsedTime,currentScrollTop,deltaScrollTop,duration));requestAnimationFrame(updateFrame)}else{scrollTo(scrollLeft,scrollTop)}}.bind(this);updateFrame()}}else if("silent"===options.behavior){var headers=Polymer.AppLayout.queryAllRoot("app-header",document.body);headers.forEach(function(header){header.setAttribute("silent-scroll","")});// Browsers keep the scroll momentum even if the bottom of the scrolling
// content was reached. This means that calling scroll({top: 0, behavior:
// 'silent'}) when the momentum is still going will result in more scroll
// events and thus scroll effects. This seems to only apply when using
// document scrolling. Therefore, when should we remove the class from the
// document element?
if(Polymer.AppLayout._scrollTimer){window.cancelAnimationFrame(Polymer.AppLayout._scrollTimer)}Polymer.AppLayout._scrollTimer=window.requestAnimationFrame(function(){headers.forEach(function(header){header.removeAttribute("silent-scroll")});Polymer.AppLayout._scrollTimer=null});scrollTo(scrollLeft,scrollTop)}else{scrollTo(scrollLeft,scrollTop)}};</script><script>/**
   * `Polymer.AppScrollEffectsBehavior` provides an interface that allows an
   * element to use scrolls effects.
   *
   * ### Importing the app-layout effects
   *
   * app-layout provides a set of scroll effects that can be used by explicitly
   * importing `app-scroll-effects.html`:
   *
   * ```html
   * <link rel="import"
   * href="/bower_components/app-layout/app-scroll-effects/app-scroll-effects.html">
   * ```
   *
   * The scroll effects can also be used by individually importing
   * `app-layout/app-scroll-effects/effects/[effectName].html`. For example:
   *
   * ```html
   *  <link rel="import"
   * href="/bower_components/app-layout/app-scroll-effects/effects/waterfall.html">
   * ```
   *
   * ### Consuming effects
   *
   * Effects can be consumed via the `effects` property. For example:
   *
   * ```html
   * <app-header effects="waterfall"></app-header>
   * ```
   *
   * ### Creating scroll effects
   *
   * You may want to create a custom scroll effect if you need to modify the CSS
   * of an element based on the scroll position.
   *
   * A scroll effect definition is an object with `setUp()`, `tearDown()` and
   * `run()` functions.
   *
   * To register the effect, you can use
   * `Polymer.AppLayout.registerEffect(effectName, effectDef)` For example, let's
   * define an effect that resizes the header's logo:
   *
   * ```js
   * Polymer.AppLayout.registerEffect('resizable-logo', {
   *   setUp: function(config) {
   *     // the effect's config is passed to the setUp.
   *     this._fxResizeLogo = { logo: Polymer.dom(this).querySelector('[logo]') };
   *   },
   *
   *   run: function(progress) {
   *      // the progress of the effect
   *      this.transform('scale3d(' + progress + ', '+ progress +', 1)',
   * this._fxResizeLogo.logo);
   *   },
   *
   *   tearDown: function() {
   *      // clean up and reset of states
   *      delete this._fxResizeLogo;
   *   }
   * });
   * ```
   * Now, you can consume the effect:
   *
   * ```html
   * <app-header id="appHeader" effects="resizable-logo">
   *   <img logo src="logo.svg">
   * </app-header>
   * ```
   *
   * ### Imperative API
   *
   * ```js
   * var logoEffect = appHeader.createEffect('resizable-logo', effectConfig);
   * // run the effect: logoEffect.run(progress);
   * // tear down the effect: logoEffect.tearDown();
   * ```
   *
   * ### Configuring effects
   *
   * For effects installed via the `effects` property, their configuration can be
   * set via the `effectsConfig` property. For example:
   *
   * ```html
   * <app-header effects="waterfall"
   *   effects-config='{"waterfall": {"startsAt": 0, "endsAt": 0.5}}'>
   * </app-header>
   * ```
   *
   * All effects have a `startsAt` and `endsAt` config property. They specify at
   * what point the effect should start and end. This value goes from 0 to 1
   * inclusive.
   *
   * @polymerBehavior
   */Polymer.AppScrollEffectsBehavior=[Polymer.IronScrollTargetBehavior,{properties:{/**
         * A space-separated list of the effects names that will be triggered when
         * the user scrolls. e.g. `waterfall parallax-background` installs the
         * `waterfall` and `parallax-background`.
         */effects:{type:String},/**
         * An object that configurates the effects installed via the `effects`
         * property. e.g.
         * ```js
         *  element.effectsConfig = {
         *   "blend-background": {
         *     "startsAt": 0.5
         *   }
         * };
         * ```
         * Every effect has at least two config properties: `startsAt` and
         * `endsAt`. These properties indicate when the event should start and end
         * respectively and relative to the overall element progress. So for
         * example, if `blend-background` starts at `0.5`, the effect will only
         * start once the current element reaches 0.5 of its progress. In this
         * context, the progress is a value in the range of `[0, 1]` that
         * indicates where this element is on the screen relative to the viewport.
         */effectsConfig:{type:Object,value:function(){return{}}},/**
         * Disables CSS transitions and scroll effects on the element.
         */disabled:{type:Boolean,reflectToAttribute:!0,value:!1},/**
         * Allows to set a `scrollTop` threshold. When greater than 0,
         * `thresholdTriggered` is true only when the scroll target's `scrollTop`
         * has reached this value.
         *
         * For example, if `threshold = 100`, `thresholdTriggered` is true when
         * the `scrollTop` is at least `100`.
         */threshold:{type:Number,value:0},/**
         * True if the `scrollTop` threshold (set in `scrollTopThreshold`) has
         * been reached.
         */thresholdTriggered:{type:Boolean,notify:!0,readOnly:!0,reflectToAttribute:!0}},observers:["_effectsChanged(effects, effectsConfig, isAttached)"],/**
       * Updates the scroll state. This method should be overridden
       * by the consumer of this behavior.
       *
       * @method _updateScrollState
       * @param {number} scrollTop
       */_updateScrollState:function(scrollTop){},/**
       * Returns true if the current element is on the screen.
       * That is, visible in the current viewport. This method should be
       * overridden by the consumer of this behavior.
       *
       * @method isOnScreen
       * @return {boolean}
       */isOnScreen:function(){return!1},/**
       * Returns true if there's content below the current element. This method
       * should be overridden by the consumer of this behavior.
       *
       * @method isContentBelow
       * @return {boolean}
       */isContentBelow:function(){return!1},/**
       * List of effects handlers that will take place during scroll.
       *
       * @type {Array<Function>}
       */_effectsRunFn:null,/**
       * List of the effects definitions installed via the `effects` property.
       *
       * @type {Array<Object>}
       */_effects:null,/**
       * The clamped value of `_scrollTop`.
       * @type number
       */get _clampedScrollTop(){return Math.max(0,this._scrollTop)},detached:function(){this._tearDownEffects()},/**
       * Creates an effect object from an effect's name that can be used to run
       * effects programmatically.
       *
       * @method createEffect
       * @param {string} effectName The effect's name registered via `Polymer.AppLayout.registerEffect`.
       * @param {Object=} effectConfig The effect config object. (Optional)
       * @return {Object} An effect object with the following functions:
       *
       *  * `effect.setUp()`, Sets up the requirements for the effect.
       *       This function is called automatically before the `effect` function
       * returns.
       *  * `effect.run(progress, y)`, Runs the effect given a `progress`.
       *  * `effect.tearDown()`, Cleans up any DOM nodes or element references
       * used by the effect.
       *
       * Example:
       * ```js
       * var parallax = element.createEffect('parallax-background');
       * // runs the effect
       * parallax.run(0.5, 0);
       * ```
       */createEffect:function(effectName,effectConfig){var effectDef=Polymer.AppLayout._scrollEffects[effectName];if(!effectDef){throw new ReferenceError(this._getUndefinedMsg(effectName))}var prop=this._boundEffect(effectDef,effectConfig||{});prop.setUp();return prop},/**
       * Called when `effects` or `effectsConfig` changes.
       */_effectsChanged:function(effects,effectsConfig,isAttached){this._tearDownEffects();if(!effects||!isAttached){return}effects.split(" ").forEach(function(effectName){var effectDef;if(""!==effectName){if(effectDef=Polymer.AppLayout._scrollEffects[effectName]){this._effects.push(this._boundEffect(effectDef,effectsConfig[effectName]))}else{console.warn(this._getUndefinedMsg(effectName))}}},this);this._setUpEffect()},/**
       * Forces layout
       */_layoutIfDirty:function(){return this.offsetWidth},/**
       * Returns an effect object bound to the current context.
       *
       * @param {Object} effectDef
       * @param {Object=} effectsConfig The effect config object if the effect accepts config values. (Optional)
       */_boundEffect:function(effectDef,effectsConfig){effectsConfig=effectsConfig||{};var startsAt=parseFloat(effectsConfig.startsAt||0),endsAt=parseFloat(effectsConfig.endsAt||1),deltaS=endsAt-startsAt,noop=function(){},runFn=0===startsAt&&1===endsAt?effectDef.run:function(progress,y){effectDef.run.call(this,Math.max(0,(progress-startsAt)/deltaS),y)};return{setUp:effectDef.setUp?effectDef.setUp.bind(this,effectsConfig):noop,run:effectDef.run?runFn.bind(this):noop,tearDown:effectDef.tearDown?effectDef.tearDown.bind(this):noop}},/**
       * Sets up the effects.
       */_setUpEffect:function(){if(this.isAttached&&this._effects){this._effectsRunFn=[];this._effects.forEach(function(effectDef){// install the effect only if no error was reported
if(!1!==effectDef.setUp()){this._effectsRunFn.push(effectDef.run)}},this)}},/**
       * Tears down the effects.
       */_tearDownEffects:function(){if(this._effects){this._effects.forEach(function(effectDef){effectDef.tearDown()})}this._effectsRunFn=[];this._effects=[]},/**
       * Runs the effects.
       *
       * @param {number} p The progress
       * @param {number} y The top position of the current element relative to the viewport.
       */_runEffects:function(p,y){if(this._effectsRunFn){this._effectsRunFn.forEach(function(run){run(p,y)})}},/**
       * Overrides the `_scrollHandler`.
       */_scrollHandler:function(){if(!this.disabled){var scrollTop=this._clampedScrollTop;this._updateScrollState(scrollTop);if(0<this.threshold){this._setThresholdTriggered(scrollTop>=this.threshold)}}},/**
       * Override this method to return a reference to a node in the local DOM.
       * The node is consumed by a scroll effect.
       *
       * @param {string} id The id for the node.
       */_getDOMRef:function(id){console.warn("_getDOMRef","`"+id+"` is undefined")},_getUndefinedMsg:function(effectName){return"Scroll effect `"+effectName+"` is undefined. "+"Did you forget to import app-layout/app-scroll-effects/effects/"+effectName+".html ?"}}];</script><dom-module id="app-header" assetpath="../bower_components/app-layout/app-header/"><template><style>:host{position:relative;display:block;transition-timing-function:linear;transition-property:-webkit-transform;transition-property:transform;}:host::before{position:absolute;right:0px;bottom:-5px;left:0px;width:100%;height:5px;content:"";transition:opacity 0.4s;pointer-events:none;opacity:0;box-shadow:inset 0px 5px 6px -3px rgba(0, 0, 0, 0.4);will-change:opacity;@apply --app-header-shadow;}:host([shadow])::before{opacity:1;}#background{@apply --layout-fit;overflow:hidden;}#backgroundFrontLayer,
      #backgroundRearLayer{@apply --layout-fit;height:100%;pointer-events:none;background-size:cover;}#backgroundFrontLayer{@apply --app-header-background-front-layer;}#backgroundRearLayer{opacity:0;@apply --app-header-background-rear-layer;}#contentContainer{position:relative;width:100%;height:100%;}:host([disabled]),
      :host([disabled])::after,
      :host([disabled]) #backgroundFrontLayer,
      :host([disabled]) #backgroundRearLayer,
      /* Silent scrolling should not run CSS transitions */
      :host([silent-scroll]),
      :host([silent-scroll])::after,
      :host([silent-scroll]) #backgroundFrontLayer,
      :host([silent-scroll]) #backgroundRearLayer{transition:none !important;}:host([disabled]) ::slotted(app-toolbar:first-of-type),
      :host([disabled]) ::slotted([sticky]),
      /* Silent scrolling should not run CSS transitions */
      :host([silent-scroll]) ::slotted(app-toolbar:first-of-type),
      :host([silent-scroll]) ::slotted([sticky]){transition:none !important;}</style><div id="contentContainer"><slot id="slot"></slot></div></template><script>Polymer({is:"app-header",behaviors:[Polymer.AppScrollEffectsBehavior,Polymer.AppLayoutBehavior],properties:{/**
         * If true, the header will automatically collapse when scrolling down.
         * That is, the `sticky` element remains visible when the header is fully
         *condensed whereas the rest of the elements will collapse below `sticky`
         *element.
         *
         * By default, the `sticky` element is the first toolbar in the light DOM:
         *
         *```html
         * <app-header condenses>
         *   <app-toolbar>This toolbar remains on top</app-toolbar>
         *   <app-toolbar></app-toolbar>
         *   <app-toolbar></app-toolbar>
         * </app-header>
         * ```
         *
         * Additionally, you can specify which toolbar or element remains visible in
         *condensed mode by adding the `sticky` attribute to that element. For
         *example: if we want the last toolbar to remain visible, we can add the
         *`sticky` attribute to it.
         *
         *```html
         * <app-header condenses>
         *   <app-toolbar></app-toolbar>
         *   <app-toolbar></app-toolbar>
         *   <app-toolbar sticky>This toolbar remains on top</app-toolbar>
         * </app-header>
         * ```
         *
         * Note the `sticky` element must be a direct child of `app-header`.
         */condenses:{type:Boolean,value:!1},/**
         * Mantains the header fixed at the top so it never moves away.
         */fixed:{type:Boolean,value:!1},/**
         * Slides back the header when scrolling back up.
         */reveals:{type:Boolean,value:!1},/**
         * Displays a shadow below the header.
         */shadow:{type:Boolean,reflectToAttribute:!0,value:!1}},observers:["_configChanged(isAttached, condenses, fixed)"],/**
       * A cached offsetHeight of the current element.
       *
       * @type {number}
       */_height:0,/**
       * The distance in pixels the header will be translated to when scrolling.
       *
       * @type {number}
       */_dHeight:0,/**
       * The offsetTop of `_stickyEl`
       *
       * @type {number}
       */_stickyElTop:0,/**
       * A reference to the element that remains visible when the header condenses.
       *
       * @type {HTMLElement}
       */_stickyElRef:null,/**
       * The header's top value used for the `transformY`
       *
       * @type {number}
       */_top:0,/**
       * The current scroll progress.
       *
       * @type {number}
       */_progress:0,_wasScrollingDown:!1,_initScrollTop:0,_initTimestamp:0,_lastTimestamp:0,_lastScrollTop:0,/**
       * The distance the header is allowed to move away.
       *
       * @type {number}
       */get _maxHeaderTop(){return this.fixed?this._dHeight:this._height+5},/**
       * Returns a reference to the sticky element.
       *
       * @return {HTMLElement}?
       */get _stickyEl(){if(this._stickyElRef){return this._stickyElRef}// Get the element with the sticky attribute on it or the first element in
// the light DOM.
for(var nodes=Polymer.dom(this.$.slot).getDistributedNodes(),i=0,node;node=/** @type {!HTMLElement} */nodes[i];i++){if(node.nodeType===Node.ELEMENT_NODE){if(node.hasAttribute("sticky")){this._stickyElRef=node;break}else if(!this._stickyElRef){this._stickyElRef=node}}}return this._stickyElRef},_configChanged:function(){this.resetLayout();this._notifyLayoutChanged()},_updateLayoutStates:function(){if(0===this.offsetWidth&&0===this.offsetHeight){return}var scrollTop=this._clampedScrollTop,firstSetup=0===this._height||0===scrollTop,currentDisabled=this.disabled;this._height=this.offsetHeight;this._stickyElRef=null;this.disabled=!0;// prepare for measurement
if(!firstSetup){this._updateScrollState(0,!0)}if(this._mayMove()){this._dHeight=this._stickyEl?this._height-this._stickyEl.offsetHeight:0}else{this._dHeight=0}this._stickyElTop=this._stickyEl?this._stickyEl.offsetTop:0;this._setUpEffect();if(firstSetup){this._updateScrollState(scrollTop,!0)}else{this._updateScrollState(this._lastScrollTop,!0);this._layoutIfDirty()}// restore no transition
this.disabled=currentDisabled},/**
       * Updates the scroll state.
       *
       * @param {number} scrollTop
       * @param {boolean=} forceUpdate (default: false)
       */_updateScrollState:function(scrollTop,forceUpdate){if(0===this._height){return}var progress=0,top=0,lastTop=this._top,lastScrollTop=this._lastScrollTop,maxHeaderTop=this._maxHeaderTop,dScrollTop=scrollTop-this._lastScrollTop,absDScrollTop=Math.abs(dScrollTop),isScrollingDown=scrollTop>this._lastScrollTop,now=performance.now();if(this._mayMove()){top=this._clamp(this.reveals?lastTop+dScrollTop:scrollTop,0,maxHeaderTop)}if(scrollTop>=this._dHeight){top=this.condenses&&!this.fixed?Math.max(this._dHeight,top):top;this.style.transitionDuration="0ms"}if(this.reveals&&!this.disabled&&100>absDScrollTop){// set the initial scroll position
if(300<now-this._initTimestamp||this._wasScrollingDown!==isScrollingDown){this._initScrollTop=scrollTop;this._initTimestamp=now}if(scrollTop>=maxHeaderTop){// check if the header is allowed to snap
if(30<Math.abs(this._initScrollTop-scrollTop)||10<absDScrollTop){if(isScrollingDown&&scrollTop>=maxHeaderTop){top=maxHeaderTop}else if(!isScrollingDown&&scrollTop>=this._dHeight){top=this.condenses&&!this.fixed?this._dHeight:0}var scrollVelocity=dScrollTop/(now-this._lastTimestamp);this.style.transitionDuration=this._clamp((top-lastTop)/scrollVelocity,0,300)+"ms"}else{top=this._top}}}if(0===this._dHeight){progress=0<scrollTop?1:0}else{progress=top/this._dHeight}if(!forceUpdate){this._lastScrollTop=scrollTop;this._top=top;this._wasScrollingDown=isScrollingDown;this._lastTimestamp=now}if(forceUpdate||progress!==this._progress||lastTop!==top||0===scrollTop){this._progress=progress;this._runEffects(progress,top);this._transformHeader(top)}},/**
       * Returns true if the current header is allowed to move as the user scrolls.
       *
       * @return {boolean}
       */_mayMove:function(){return this.condenses||!this.fixed},/**
       * Returns true if the current header will condense based on the size of the
       * header and the `consenses` property.
       *
       * @return {boolean}
       */willCondense:function(){return 0<this._dHeight&&this.condenses},/**
       * Returns true if the current element is on the screen.
       * That is, visible in the current viewport.
       *
       * @method isOnScreen
       * @return {boolean}
       */isOnScreen:function(){return 0!==this._height&&this._top<this._height},/**
       * Returns true if there's content below the current element.
       *
       * @method isContentBelow
       * @return {boolean}
       */isContentBelow:function(){return 0===this._top?0<this._clampedScrollTop:0<=this._clampedScrollTop-this._maxHeaderTop},/**
       * Transforms the header.
       *
       * @param {number} y
       */_transformHeader:function(y){this.translate3d(0,-y+"px",0);if(this._stickyEl){this.translate3d(0,this.condenses&&y>=this._stickyElTop?Math.min(y,this._dHeight)-this._stickyElTop+"px":0,0,this._stickyEl)}},_clamp:function(v,min,max){return Math.min(max,Math.max(min,v))},_ensureBgContainers:function(){if(!this._bgContainer){this._bgContainer=document.createElement("div");this._bgContainer.id="background";this._bgRear=document.createElement("div");this._bgRear.id="backgroundRearLayer";this._bgContainer.appendChild(this._bgRear);this._bgFront=document.createElement("div");this._bgFront.id="backgroundFrontLayer";this._bgContainer.appendChild(this._bgFront);Polymer.dom(this.root).insertBefore(this._bgContainer,this.$.contentContainer)}},_getDOMRef:function(id){switch(id){case"backgroundFrontLayer":this._ensureBgContainers();return this._bgFront;case"backgroundRearLayer":this._ensureBgContainers();return this._bgRear;case"background":this._ensureBgContainers();return this._bgContainer;case"mainTitle":return Polymer.dom(this).querySelector("[main-title]");case"condensedTitle":return Polymer.dom(this).querySelector("[condensed-title]");}return null},/**
       * Returns an object containing the progress value of the scroll effects
       * and the top position of the header.
       *
       * @method getScrollState
       * @return {Object}
       */getScrollState:function(){return{progress:this._progress,top:this._top}}});</script></dom-module><dom-module id="nav-bar"><template><style include="lumo-color-legacy">:host{display:flex;align-items:center;box-sizing:border-box;width:100%;height:64px;padding:0 var(--lumo-space-m);}h1{margin-right:auto;font-size:var(--lumo-font-size-xl);}vaadin-button{margin-left:var(--lumo-space-m);text-transform:uppercase;flex-shrink:0;}@media (max-width: 600px){h1{font-size:var(--lumo-font-size-m);}}</style><h1>Expense Manager</h1><vaadin-button on-click="_showInfoDialog" theme="small">Info</vaadin-button><vaadin-button on-click="_logout" theme="small">Logout</vaadin-button></template><script>(function(){/**
       * @memberof ExpenseManager
       */class NavBarElement extends ExpenseManager.ReduxMixin(Polymer.Element){static get is(){return"nav-bar"}_showInfoDialog(){this.dispatch("showInfoDialog")}_logout(){this.dispatch("logout")}}customElements.define(NavBarElement.is,NavBarElement);/**
       * @namespace ExpenseManager
       */window.ExpenseManager=window.ExpenseManager||{};ExpenseManager.NavBarElement=NavBarElement})();</script></dom-module><dom-module id="lumo-overlay" assetpath="../bower_components/vaadin-lumo-styles/mixins/"><template><style>:host{top:var(--lumo-space-m);right:var(--lumo-space-m);bottom:var(--lumo-space-m);left:var(--lumo-space-m);outline:0px solid transparent;}[part="overlay"]{background-color:var(--lumo-base-color);background-image:linear-gradient(var(--lumo-tint-5pct), var(--lumo-tint-5pct));border-radius:var(--lumo-border-radius-m);box-shadow:0 0 0 1px var(--lumo-shade-5pct), var(--lumo-box-shadow-m);color:var(--lumo-body-text-color);font-family:var(--lumo-font-family);font-size:var(--lumo-font-size-m);font-weight:400;line-height:var(--lumo-line-height-m);letter-spacing:0;text-transform:none;-webkit-text-size-adjust:100%;-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale;}[part="content"]{padding:var(--lumo-space-xs);}[part="backdrop"]{background-color:var(--lumo-shade-20pct);animation:0.2s lumo-overlay-backdrop-enter both;will-change:opacity;}@keyframes lumo-overlay-backdrop-enter{0%{opacity:0;}}:host([closing]) [part="backdrop"]{animation:0.2s lumo-overlay-backdrop-exit both;}@keyframes lumo-overlay-backdrop-exit{100%{opacity:0;}}@keyframes lumo-overlay-dummy-animation{0%{opacity:1;}100%{opacity:1;}}</style></template></dom-module><dom-module id="lumo-vaadin-overlay" theme-for="vaadin-overlay" assetpath="../bower_components/vaadin-overlay/theme/lumo/"><template><style include="lumo-overlay"></style></template></dom-module><script>/**
  @license
  Copyright (c) 2016 The Polymer Project Authors. All rights reserved.
  This code may only be used under the BSD style license found at
  http://polymer.github.io/LICENSE.txt The complete set of authors may be found at
  http://polymer.github.io/AUTHORS.txt The complete set of contributors may be
  found at http://polymer.github.io/CONTRIBUTORS.txt Code distributed by Google as
  part of the polymer project is also subject to an additional IP rights grant
  found at http://polymer.github.io/PATENTS.txt
  */ // NOTE(web-padawan): copied from the iron-overlay-behavior 3.0.1
// and excluded from code coverage intentionally as external code.
/* istanbul ignore next */(function(){'use strict';const p=Element.prototype,matches=p.matches||p.matchesSelector||p.mozMatchesSelector||p.msMatchesSelector||p.oMatchesSelector||p.webkitMatchesSelector,FocusablesHelper={/**
       * Returns a sorted array of tabbable nodes, including the root node.
       * It searches the tabbable nodes in the light and shadow dom of the children,
       * sorting the result by tabindex.
       * @param {!Node} node
       * @return {!Array<!HTMLElement>}
       */getTabbableNodes:function(node){const result=[],needsSortByTabIndex=this._collectTabbableNodes(node,result);// If there is at least one element with tabindex > 0, we need to sort
// the final array by tabindex.
if(needsSortByTabIndex){return this._sortByTabIndex(result)}return result},/**
       * Returns if a element is focusable.
       * @param {!HTMLElement} element
       * @return {boolean}
       */isFocusable:function(element){// From http://stackoverflow.com/a/1600194/4228703:
// There isn't a definite list, it's up to the browser. The only
// standard we have is DOM Level 2 HTML
// https://www.w3.org/TR/DOM-Level-2-HTML/html.html, according to which the
// only elements that have a focus() method are HTMLInputElement,
// HTMLSelectElement, HTMLTextAreaElement and HTMLAnchorElement. This
// notably omits HTMLButtonElement and HTMLAreaElement. Referring to these
// tests with tabbables in different browsers
// http://allyjs.io/data-tables/focusable.html
// Elements that cannot be focused if they have [disabled] attribute.
if(matches.call(element,"input, select, textarea, button, object")){return matches.call(element,":not([disabled])")}// Elements that can be focused even if they have [disabled] attribute.
return matches.call(element,"a[href], area[href], iframe, [tabindex], [contentEditable]")},/**
       * Returns if a element is tabbable. To be tabbable, a element must be
       * focusable, visible, and with a tabindex !== -1.
       * @param {!HTMLElement} element
       * @return {boolean}
       */isTabbable:function(element){return this.isFocusable(element)&&matches.call(element,":not([tabindex=\"-1\"])")&&this._isVisible(element)},/**
       * Returns the normalized element tabindex. If not focusable, returns -1.
       * It checks for the attribute "tabindex" instead of the element property
       * `tabIndex` since browsers assign different values to it.
       * e.g. in Firefox `<div contenteditable>` has `tabIndex = -1`
       * @param {!HTMLElement} element
       * @return {!number}
       * @private
       */_normalizedTabIndex:function(element){if(this.isFocusable(element)){const tabIndex=element.getAttribute("tabindex")||0;return+tabIndex}return-1},/**
       * Searches for nodes that are tabbable and adds them to the `result` array.
       * Returns if the `result` array needs to be sorted by tabindex.
       * @param {!Node} node The starting point for the search; added to `result` if tabbable.
       * @param {!Array<!HTMLElement>} result
       * @return {boolean}
       * @private
       */_collectTabbableNodes:function(node,result){// If not an element or not visible, no need to explore children.
if(node.nodeType!==Node.ELEMENT_NODE||!this._isVisible(node)){return!1}const element=/** @type {!HTMLElement} */node,tabIndex=this._normalizedTabIndex(element);let needsSort=0<tabIndex;if(0<=tabIndex){result.push(element)}// In ShadowDOM v1, tab order is affected by the order of distribution.
// E.g. getTabbableNodes(#root) in ShadowDOM v1 should return [#A, #B];
// in ShadowDOM v0 tab order is not affected by the distribution order,
// in fact getTabbableNodes(#root) returns [#B, #A].
//  <div id="root">
//   <!-- shadow -->
//     <slot name="a">
//     <slot name="b">
//   <!-- /shadow -->
//   <input id="A" slot="a">
//   <input id="B" slot="b" tabindex="1">
//  </div>
let children;if("slot"===element.localName){children=element.assignedNodes({flatten:!0})}else{// Use shadow root if possible, will check for distributed nodes.
children=(element.shadowRoot||element).children}if(children){for(let i=0;i<children.length;i++){// Ensure method is always invoked to collect tabbable children.
needsSort=this._collectTabbableNodes(children[i],result)||needsSort}}return needsSort},/**
       * Returns false if the element has `visibility: hidden` or `display: none`
       * @param {!HTMLElement} element
       * @return {boolean}
       * @private
       */_isVisible:function(element){// Check inline style first to save a re-flow. If looks good, check also
// computed style.
let style=element.style;if("hidden"!==style.visibility&&"none"!==style.display){style=window.getComputedStyle(element);return"hidden"!==style.visibility&&"none"!==style.display}return!1},/**
       * Sorts an array of tabbable elements by tabindex. Returns a new array.
       * @param {!Array<!HTMLElement>} tabbables
       * @return {!Array<!HTMLElement>}
       * @private
       */_sortByTabIndex:function(tabbables){// Implement a merge sort as Array.prototype.sort does a non-stable sort
// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/sort
const len=tabbables.length;if(2>len){return tabbables}const pivot=Math.ceil(len/2),left=this._sortByTabIndex(tabbables.slice(0,pivot)),right=this._sortByTabIndex(tabbables.slice(pivot));return this._mergeSortByTabIndex(left,right)},/**
       * Merge sort iterator, merges the two arrays into one, sorted by tab index.
       * @param {!Array<!HTMLElement>} left
       * @param {!Array<!HTMLElement>} right
       * @return {!Array<!HTMLElement>}
       * @private
       */_mergeSortByTabIndex:function(left,right){const result=[];while(0<left.length&&0<right.length){if(this._hasLowerTabOrder(left[0],right[0])){result.push(right.shift())}else{result.push(left.shift())}}return result.concat(left,right)},/**
       * Returns if element `a` has lower tab order compared to element `b`
       * (both elements are assumed to be focusable and tabbable).
       * Elements with tabindex = 0 have lower tab order compared to elements
       * with tabindex > 0.
       * If both have same tabindex, it returns false.
       * @param {!HTMLElement} a
       * @param {!HTMLElement} b
       * @return {boolean}
       * @private
       */_hasLowerTabOrder:function(a,b){// Normalize tabIndexes
// e.g. in Firefox `<div contenteditable>` has `tabIndex = -1`
const ati=Math.max(a.tabIndex,0),bti=Math.max(b.tabIndex,0);return 0===ati||0===bti?bti>ati:ati>bti}};/**
     * @namespace Vaadin
     */window.Vaadin=window.Vaadin||{};Vaadin.FocusablesHelper=FocusablesHelper})();</script><dom-module id="vaadin-overlay" assetpath="../bower_components/vaadin-overlay/src/"><template><style>:host{z-index:200;position:fixed;top:0;right:0;bottom:var(--vaadin-overlay-viewport-bottom);left:0;display:flex;flex-direction:column;align-items:center;justify-content:center;margin:auto;pointer-events:none;-webkit-tap-highlight-color:transparent;--vaadin-overlay-viewport-bottom:0;}:host([hidden]),
      :host(:not([opened]):not([closing])){display:none !important;}[part="overlay"]{-webkit-overflow-scrolling:touch;overflow:auto;pointer-events:auto;max-width:100%;box-sizing:border-box;-webkit-tap-highlight-color:initial;}[part="backdrop"]{z-index:-1;content:"";background:rgba(0, 0, 0, 0.5);position:fixed;top:0;left:0;bottom:0;right:0;pointer-events:auto;}</style><div id="backdrop" part="backdrop" hidden$="{{!withBackdrop}}"></div><div part="overlay" id="overlay" tabindex="0"><div part="content" id="content"><slot></slot></div></div></template></dom-module><script>(function(){let overlayContentCounter=0;const overlayContentCache={},createOverlayContent=cssText=>{const is=overlayContentCache[cssText]||processOverlayStyles(cssText);return document.createElement(is)},processOverlayStyles=cssText=>{overlayContentCounter++;const is=`vaadin-overlay-content-${overlayContentCounter}`,styledTemplate=document.createElement("template"),style=document.createElement("style");style.textContent=":host { display: block; }"+cssText;styledTemplate.content.appendChild(style);if(window.ShadyCSS){window.ShadyCSS.prepareTemplate(styledTemplate,is)}// NOTE(platosha): Have to use an awkward IIFE returning class here
// to prevent this class from showing up in analysis.json & API docs.
/** @private */const klass=(()=>class extends HTMLElement{static get is(){return is}constructor(){super();if(!this.shadowRoot){this.attachShadow({mode:"open"});this.shadowRoot.appendChild(document.importNode(styledTemplate.content,!0))}}connectedCallback(){if(window.ShadyCSS){window.ShadyCSS.styleElement(this)}}})();customElements.define(klass.is,klass);overlayContentCache[cssText]=is;return is};/**
     *
     * `<vaadin-overlay>` is a Web Component for creating overlays. The content of the overlay
     * can be populated in two ways: imperatively by using renderer callback function and
     * declaratively by using Polymer's Templates.
     *
     * ### Rendering
     *
     * By default, the overlay uses the content provided by using the renderer callback function.
     *
     * The renderer function provides `root`, `owner`, `model` arguments when applicable.
     * Generate DOM content by using `model` object properties if needed, append it to the `root`
     * element and control the state of the host element by accessing `owner`. Before generating new
     * content, users are able to check if there is already content in `root` for reusing it.
     *
     * ```html
     * <vaadin-overlay id="overlay"></vaadin-overlay>
     * ```
     * ```js
     * const overlay = document.querySelector('#overlay');
     * overlay.renderer = function(root) {
     *  root.textContent = "Overlay content";
     * };
     * ```
     *
     * Renderer is called on the opening of the overlay and each time the related model is updated.
     * DOM generated during the renderer call can be reused
     * in the next renderer call and will be provided with the `root` argument.
     * On first call it will be empty.
     *
     * **NOTE:** when the renderer property is defined, the `<template>` content is not used.
     *
     * ### Templating
     *
     * Alternatively, the content can be provided with Polymer Template.
     * Overlay finds the first child template and uses that in case renderer callback function
     * is not provided. You can also set a custom template using the `template` property.
     *
     * After the content from the template is stamped, the `content` property
     * points to the content container.
     *
     * The overlay provides `forwardHostProp` when calling
     * `Polymer.Templatize.templatize` for the template, so that the bindings
     * from the parent scope propagate to the content.  You can also pass
     * custom `instanceProps` object using the `instanceProps` property.
     *
     * ```html
     * <vaadin-overlay>
     *   <template>Overlay content</template>
     * </vaadin-overlay>
     * ```
     *
     * **NOTE:** when using `instanceProps`: because of the Polymer limitation,
     * every template can only be templatized once, so it is important
     * to set `instanceProps` before the `template` is assigned to the overlay.
     *
     * ### Styling
     *
     * To style the overlay content, use styles in the parent scope:
     *
     * - If the overlay is used in a component, then the component styles
     *   apply the overlay content.
     * - If the overlay is used in the global DOM scope, then global styles
     *   apply to the overlay content.
     *
     * See examples for styling the overlay content in the live demos.
     *
     * The following Shadow DOM parts are available for styling the overlay component itself:
     *
     * Part name  | Description
     * -----------|---------------------------------------------------------|
     * `backdrop` | Backdrop of the overlay
     * `overlay`  | Container for position/sizing/alignment of the content
     * `content`  | Content of the overlay
     *
     * The following state attributes are available for styling:
     *
     * Attribute | Description | Part
     * ---|---|---
     * `opening` | Applied just after the overlay is attached to the DOM. You can apply a CSS @keyframe animation for this state. | `:host`
     * `closing` | Applied just before the overlay is detached from the DOM. You can apply a CSS @keyframe animation for this state. | `:host`
     *
     * The following custom CSS properties are available for styling:
     *
     * Custom CSS property | Description | Default value
     * ---|---|---
     * `--vaadin-overlay-viewport-bottom` | Bottom offset of the visible viewport area | `0` or detected offset
     *
     * See [ThemableMixin – how to apply styles for shadow parts](https://github.com/vaadin/vaadin-themable-mixin/wiki)
     *
     * @memberof Vaadin
     * @mixes Vaadin.ThemableMixin
     * @demo demo/index.html
     */class OverlayElement extends Vaadin.ThemableMixin(Vaadin.DirMixin(Polymer.Element)){static get is(){return"vaadin-overlay"}static get properties(){return{opened:{type:Boolean,notify:!0,observer:"_openedChanged",reflectToAttribute:!0},/**
           * Owner element passed with renderer function
           */owner:Element,/**
           * Custom function for rendering the content of the overlay.
           * Receives three arguments:
           *
           * - `root` The root container DOM element. Append your content to it.
           * - `owner` The host element of the renderer function.
           * - `model` The object with the properties related with rendering.
           */renderer:Function,/**
           * The template of the overlay content.
           */template:{type:Object,notify:!0},/**
           * Optional argument for `Polymer.Templatize.templatize`.
           */instanceProps:{type:Object},/**
           * References the content container after the template is stamped.
           */content:{type:Object,notify:!0},withBackdrop:{type:Boolean,value:!1,reflectToAttribute:!0},/**
           * Object with properties that is passed to `renderer` function
           */model:Object,/**
           * When true the overlay won't disable the main content, showing
           * it doesn’t change the functionality of the user interface.
           */modeless:{type:Boolean,value:!1,reflectToAttribute:!0,observer:"_modelessChanged"},/**
           * When set to true, the overlay is hidden. This also closes the overlay
           * immediately in case there is a closing animation in progress.
           */hidden:{type:Boolean,reflectToAttribute:!0,observer:"_hiddenChanged"},/**
           * When true move focus to the first focusable element in the overlay,
           * or to the overlay if there are no focusable elements.
           */focusTrap:{type:Boolean,value:!1},/**
           * Set to true to enable restoring of focus when overlay is closed.
           */restoreFocusOnClose:{type:Boolean,value:!1},_mouseDownInside:{type:Boolean},_mouseUpInside:{type:Boolean},_instance:{type:Object},_originalContentPart:Object,_contentNodes:Array,_oldOwner:Element,_oldModel:Object,_oldTemplate:Object,_oldInstanceProps:Object,_oldRenderer:Object,_oldOpened:Boolean}}static get observers(){return["_templateOrRendererChanged(template, renderer, owner, model, instanceProps, opened)"]}constructor(){super();this._boundMouseDownListener=this._mouseDownListener.bind(this);this._boundMouseUpListener=this._mouseUpListener.bind(this);this._boundOutsideClickListener=this._outsideClickListener.bind(this);this._boundKeydownListener=this._keydownListener.bind(this);this._observer=new Polymer.FlattenedNodesObserver(this,info=>{this._setTemplateFromNodes(info.addedNodes)});// Listener for preventing closing of the paper-dialog and all components extending `iron-overlay-behavior`.
this._boundIronOverlayCanceledListener=this._ironOverlayCanceled.bind(this);if(/iPad|iPhone|iPod/.test(navigator.userAgent)){this._boundIosResizeListener=()=>this._detectIosNavbar()}}ready(){super.ready();this._observer.flush();// Need to add dummy click listeners to this and the backdrop or else
// the document click event listener (_outsideClickListener) may never
// get invoked on iOS Safari (reproducible in <vaadin-dialog>
// and <vaadin-context-menu>).
this.addEventListener("click",()=>{});this.$.backdrop.addEventListener("click",()=>{})}_detectIosNavbar(){if(!this.opened){return}const innerHeight=window.innerHeight,innerWidth=window.innerWidth,landscape=innerWidth>innerHeight,clientHeight=document.documentElement.clientHeight;if(landscape&&clientHeight>innerHeight){this.style.setProperty("--vaadin-overlay-viewport-bottom",clientHeight-innerHeight+"px")}else{this.style.setProperty("--vaadin-overlay-viewport-bottom","0")}}_setTemplateFromNodes(nodes){this.template=nodes.filter(node=>node.localName&&"template"===node.localName)[0]||this.template}/**
       * @event vaadin-overlay-close
       * fired before the `vaadin-overlay` will be closed. If canceled the closing of the overlay is canceled as well.
       */close(sourceEvent){var evt=new CustomEvent("vaadin-overlay-close",{bubbles:!0,cancelable:!0,detail:{sourceEvent:sourceEvent}});this.dispatchEvent(evt);if(!evt.defaultPrevented){this.opened=!1}}connectedCallback(){super.connectedCallback();if(this._boundIosResizeListener){this._detectIosNavbar();window.addEventListener("resize",this._boundIosResizeListener)}}disconnectedCallback(){super.disconnectedCallback();this._boundIosResizeListener&&window.removeEventListener("resize",this._boundIosResizeListener)}_ironOverlayCanceled(event){event.preventDefault()}_mouseDownListener(event){this._mouseDownInside=0<=event.composedPath().indexOf(this.$.overlay)}_mouseUpListener(event){this._mouseUpInside=0<=event.composedPath().indexOf(this.$.overlay)}/**
       * We need to listen on 'click' / 'tap' event and capture it and close the overlay before
       * propagating the event to the listener in the button. Otherwise, if the clicked button would call
       * open(), this would happen: https://www.youtube.com/watch?v=Z86V_ICUCD4
       *
       * @event vaadin-overlay-outside-click
       * fired before the `vaadin-overlay` will be closed on outside click. If canceled the closing of the overlay is canceled as well.
       */_outsideClickListener(event){if(-1!==event.composedPath().indexOf(this.$.overlay)||this._mouseDownInside||this._mouseUpInside){this._mouseDownInside=!1;this._mouseUpInside=!1;return}if(!this._last){return}const evt=new CustomEvent("vaadin-overlay-outside-click",{bubbles:!0,cancelable:!0,detail:{sourceEvent:event}});this.dispatchEvent(evt);if(this.opened&&!evt.defaultPrevented){this.close(event)}}/**
       * @event vaadin-overlay-escape-press
       * fired before the `vaadin-overlay` will be closed on ESC button press. If canceled the closing of the overlay is canceled as well.
       */_keydownListener(event){if(!this._last){return}// TAB
if("Tab"===event.key&&this.focusTrap&&!event.defaultPrevented){// if only tab key is pressed, cycle forward, else cycle backwards.
this._cycleTab(event.shiftKey?-1:1);event.preventDefault();// ESC
}else if("Escape"===event.key||"Esc"===event.key){const evt=new CustomEvent("vaadin-overlay-escape-press",{bubbles:!0,cancelable:!0,detail:{sourceEvent:event}});this.dispatchEvent(evt);if(this.opened&&!evt.defaultPrevented){this.close(event)}}}_ensureTemplatized(){this._setTemplateFromNodes(Array.from(this.children))}/**
       * @event vaadin-overlay-open
       * fired after the `vaadin-overlay` is opened.
       */_openedChanged(opened,wasOpened){if(!this._instance){this._ensureTemplatized()}if(opened){// Store focused node.
this.__restoreFocusNode=this._getActiveElement();this._animatedOpening();Polymer.RenderStatus.afterNextRender(this,()=>{if(this.focusTrap&&!this.contains(document._activeElement||document.activeElement)){this._cycleTab(0,0)}const evt=new CustomEvent("vaadin-overlay-open",{bubbles:!0});this.dispatchEvent(evt)});if(!this.modeless){this._addGlobalListeners()}}else if(wasOpened){this._animatedClosing();if(!this.modeless){this._removeGlobalListeners()}}}_hiddenChanged(hidden){if(hidden&&this.hasAttribute("closing")){this._flushAnimation("closing")}}_shouldAnimate(){const name=getComputedStyle(this).getPropertyValue("animation-name"),hidden="none"===getComputedStyle(this).getPropertyValue("display");return!hidden&&name&&"none"!=name}_enqueueAnimation(type,callback){const handler=`__${type}Handler`,listener=event=>{if(event&&event.target!==this){return}callback();this.removeEventListener("animationend",listener);delete this[handler]};this[handler]=listener;this.addEventListener("animationend",listener)}_flushAnimation(type){const handler=`__${type}Handler`;if("function"===typeof this[handler]){this[handler]()}}_animatedOpening(){if(this.parentNode===document.body&&this.hasAttribute("closing")){this._flushAnimation("closing")}this._attachOverlay();if(!this.modeless){this._enterModalState()}this.setAttribute("opening","");const finishOpening=()=>{document.addEventListener("iron-overlay-canceled",this._boundIronOverlayCanceledListener);this.removeAttribute("opening")};if(this._shouldAnimate()){this._enqueueAnimation("opening",finishOpening)}else{finishOpening()}}_attachOverlay(){this._placeholder=document.createComment("vaadin-overlay-placeholder");this.parentNode.insertBefore(this._placeholder,this);document.body.appendChild(this);this.bringToFront()}_animatedClosing(){if(this.hasAttribute("opening")){this._flushAnimation("opening")}if(this._placeholder){this._exitModalState();if(this.restoreFocusOnClose&&this.__restoreFocusNode){// If the activeElement is `<body>` or inside the overlay,
// we are allowed to restore the focus. In all the other
// cases focus might have been moved elsewhere by another
// component or by the user interaction (e.g. click on a
// button outside the overlay).
const activeElement=this._getActiveElement();if(activeElement===document.body||this._deepContains(activeElement)){this.__restoreFocusNode.focus()}this.__restoreFocusNode=null}this.setAttribute("closing","");const finishClosing=()=>{document.removeEventListener("iron-overlay-canceled",this._boundIronOverlayCanceledListener);this._detachOverlay();this.shadowRoot.querySelector("[part=\"overlay\"]").style.removeProperty("pointer-events");this.removeAttribute("closing")};if(this._shouldAnimate()){this._enqueueAnimation("closing",finishClosing)}else{finishClosing()}}}_detachOverlay(){this._placeholder.parentNode.insertBefore(this,this._placeholder);this._placeholder.parentNode.removeChild(this._placeholder)}/**
       * Returns all attached overlays in visual stacking order.
       */static get __attachedInstances(){return Array.from(document.body.children).filter(el=>el instanceof OverlayElement&&!el.hasAttribute("closing")).sort((a,b)=>a.__zIndex-b.__zIndex||0)}/**
       * returns true if this is the last one in the opened overlays stack
       */get _last(){return this===OverlayElement.__attachedInstances.pop()}_modelessChanged(modeless){if(!modeless){if(this.opened){this._addGlobalListeners();this._enterModalState()}}else{this._removeGlobalListeners();this._exitModalState()}}_addGlobalListeners(){document.addEventListener("mousedown",this._boundMouseDownListener);document.addEventListener("mouseup",this._boundMouseUpListener);// Firefox leaks click to document on contextmenu even if prevented
// https://bugzilla.mozilla.org/show_bug.cgi?id=990614
document.documentElement.addEventListener("click",this._boundOutsideClickListener,!0);document.addEventListener("keydown",this._boundKeydownListener)}_enterModalState(){if("none"!==document.body.style.pointerEvents){// Set body pointer-events to 'none' to disable mouse interactions with
// other document nodes.
this._previousDocumentPointerEvents=document.body.style.pointerEvents;document.body.style.pointerEvents="none"}// Disable pointer events in other attached overlays
OverlayElement.__attachedInstances.forEach(el=>{if(el!==this){el.shadowRoot.querySelector("[part=\"overlay\"]").style.pointerEvents="none"}})}_removeGlobalListeners(){document.removeEventListener("mousedown",this._boundMouseDownListener);document.removeEventListener("mouseup",this._boundMouseUpListener);document.documentElement.removeEventListener("click",this._boundOutsideClickListener,!0);document.removeEventListener("keydown",this._boundKeydownListener)}_exitModalState(){if(this._previousDocumentPointerEvents!==void 0){// Restore body pointer-events
document.body.style.pointerEvents=this._previousDocumentPointerEvents;delete this._previousDocumentPointerEvents}// Restore pointer events in the previous overlay(s)
const instances=OverlayElement.__attachedInstances;let el;// Use instances.pop() to ensure the reverse order
while(el=instances.pop()){if(el===this){// Skip the current instance
continue}el.shadowRoot.querySelector("[part=\"overlay\"]").style.removeProperty("pointer-events");if(!el.modeless){// Stop after the last modal
break}}}_removeOldContent(){if(!this.content||!this._contentNodes){return}this._observer.disconnect();this._contentNodes.forEach(node=>{if(node.parentNode===this.content){this.content.removeChild(node)}});if(this._originalContentPart){// Restore the original <div part="content">
this.$.content.parentNode.replaceChild(this._originalContentPart,this.$.content);this.$.content=this._originalContentPart;this._originalContentPart=void 0}this._observer.connect();this._contentNodes=void 0;this.content=void 0}_stampOverlayTemplate(template,instanceProps){this._removeOldContent();if(!template._Templatizer){template._Templatizer=Polymer.Templatize.templatize(template,this,{instanceProps:instanceProps,forwardHostProp:function(prop,value){if(this._instance){this._instance.forwardHostProp(prop,value)}}})}this._instance=new template._Templatizer({});this._contentNodes=Array.from(this._instance.root.childNodes);const templateRoot=template._templateRoot||(template._templateRoot=template.getRootNode()),_isScoped=templateRoot!==document;if(_isScoped){const isShady=window.ShadyCSS&&!window.ShadyCSS.nativeShadow;if(!this.$.content.shadowRoot){this.$.content.attachShadow({mode:"open"})}let scopeCssText=Array.from(templateRoot.querySelectorAll("style")).reduce((result,style)=>result+style.textContent,"");if(isShady){// NOTE(platosha): ShadyCSS removes <style>’s from templates, so
// we have to use these protected APIs to get their contents back
const styleInfo=window.ShadyCSS.ScopingShim._styleInfoForNode(templateRoot.host);if(styleInfo){scopeCssText+=styleInfo._getStyleRules().parsedCssText;scopeCssText+="}"}}// The overlay root’s :host styles should not apply inside the overlay
scopeCssText=scopeCssText.replace(/:host/g,":host-nomatch");if(scopeCssText){if(isShady){// ShadyDOM: replace the <div part="content"> with a generated
// styled custom element
const contentPart=createOverlayContent(scopeCssText);contentPart.id="content";contentPart.setAttribute("part","content");this.$.content.parentNode.replaceChild(contentPart,this.$.content);// NOTE(platosha): carry the style scope of the content part
contentPart.className=this.$.content.className;this._originalContentPart=this.$.content;this.$.content=contentPart}else{// Shadow DOM: append a style to the content shadowRoot
const style=document.createElement("style");style.textContent=scopeCssText;this.$.content.shadowRoot.appendChild(style);this._contentNodes.unshift(style)}}this.$.content.shadowRoot.appendChild(this._instance.root);this.content=this.$.content.shadowRoot}else{this.appendChild(this._instance.root);this.content=this}}_removeNewRendererOrTemplate(template,oldTemplate,renderer,oldRenderer){if(template!==oldTemplate){this.template=void 0}else if(renderer!==oldRenderer){this.renderer=void 0}}/**
       * Manually invoke existing renderer.
       */render(){if(this.renderer){this.renderer.call(this.owner,this.content,this.owner,this.model)}}_templateOrRendererChanged(template,renderer,owner,model,instanceProps,opened){if(template&&renderer){this._removeNewRendererOrTemplate(template,this._oldTemplate,renderer,this._oldRenderer);throw new Error("You should only use either a renderer or a template for overlay content")}const ownerOrModelChanged=this._oldOwner!==owner||this._oldModel!==model;this._oldModel=model;this._oldOwner=owner;const templateOrInstancePropsChanged=this._oldInstanceProps!==instanceProps||this._oldTemplate!==template;this._oldInstanceProps=instanceProps;this._oldTemplate=template;const rendererChanged=this._oldRenderer!==renderer;this._oldRenderer=renderer;const openedChanged=this._oldOpened!==opened;this._oldOpened=opened;if(template&&templateOrInstancePropsChanged){this._stampOverlayTemplate(template,instanceProps)}else if(renderer&&(rendererChanged||openedChanged||ownerOrModelChanged)){this.content=this;if(rendererChanged){while(this.content.firstChild){this.content.removeChild(this.content.firstChild)}}if(opened){this.render()}}}_isFocused(element){return element&&element.getRootNode().activeElement===element}_focusedIndex(elements){elements=elements||this._getFocusableElements();return elements.indexOf(elements.filter(this._isFocused).pop())}_cycleTab(increment,index){const focusableElements=this._getFocusableElements();if(index===void 0){index=this._focusedIndex(focusableElements)}index+=increment;// rollover to first item
if(index>=focusableElements.length){index=0;// go to last item
}else if(0>index){index=focusableElements.length-1}focusableElements[index].focus()}_getFocusableElements(){// collect all focusable elements
return Vaadin.FocusablesHelper.getTabbableNodes(this.$.overlay)}_getActiveElement(){let active=document._activeElement||document.activeElement;// document.activeElement can be null
// https://developer.mozilla.org/en-US/docs/Web/API/Document/activeElement
// In IE 11, it can also be an object when operating in iframes
// or document.documentElement (when overlay closed on outside click).
// In these cases, default it to document.body.
if(!active||active===document.documentElement||!1===active instanceof Element){active=document.body}while(active.shadowRoot&&active.shadowRoot.activeElement){active=active.shadowRoot.activeElement}return active}_deepContains(node){if(this.contains(node)){return!0}let n=node;const doc=node.ownerDocument;// walk from node to `this` or `document`
while(n&&n!==doc&&n!==this){n=n.parentNode||n.host}return n===this}/**
       * Brings the overlay as visually the frontmost one
       */bringToFront(){let zIndex="";const frontmost=OverlayElement.__attachedInstances.filter(o=>o!==this).pop();if(frontmost){const frontmostZIndex=frontmost.__zIndex;zIndex=frontmostZIndex+1}this.style.zIndex=zIndex;this.__zIndex=zIndex||parseFloat(getComputedStyle(this).zIndex)}}customElements.define(OverlayElement.is,OverlayElement);/**
     * @namespace Vaadin
     */window.Vaadin.OverlayElement=OverlayElement})();</script><dom-module id="lumo-menu-overlay-core" assetpath="../bower_components/vaadin-lumo-styles/mixins/"><template><style>:host([opening]),
      :host([closing]){animation:0.14s lumo-overlay-dummy-animation;}[part="overlay"]{will-change:opacity, transform;}:host([opening]) [part="overlay"]{animation:0.1s lumo-menu-overlay-enter ease-out both;}@keyframes lumo-menu-overlay-enter{0%{opacity:0;transform:translateY(-4px);}}:host([closing]) [part="overlay"]{animation:0.1s lumo-menu-overlay-exit both;}@keyframes lumo-menu-overlay-exit{100%{opacity:0;}}</style></template></dom-module><dom-module id="lumo-menu-overlay" assetpath="../bower_components/vaadin-lumo-styles/mixins/"><template><style include="lumo-overlay lumo-menu-overlay-core">@media (max-width: 420px), (max-height: 420px){:host{top:0 !important;right:0 !important;bottom:var(--vaadin-overlay-viewport-bottom, 0) !important;left:0 !important;align-items:stretch !important;justify-content:flex-end !important;}[part="overlay"]{max-height:50vh;width:100vw;border-radius:0;box-shadow:var(--lumo-box-shadow-xl);}[part="content"]{padding:30px var(--lumo-space-m);max-height:inherit;box-sizing:border-box;-webkit-overflow-scrolling:touch;overflow:auto;-webkit-mask-image:linear-gradient(transparent, #000 40px, #000 calc(100% - 40px), transparent);mask-image:linear-gradient(transparent, #000 40px, #000 calc(100% - 40px), transparent);}[part="backdrop"]{display:block;}:host([opening]) [part="overlay"]{animation:0.2s lumo-mobile-menu-overlay-enter cubic-bezier(.215, .61, .355, 1) both;}:host([closing]),
        :host([closing]) [part="backdrop"]{animation-delay:0.14s;}:host([closing]) [part="overlay"]{animation:0.14s 0.14s lumo-mobile-menu-overlay-exit cubic-bezier(.55, .055, .675, .19) both;}}@keyframes lumo-mobile-menu-overlay-enter{0%{transform:translateY(150%);}}@keyframes lumo-mobile-menu-overlay-exit{100%{transform:translateY(150%);}}</style></template></dom-module><dom-module id="lumo-combo-box-overlay" theme-for="vaadin-combo-box-overlay" assetpath="../bower_components/vaadin-combo-box/theme/lumo/"><template><style include="lumo-overlay lumo-menu-overlay-core">[part="content"]{padding:0;}:host{--iron-list-items-container:{border-width:var(--lumo-space-xs);border-style:solid;border-color:transparent;};}:host([opened]){--iron-list-items-container_-_border-width:var(--lumo-space-xs);--iron-list-items-container_-_border-style:solid;--iron-list-items-container_-_border-color:transparent;}:host(:not([closing])) [part~="content"]{min-height:calc(2 * var(--lumo-space-s) + var(--lumo-icon-size-s));}[part~="overlay"]{position:relative;}:host([loading]) [part~="loader"]{box-sizing:border-box;width:var(--lumo-icon-size-s);height:var(--lumo-icon-size-s);position:absolute;z-index:1;left:var(--lumo-space-s);right:var(--lumo-space-s);top:var(--lumo-space-s);margin-left:auto;margin-inline-start:auto;margin-inline-end:0;border:2px solid transparent;border-color:var(--lumo-primary-color-50pct)
          var(--lumo-primary-color-50pct)
          var(--lumo-primary-color)
          var(--lumo-primary-color);border-radius:calc(0.5 * var(--lumo-icon-size-s));opacity:0;animation:1s linear infinite lumo-combo-box-loader-rotate,
          .3s .1s lumo-combo-box-loader-fade-in both;pointer-events:none;}@keyframes lumo-combo-box-loader-fade-in{0%{opacity:0;}100%{opacity:1;}}@keyframes lumo-combo-box-loader-rotate{0%{transform:rotate(0deg);}100%{transform:rotate(360deg);}}:host([loading][dir="rtl"]) [part~="loader"]{left:auto;margin-left:0;margin-right:auto;margin-inline-start:0;margin-inline-end:auto;}</style></template></dom-module><dom-module id="lumo-item" theme-for="vaadin-item" assetpath="../bower_components/vaadin-item/theme/lumo/"><template><style>:host{display:flex;align-items:center;box-sizing:border-box;font-family:var(--lumo-font-family);font-size:var(--lumo-font-size-m);line-height:var(--lumo-line-height-xs);padding:0.5em 1em;min-height:var(--lumo-size-m);-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale;-webkit-tap-highlight-color:transparent;}:host([tabindex])::before{display:var(--_lumo-item-selected-icon-display, none);content:var(--lumo-icons-checkmark);font-family:lumo-icons;font-size:var(--lumo-icon-size-m);line-height:1;font-weight:normal;width:1em;height:1em;margin:calc((1 - var(--lumo-line-height-xs)) * var(--lumo-font-size-m) / 2) 0;color:var(--lumo-primary-text-color);flex:none;opacity:0;transition:transform 0.2s cubic-bezier(.12, .32, .54, 2), opacity 0.1s;}:host([selected])::before{opacity:1;}:host([active]:not([selected]))::before{transform:scale(0.8);opacity:0;transition-duration:0s;}[part="content"]{flex:auto;}:host([disabled]){color:var(--lumo-disabled-text-color);cursor:default;pointer-events:none;}:host ::slotted(iron-icon){width:var(--lumo-icon-size-m);height:var(--lumo-icon-size-m);}</style></template></dom-module><script>/**
   * @namespace Vaadin
   */window.Vaadin=window.Vaadin||{};/**
   * A mixin providing `focused`, `focus-ring`, `active`, `disabled` and `selected`.
   *
   * `focused`, `active` and `focus-ring` are set as only as attributes.
   * @polymerMixin
   * @memberof Vaadin
   */Vaadin.ItemMixin=superClass=>class VaadinItemMixin extends superClass{static get properties(){return{/**
         * Used for mixin detection because `instanceof` does not work with mixins.
         * e.g. in VaadinListMixin it filters items by using the
         * `element._hasVaadinItemMixin` condition.
         */_hasVaadinItemMixin:{value:!0},/**
         * If true, the user cannot interact with this element.
         */disabled:{type:Boolean,value:!1,observer:"_disabledChanged",reflectToAttribute:!0},/**
         * If true, the item is in selected state.
         */selected:{type:Boolean,value:!1,reflectToAttribute:!0,observer:"_selectedChanged"},_value:String}}get value(){return this._value!==void 0?this._value:this.textContent.trim()}set value(value){this._value=value}ready(){super.ready();const attrValue=this.getAttribute("value");if(null!==attrValue){this.value=attrValue}this.addEventListener("focus",e=>this._setFocused(!0),!0);this.addEventListener("blur",e=>this._setFocused(!1),!0);this.addEventListener("mousedown",e=>{this._setActive(this._mousedown=!0);const mouseUpListener=()=>{this._setActive(this._mousedown=!1);document.removeEventListener("mouseup",mouseUpListener)};document.addEventListener("mouseup",mouseUpListener)});this.addEventListener("keydown",e=>this._onKeydown(e));this.addEventListener("keyup",e=>this._onKeyup(e))}/**
     * @protected
     */disconnectedCallback(){super.disconnectedCallback();// in Firefox and Safari, blur does not fire on the element when it is removed,
// especially between keydown and keyup events, being active at the same time.
// reproducible in `<vaadin-select>` when closing overlay on select.
if(this.hasAttribute("active")){this._setFocused(!1)}}_selectedChanged(selected){this.setAttribute("aria-selected",selected)}_disabledChanged(disabled){if(disabled){this.selected=!1;this.setAttribute("aria-disabled","true");this.blur()}else{this.removeAttribute("aria-disabled")}}_setFocused(focused){if(focused){this.setAttribute("focused","");if(!this._mousedown){this.setAttribute("focus-ring","")}}else{this.removeAttribute("focused");this.removeAttribute("focus-ring");this._setActive(!1)}}_setActive(active){if(active){this.setAttribute("active","")}else{this.removeAttribute("active")}}_onKeydown(event){if(/^( |SpaceBar|Enter)$/.test(event.key)&&!event.defaultPrevented){event.preventDefault();this._setActive(!0)}}_onKeyup(event){if(this.hasAttribute("active")){this._setActive(!1);this.click()}}};</script><dom-module id="vaadin-item" assetpath="../bower_components/vaadin-item/src/"><template><style>:host{display:inline-block;}:host([hidden]){display:none !important;}</style><div part="content"><slot></slot></div></template><script>(function(){/**
       * `<vaadin-item>` is a Web Component providing layout for items in tabs and menus.
       *
       * ```
       *   <vaadin-item>
       *     Item content
       *   </vaadin-item>
       * ```
       *
       * ### Selectable
       *
       * `<vaadin-item>` has the `selected` property and the corresponding state attribute.
       * Currently, the component sets the `selected` to false, when `disabled` property is set to true.
       * But other than that, the `<vaadin-item>` does not switch selection by itself.
       * In general, it is the wrapper component, like `<vaadin-list-box>`, which should update
       * the `selected` property on the items, e. g. on mousedown or when Enter / Spacebar is pressed.
       *
       * ### Styling
       *
       * The following shadow DOM parts are available for styling:
       *
       * Part name | Description
       * ---|---
       * `content` | The element that wraps the slot
       *
       * The following state attributes are available for styling:
       *
       * Attribute  | Description | Part name
       * -----------|-------------|------------
       * `disabled` | Set to a disabled item | :host
       * `focused` | Set when the element is focused | :host
       * `focus-ring` | Set when the element is keyboard focused | :host
       * `selected` | Set when the item is selected | :host
       * `active` | Set when mousedown or enter/spacebar pressed | :host
       *
       * @memberof Vaadin
       * @mixes Vaadin.ItemMixin
       * @mixes Vaadin.ThemableMixin
       */class ItemElement extends Vaadin.ItemMixin(Vaadin.ThemableMixin(Vaadin.DirMixin(Polymer.Element))){static get is(){return"vaadin-item"}static get version(){return"2.2.0"}constructor(){super();/**
           * Submittable string value. The default value is the trimmed text content of the element.
           * @type {string}
           */this.value}}customElements.define(ItemElement.is,ItemElement);/**
       * @namespace Vaadin
       */window.Vaadin=window.Vaadin||{};Vaadin.ItemElement=ItemElement})();</script></dom-module><dom-module id="lumo-combo-box-item" theme-for="vaadin-combo-box-item" assetpath="../bower_components/vaadin-combo-box/theme/lumo/"><template><style include="lumo-item">:host{cursor:default;-webkit-tap-highlight-color:var(--lumo-primary-color-10pct);padding-left:calc(var(--lumo-border-radius) / 4);padding-right:calc(var(--lumo-space-l) + var(--lumo-border-radius) / 4);transition:background-color 100ms;border-radius:var(--lumo-border-radius);overflow:hidden;--_lumo-item-selected-icon-display:block;}:host::before{display:block;}:host(:hover){background-color:var(--lumo-primary-color-10pct);}:host([focused]:not([disabled])){box-shadow:inset 0 0 0 2px var(--lumo-primary-color-50pct);}@media (pointer: coarse){:host(:hover){background-color:transparent;}:host([focused]:not([disabled])){box-shadow:none;}}:host([dir="rtl"]){padding-right:calc(var(--lumo-border-radius) / 4);padding-left:calc(var(--lumo-space-l) + var(--lumo-border-radius) / 4);}</style></template></dom-module><dom-module id="lumo-combo-box" theme-for="vaadin-combo-box" assetpath="../bower_components/vaadin-combo-box/theme/lumo/"><template><style include="lumo-field-button">:host{outline:none;}[part="toggle-button"]::before{content:var(--lumo-icons-dropdown);}</style></template></dom-module><dom-module id="iron-a11y-announcer" assetpath="../bower_components/iron-a11y-announcer/"><template><style>:host{display:inline-block;position:fixed;clip:rect(0px,0px,0px,0px);}</style><div aria-live$="[[mode]]">[[_text]]</div></template><script>(function(){'use strict';Polymer.IronA11yAnnouncer=Polymer({is:"iron-a11y-announcer",properties:{/**
           * The value of mode is used to set the `aria-live` attribute
           * for the element that will be announced. Valid values are: `off`,
           * `polite` and `assertive`.
           */mode:{type:String,value:"polite"},_text:{type:String,value:""}},created:function(){if(!Polymer.IronA11yAnnouncer.instance){Polymer.IronA11yAnnouncer.instance=this}document.body.addEventListener("iron-announce",this._onIronAnnounce.bind(this))},/**
         * Cause a text string to be announced by screen readers.
         *
         * @param {string} text The text that should be announced.
         */announce:function(text){this._text="";this.async(function(){this._text=text},100)},_onIronAnnounce:function(event){if(event.detail&&event.detail.text){this.announce(event.detail.text)}}});Polymer.IronA11yAnnouncer.instance=null;Polymer.IronA11yAnnouncer.requestAvailability=function(){if(!Polymer.IronA11yAnnouncer.instance){Polymer.IronA11yAnnouncer.instance=document.createElement("iron-a11y-announcer")}document.body.appendChild(Polymer.IronA11yAnnouncer.instance)}})();</script></dom-module><script>'use strict';/**
   * @namespace Vaadin
   */window.Vaadin=window.Vaadin||{};/*
   * Placeholder object class representing items being loaded.
   *
   * @memberof Vaadin
   * @private
   */Vaadin.ComboBoxPlaceholder=class ComboBoxPlaceholder{toString(){return""}};</script><script>window.Vaadin=window.Vaadin||{};/**
   * @polymerMixin
   * @memberof Vaadin
   */Vaadin.ComboBoxMixin=subclass=>class VaadinComboBoxMixinElement extends subclass{static get properties(){return{/**
         * True if the dropdown is open, false otherwise.
         */opened:{type:Boolean,notify:!0,value:!1,reflectToAttribute:!0,observer:"_openedChanged"},/**
         * Set true to prevent the overlay from opening automatically.
         */autoOpenDisabled:Boolean,/**
         * Set to true to disable this element.
         */disabled:{type:Boolean,value:!1,reflectToAttribute:!0},/**
         * When present, it specifies that the element field is read-only.
         */readonly:{type:Boolean,value:!1,reflectToAttribute:!0},/**
         * Custom function for rendering the content of every item.
         * Receives three arguments:
         *
         * - `root` The `<vaadin-combo-box-item>` internal container DOM element.
         * - `comboBox` The reference to the `<vaadin-combo-box>` element.
         * - `model` The object with the properties related with the rendered
         *   item, contains:
         *   - `model.index` The index of the rendered item.
         *   - `model.item` The item.
         */renderer:Function,/**
         * A full set of items to filter the visible options from.
         * The items can be of either `String` or `Object` type.
         */items:{type:Array,observer:"_itemsChanged"},/**
         * If `true`, the user can input a value that is not present in the items list.
         * `value` property will be set to the input value in this case.
         * Also, when `value` is set programmatically, the input value will be set
         * to reflect that value.
         */allowCustomValue:{type:Boolean,value:!1},/**
         * A subset of items, filtered based on the user input. Filtered items
         * can be assigned directly to omit the internal filtering functionality.
         * The items can be of either `String` or `Object` type.
         */filteredItems:{type:Array},/**
         * The `String` value for the selected item of the combo box. Provides
         * the value for `iron-form`.
         *
         * When there’s no item selected, the value is an empty string.
         *
         * Use `selectedItem` property to get the raw selected item from
         * the `items` array.
         */value:{type:String,observer:"_valueChanged",notify:!0,value:""},/**
         * Used to detect user value changes and fire `change` events.
         */_lastCommittedValue:String,/*
         * When set to `true`, "loading" attribute is added to host and the overlay element.
         */loading:{type:Boolean,value:!1,reflectToAttribute:!0},_focusedIndex:{type:Number,value:-1},/**
         * Filtering string the user has typed into the input field.
         */filter:{type:String,value:"",notify:!0},/**
         * The selected item from the `items` array.
         */selectedItem:{type:Object,notify:!0},/**
         * Path for label of the item. If `items` is an array of objects, the
         * `itemLabelPath` is used to fetch the displayed string label for each
         * item.
         *
         * The item label is also used for matching items when processing user
         * input, i.e., for filtering and selecting items.
         *
         * When using item templates, the property is still needed because it is used
         * for filtering, and for displaying the selected item value in the input box.
         */itemLabelPath:{type:String,value:"label",observer:"_itemLabelPathChanged"},/**
         * Path for the value of the item. If `items` is an array of objects, the
         * `itemValuePath:` is used to fetch the string value for the selected
         * item.
         *
         * The item value is used in the `value` property of the combo box,
         * to provide the form value.
         */itemValuePath:{type:String,value:"value"},/**
         * Path for the id of the item. If `items` is an array of objects,
         * the `itemIdPath` is used to compare and identify the same item
         * in `selectedItem` and `filteredItems` (items given by the
         * `dataProvider` callback).
         */itemIdPath:String,/**
         * The name of this element.
         */name:{type:String},/**
         * Set to true if the value is invalid.
         */invalid:{type:Boolean,reflectToAttribute:!0,notify:!0,value:!1},_toggleElement:Object,_clearElement:Object,_inputElementValue:String,_closeOnBlurIsPrevented:Boolean,_previousDocumentPointerEvents:String,_itemTemplate:Object}}static get observers(){return["_filterChanged(filter, itemValuePath, itemLabelPath)","_itemsOrPathsChanged(items.*, itemValuePath, itemLabelPath)","_filteredItemsChanged(filteredItems.*, itemValuePath, itemLabelPath)","_templateOrRendererChanged(_itemTemplate, renderer)","_loadingChanged(loading)","_selectedItemChanged(selectedItem, itemLabelPath)","_toggleElementChanged(_toggleElement)"]}constructor(){super();this._boundOnFocusout=this._onFocusout.bind(this);this._boundOverlaySelectedItemChanged=this._overlaySelectedItemChanged.bind(this);this._boundClose=this.close.bind(this);this._boundOnOpened=this._onOpened.bind(this);this._boundOnKeyDown=this._onKeyDown.bind(this);this._boundOnClick=this._onClick.bind(this);this._boundOnOverlayTouchAction=this._onOverlayTouchAction.bind(this);this._boundOnTouchend=this._onTouchend.bind(this)}ready(){super.ready();this.addEventListener("focusout",this._boundOnFocusout);this._lastCommittedValue=this.value;Polymer.IronA11yAnnouncer.requestAvailability();// 2.0 does not support 'overlay.selection-changed' syntax in listeners
this.$.overlay.addEventListener("selection-changed",this._boundOverlaySelectedItemChanged);this.addEventListener("vaadin-combo-box-dropdown-closed",this._boundClose);this.addEventListener("vaadin-combo-box-dropdown-opened",this._boundOnOpened);this.addEventListener("keydown",this._boundOnKeyDown);this.addEventListener("click",this._boundOnClick);this.$.overlay.addEventListener("vaadin-overlay-touch-action",this._boundOnOverlayTouchAction);this.addEventListener("touchend",this._boundOnTouchend);this._observer=new Polymer.FlattenedNodesObserver(this,info=>{this._setTemplateFromNodes(info.addedNodes)});const bringToFrontListener=e=>{const overlay=this.$.overlay,dropdown=overlay&&overlay.$.dropdown;// Check dropdown.$ because overlay is lazily instantiated
if(dropdown&&dropdown.$&&this.$.overlay.$.dropdown.$.overlay.bringToFront){requestAnimationFrame(()=>{dropdown.$.overlay.bringToFront()})}};this.addEventListener("mousedown",bringToFrontListener);this.addEventListener("touchstart",bringToFrontListener)}/**
     * Manually invoke existing renderer.
     */render(){if(this.$.overlay._selector){this.$.overlay._selector.querySelectorAll("vaadin-combo-box-item").forEach(item=>item._render())}}_setTemplateFromNodes(nodes){this._itemTemplate=nodes.filter(node=>node.localName&&"template"===node.localName)[0]||this._itemTemplate}_removeNewRendererOrTemplate(template,oldTemplate,renderer,oldRenderer){if(template!==oldTemplate){this._itemTemplate=void 0}else if(renderer!==oldRenderer){this.renderer=void 0}}_templateOrRendererChanged(template,renderer){if(template&&renderer){this._removeNewRendererOrTemplate(template,this._oldTemplate,renderer,this._oldRenderer);throw new Error("You should only use either a renderer or a template for combo box items")}this._oldTemplate=template;this._oldRenderer=renderer}/**
     * Opens the dropdown list.
     */open(){// Prevent _open() being called when input is disabled or read-only
if(!this.disabled&&!this.readonly){this.opened=!0}}/**
     * Closes the dropdown list.
     */close(){this.opened=!1}_openedChanged(value,old){// Prevent _close() being called when opened is set to its default value (false).
if(old===void 0){return}if(this.opened){this._openedWithFocusRing=this.hasAttribute("focus-ring")||this.focusElement&&this.focusElement.hasAttribute("focus-ring");// For touch devices, we don't want to popup virtual keyboard unless input is explicitly focused by the user.
if(!this.hasAttribute("focused")&&!this.$.overlay.touchDevice){this.focus()}}else{this._onClosed();if(this._openedWithFocusRing&&this.hasAttribute("focused")){this.focusElement.setAttribute("focus-ring","")}}}_onOverlayTouchAction(event){// On touch devices, blur the input on touch start inside the overlay, in order to hide
// the virtual keyboard. But don't close the overlay on this blur.
this._closeOnBlurIsPrevented=!0;this.inputElement.blur();this._closeOnBlurIsPrevented=!1}_onClick(e){this._closeOnBlurIsPrevented=!0;const path=e.composedPath(),isClearElement=-1!==path.indexOf(this._clearElement)||"clear-button"===path[0].getAttribute("part");if(isClearElement){this._clear();this.focus()}else if(-1!==path.indexOf(this.inputElement)){if(-1<path.indexOf(this._toggleElement)&&this.opened){this.close()}else if(-1<path.indexOf(this._toggleElement)||!this.autoOpenDisabled){this.open()}}this._closeOnBlurIsPrevented=!1}/**
     * Keyboard navigation
     */_onKeyDown(e){if(this._isEventKey(e,"down")){this._closeOnBlurIsPrevented=!0;this._onArrowDown();this._closeOnBlurIsPrevented=!1;// prevent caret from moving
e.preventDefault()}else if(this._isEventKey(e,"up")){this._closeOnBlurIsPrevented=!0;this._onArrowUp();this._closeOnBlurIsPrevented=!1;// prevent caret from moving
e.preventDefault()}else if(this._isEventKey(e,"enter")){this._onEnter(e)}else if(this._isEventKey(e,"esc")){this._onEscape(e)}}_isEventKey(e,k){return Polymer.IronA11yKeysBehavior.keyboardEventMatchesKeys(e,k)}_getItemLabel(item){return this.$.overlay.getItemLabel(item)}_getItemValue(item){let value=item&&this.itemValuePath?this.get(this.itemValuePath,item):void 0;if(value===void 0){value=item?item.toString():""}return value}_onArrowDown(){if(this.opened){if(this.$.overlay._items){this._focusedIndex=Math.min(this.$.overlay._items.length-1,this._focusedIndex+1);this._prefillFocusedItemLabel()}}else{this.open()}}_onArrowUp(){if(this.opened){if(-1<this._focusedIndex){this._focusedIndex=Math.max(0,this._focusedIndex-1)}else{if(this.$.overlay._items){this._focusedIndex=this.$.overlay._items.length-1}}this._prefillFocusedItemLabel()}else{this.open()}}_prefillFocusedItemLabel(){if(-1<this._focusedIndex){// Reset the input value asyncronously to prevent partial value changes
// announce. Makes OSX VoiceOver to announce the complete value instead.
this._inputElementValue="";// 1ms delay needed for OSX VoiceOver to realise input value was reset
setTimeout(()=>{this._inputElementValue=this._getItemLabel(this.$.overlay._focusedItem);this._markAllSelectionRange()},1)}}_setSelectionRange(start,end){// vaadin-text-field does not implement setSelectionRange, hence we need the native input
const input=this._nativeInput||this.inputElement;// Setting selection range focuses and/or moves the caret in some browsers,
// and there's no need to modify the selection range if the input isn't focused anyway.
// This affects Safari. When the overlay is open, and then hiting tab, browser should focus
// the next focusable element instead of the combo-box itself.
// Checking the focused property here is enough instead of checking the activeElement.
if(this.hasAttribute("focused")&&input&&input.setSelectionRange){try{input.setSelectionRange(start,end)}catch(ignore){// IE11 randomly fails when running tests in Sauce.
}}}_markAllSelectionRange(){if(this._inputElementValue!==void 0){this._setSelectionRange(0,this._inputElementValue.length)}}_clearSelectionRange(){if(this._inputElementValue!==void 0){const pos=this._inputElementValue?this._inputElementValue.length:0;this._setSelectionRange(pos,pos)}}_closeOrCommit(){if(this.autoOpenDisabled&&!this.opened){this._commitValue()}else{this.close()}}_onEnter(e){// should close on enter when custom values are allowed, input field is cleared, or when an existing
// item is focused with keyboard. If auto open is disabled, under the same conditions, commit value.
if((this.opened||this.autoOpenDisabled)&&(this.allowCustomValue||""===this._inputElementValue||-1<this._focusedIndex)){this._closeOrCommit();// Do not submit the surrounding form.
e.preventDefault();// Do not trigger global listeners
e.stopPropagation()}}_onEscape(e){if(this.autoOpenDisabled){this._focusedIndex=-1;this.cancel()}else if(this.opened){this._stopPropagation(e);if(-1<this._focusedIndex){this._focusedIndex=-1;this._revertInputValue()}else{this.cancel()}}}_toggleElementChanged(toggleElement){if(toggleElement){// Don't blur the input on toggle mousedown
toggleElement.addEventListener("mousedown",e=>e.preventDefault());// Unfocus previously focused element if focus is not inside combo box (on touch devices)
toggleElement.addEventListener("click",e=>{if(this.$.overlay.touchDevice&&!this.hasAttribute("focused")){document.activeElement.blur()}})}}/**
     * Clears the current value.
     */_clear(){this.selectedItem=null;if(this.allowCustomValue){this.value=""}this._detectAndDispatchChange()}/**
     * Reverts back to original value.
     */cancel(){this._revertInputValueToValue();// In the next _detectAndDispatchChange() call, the change detection should not pass
this._lastCommittedValue=this.value;this._closeOrCommit()}_onOpened(){// Pre P2 iron-list used a debouncer to render. Now that we synchronously render items,
// we need to flush the DOM to make sure it doesn't get flushed in the middle of _render call
// because that will cause problems to say the least.
Polymer.flush();// With iron-list v1.3.9, calling `notifyResize()` no longer renders
// the items synchronously. It is required to have the items rendered
// before we update the overlay and the list positions and sizes.
this.$.overlay.ensureItemsRendered();this.$.overlay._selector.toggleScrollListener(!0);// Ensure metrics are up-to-date
this.$.overlay.updateViewportBoundaries();// Force iron-list to create reusable nodes. Otherwise it will only start
// doing that in scroll listener, which is especially slow in Edge.
this.$.overlay._selector._increasePoolIfNeeded();setTimeout(()=>this._resizeDropdown(),1);// Defer scroll position adjustment to prevent freeze in Edge
window.requestAnimationFrame(()=>this.$.overlay.adjustScrollPosition());// _detectAndDispatchChange() should not consider value changes done before opening
this._lastCommittedValue=this.value}_onClosed(){// Happens when the overlay is closed by clicking outside
if(this.opened){this.close()}this._commitValue()}_commitValue(){if(this.$.overlay._items&&-1<this._focusedIndex){const focusedItem=this.$.overlay._items[this._focusedIndex];if(this.selectedItem!==focusedItem){this.selectedItem=focusedItem}// make sure input field is updated in case value doesn't change (i.e. FOO -> foo)
this._inputElementValue=this._getItemLabel(this.selectedItem)}else if(""===this._inputElementValue||this._inputElementValue===void 0){this.selectedItem=null;if(this.allowCustomValue){this.value=""}}else{if(this.allowCustomValue// to prevent a repetitive input value being saved after pressing ESC and Tab.
&&!(this.filteredItems&&this.filteredItems.filter(item=>this._getItemLabel(item)===this._inputElementValue).length)){const e=new CustomEvent("custom-value-set",{detail:this._inputElementValue,composed:!0,cancelable:!0,bubbles:!0});this.dispatchEvent(e);if(!e.defaultPrevented){const customValue=this._inputElementValue;this._selectItemForValue(customValue);this.value=customValue}}else{this._inputElementValue=this.selectedItem?this._getItemLabel(this.selectedItem):this.value||""}}this._detectAndDispatchChange();this._clearSelectionRange();if(!this.dataProvider){this.filter=""}}get _propertyForValue(){return"value"}/**
     *  Filtering and items handling
     */_inputValueChanged(e){// Handle only input events from our inputElement.
if(-1!==e.composedPath().indexOf(this.inputElement)){this._inputElementValue=this.inputElement[this._propertyForValue];this._filterFromInput(e)}}_filterFromInput(e){if(!this.opened&&!e.__fromClearButton&&!this.autoOpenDisabled){this.open()}if(this.filter===this._inputElementValue){// Filter and input value might get out of sync, while keyboard navigating for example.
// Afterwards, input value might be changed to the same value as used in filtering.
// In situation like these, we need to make sure all the filter changes handlers are run.
this._filterChanged(this.filter,this.itemValuePath,this.itemLabelPath)}else{this.filter=this._inputElementValue}}_itemLabelPathChanged(itemLabelPath,oldItemLabelPath){if("string"!==typeof itemLabelPath){console.error("You should set itemLabelPath to a valid string")}}_filterChanged(filter,itemValuePath,itemLabelPath){if(filter===void 0){return}if(this.items){this.filteredItems=this._filterItems(this.items,filter)}else{// With certain use cases (e. g., external filtering), `items` are
// undefined. Filtering is unnecessary per se, but the filteredItems
// observer should still be invoked to update focused item.
this._filteredItemsChanged({path:"filteredItems",value:this.filteredItems},itemValuePath,itemLabelPath)}}_loadingChanged(loading){if(loading){this._focusedIndex=-1}}_revertInputValue(){if(""!==this.filter){this._inputElementValue=this.filter}else{this._revertInputValueToValue()}this._clearSelectionRange()}_revertInputValueToValue(){if(this.allowCustomValue&&!this.selectedItem){this._inputElementValue=this.value}else{this._inputElementValue=this._getItemLabel(this.selectedItem)}}_resizeDropdown(){this.$.overlay.$.dropdown.notifyResize()}_updateHasValue(hasValue){if(hasValue){this.setAttribute("has-value","")}else{this.removeAttribute("has-value")}}_selectedItemChanged(selectedItem,itemLabelPath){if(null===selectedItem||selectedItem===void 0){if(this.filteredItems){if(!this.allowCustomValue){this.value=""}this._updateHasValue(""!==this.value);this._inputElementValue=this.value}}else{const value=this._getItemValue(selectedItem);if(this.value!==value){this.value=value;if(this.value!==value){// The value was changed to something else in value-changed listener,
// so prevent from resetting it to the previous value.
return}}this._updateHasValue(!0);this._inputElementValue=this._getItemLabel(selectedItem);// Could not be defined in 1.x because ready is called after all prop-setters
if(this.inputElement){this.inputElement[this._propertyForValue]=this._inputElementValue}}this.$.overlay._selectedItem=selectedItem;if(this.filteredItems&&this.$.overlay._items){this._focusedIndex=this.filteredItems.indexOf(selectedItem)}}_valueChanged(value,oldVal){if(""===value&&oldVal===void 0){// initializing, no need to do anything (#554)
return}if(this._isValidValue(value)){let item;if(this._getItemValue(this.selectedItem)!==value){this._selectItemForValue(value)}else{item=this.selectedItem}if(!item&&this.allowCustomValue){this._inputElementValue=value}this._updateHasValue(""!==this.value)}else{this.selectedItem=null}// In the next _detectAndDispatchChange() call, the change detection should pass
this._lastCommittedValue=void 0}_detectAndDispatchChange(){if(this.value!==this._lastCommittedValue){this.dispatchEvent(new CustomEvent("change",{bubbles:!0}));this._lastCommittedValue=this.value}}_itemsChanged(items,oldItems){this._ensureItemsOrDataProvider(()=>{this.items=oldItems})}_itemsOrPathsChanged(e,itemValuePath,itemLabelPath){if(e.value===void 0){return}if("items"===e.path||"items.splices"===e.path){this.filteredItems=this.items?this.items.slice(0):this.items;const valueIndex=this._indexOfValue(this.value,this.items);this._focusedIndex=valueIndex;const item=-1<valueIndex&&this.items[valueIndex];if(item){this.selectedItem=item}}}_filteredItemsChanged(e,itemValuePath,itemLabelPath){if(e.value===void 0){return}if("filteredItems"===e.path||"filteredItems.splices"===e.path){this._setOverlayItems(this.filteredItems);this._focusedIndex=this.opened||this.autoOpenDisabled?this.$.overlay.indexOfLabel(this.filter):this._indexOfValue(this.value,this.filteredItems);if(this.opened){this._repositionOverlay()}}}_filterItems(arr,filter){if(!arr){return arr}const filteredItems=arr.filter(item=>{filter=filter?filter.toString().toLowerCase():"";// Check if item contains input value.
return-1<this._getItemLabel(item).toString().toLowerCase().indexOf(filter)});return!filteredItems.length&&this.autoOpenDisabled?arr:filteredItems}_selectItemForValue(value){const valueIndex=this._indexOfValue(value,this.filteredItems),previouslySelectedItem=this.selectedItem;this.selectedItem=0<=valueIndex?this.filteredItems[valueIndex]:this.dataProvider&&this.selectedItem===void 0?void 0:null;if(null===this.selectedItem&&null===previouslySelectedItem){this._selectedItemChanged(this.selectedItem)}}_setOverlayItems(items){this.$.overlay.set("_items",items)}_repositionOverlay(){// async needed to reposition correctly after filtering
// (especially when aligned on top of input)
this.__repositionOverlayDebouncer=Polymer.Debouncer.debounce(this.__repositionOverlayDebouncer,// Long debounce: sizing updates invoke multiple styling rounds,
// which is very slow in Edge
Polymer.Async.timeOut.after(500),()=>{const selector=this.$.overlay._selector;if(!selector._isClientFull()){// Due to the mismatch of the Y position of the item rendered
// at the top of the scrolling list with some specific scroll
// position values (2324, 3486, 6972, 60972, 95757 etc.)
// iron-list loops the increasing of the pool and adds
// too many items to the DOM.
// Adjusting scroll position to equal the current scrollTop value
// to avoid looping.
selector._resetScrollPosition(selector._physicalTop)}this._resizeDropdown();this.$.overlay.updateViewportBoundaries();this.$.overlay.ensureItemsRendered();selector.notifyResize();Polymer.flush()})}_indexOfValue(value,items){if(items&&this._isValidValue(value)){for(let i=0;i<items.length;i++){if(this._getItemValue(items[i])===value){return i}}}return-1}/**
     * Checks if the value is supported as an item value in this control.
     *
     * @return {boolean}
     */_isValidValue(value){return value!==void 0&&null!==value}_overlaySelectedItemChanged(e){// stop this private event from leaking outside.
e.stopPropagation();if(e.detail.item instanceof Vaadin.ComboBoxPlaceholder){// Placeholder items should not be selectable.
return}if(this.opened){this._focusedIndex=this.filteredItems.indexOf(e.detail.item);this.close()}else if(this.selectedItem!==e.detail.item){this.selectedItem=e.detail.item;this._detectAndDispatchChange()}}_onFocusout(event){// Fixes the problem with `focusout` happening when clicking on the scroll bar on Edge
const dropdown=this.$.overlay.$.dropdown;if(dropdown&&dropdown.$&&event.relatedTarget===dropdown.$.overlay){event.composedPath()[0].focus();return}if(!this._closeOnBlurIsPrevented){this._closeOrCommit()}}_onTouchend(event){if(!this._clearElement||event.composedPath()[0]!==this._clearElement){return}event.preventDefault();this._clear()}/**
     * Returns true if `value` is valid, and sets the `invalid` flag appropriately.
     *
     * @return {boolean} True if the value is valid and sets the `invalid` flag appropriately
     */validate(){return!(this.invalid=!this.checkValidity())}/**
     * Returns true if the current input value satisfies all constraints (if any)
     *
     * You can override the `checkValidity` method for custom validations.
     */checkValidity(){if(this.inputElement.validate){return this.inputElement.validate()}}get _instanceProps(){return{item:!0,index:!0,selected:!0,focused:!0}}_ensureTemplatized(){if(!this._TemplateClass){const tpl=this._itemTemplate||this._getRootTemplate();if(tpl){this._TemplateClass=Polymer.Templatize.templatize(tpl,this,{instanceProps:this._instanceProps,forwardHostProp:function(prop,value){const items=this.$.overlay._selector.querySelectorAll("vaadin-combo-box-item");Array.prototype.forEach.call(items,item=>{if(item._itemTemplateInstance){item._itemTemplateInstance.set(prop,value);item._itemTemplateInstance.notifyPath(prop,value,!0)}})}})}}}_getRootTemplate(){return Array.prototype.filter.call(this.children,elem=>"TEMPLATE"===elem.tagName)[0]}_preventInputBlur(){if(this._toggleElement){this._toggleElement.addEventListener("click",this._preventDefault)}if(this._clearElement){this._clearElement.addEventListener("click",this._preventDefault)}}_restoreInputBlur(){if(this._toggleElement){this._toggleElement.removeEventListener("click",this._preventDefault)}if(this._clearElement){this._clearElement.removeEventListener("click",this._preventDefault)}}_preventDefault(e){e.preventDefault()}_stopPropagation(e){e.stopPropagation()}/**
     * Fired when the value changes.
     *
     * @event value-changed
     * @param {Object} detail
     *  @param {String} detail.value the combobox value
     */ /**
     * Fired when selected item changes.
     *
     * @event selected-item-changed
     * @param {Object} detail
     *  @param {Object|String} detail.value the selected item. Type is the same as the type of `items`.
     */ /**
     * Fired when the user sets a custom value.
     * @event custom-value-set
     * @param {String} detail the custom value
     */ /**
     * Fired when value changes.
     * To comply with https://developer.mozilla.org/en-US/docs/Web/Events/change
     * @event change
     */};</script><dom-module id="iron-list" assetpath="../bower_components/iron-list/"><template><style>:host{display:block;}@media only screen and (-webkit-max-device-pixel-ratio: 1){:host{will-change:transform;}}#items{@apply --iron-list-items-container;position:relative;}:host(:not([grid])) #items > ::slotted(*){width:100%;}#items > ::slotted(*){box-sizing:border-box;margin:0;position:absolute;top:0;will-change:transform;}</style><array-selector id="selector" items="{{items}}" selected="{{selectedItems}}" selected-item="{{selectedItem}}"></array-selector><div id="items"><slot></slot></div></template></dom-module><script>(function(){var IOS=navigator.userAgent.match(/iP(?:hone|ad;(?: U;)? CPU) OS (\d+)/),IOS_TOUCH_SCROLLING=IOS&&8<=IOS[1],DEFAULT_PHYSICAL_COUNT=3,HIDDEN_Y="-10000px",ITEM_WIDTH=0,ITEM_HEIGHT=1,SECRET_TABINDEX=-100,IS_V2=null!=Polymer.flush,ANIMATION_FRAME=IS_V2?Polymer.Async.animationFrame:0,IDLE_TIME=IS_V2?Polymer.Async.idlePeriod:1,MICRO_TASK=IS_V2?Polymer.Async.microTask:2;/* Polymer.OptionalMutableDataBehavior is only available with Polymer 2.0. */if(!Polymer.OptionalMutableDataBehavior){/** @polymerBehavior */Polymer.OptionalMutableDataBehavior={}}Polymer({is:"iron-list",properties:{/**
       * An array containing items determining how many instances of the template
       * to stamp and that that each template instance should bind to.
       */items:{type:Array},/**
       * The name of the variable to add to the binding scope for the array
       * element associated with a given template instance.
       */as:{type:String,value:"item"},/**
       * The name of the variable to add to the binding scope with the index
       * for the row.
       */indexAs:{type:String,value:"index"},/**
       * The name of the variable to add to the binding scope to indicate
       * if the row is selected.
       */selectedAs:{type:String,value:"selected"},/**
       * When true, the list is rendered as a grid. Grid items must have
       * fixed width and height set via CSS. e.g.
       *
       * ```html
       * <iron-list grid>
       *   <template>
       *      <div style="width: 100px; height: 100px;"> 100x100 </div>
       *   </template>
       * </iron-list>
       * ```
       */grid:{type:Boolean,value:!1,reflectToAttribute:!0,observer:"_gridChanged"},/**
       * When true, tapping a row will select the item, placing its data model
       * in the set of selected items retrievable via the selection property.
       *
       * Note that tapping focusable elements within the list item will not
       * result in selection, since they are presumed to have their * own action.
       */selectionEnabled:{type:Boolean,value:!1},/**
       * When `multiSelection` is false, this is the currently selected item, or `null`
       * if no item is selected.
       */selectedItem:{type:Object,notify:!0},/**
       * When `multiSelection` is true, this is an array that contains the selected items.
       */selectedItems:{type:Object,notify:!0},/**
       * When `true`, multiple items may be selected at once (in this case,
       * `selected` is an array of currently selected items).  When `false`,
       * only one item may be selected at a time.
       */multiSelection:{type:Boolean,value:!1},/**
       * The offset top from the scrolling element to the iron-list element.
       * This value can be computed using the position returned by `getBoundingClientRect()`
       * although it's preferred to use a constant value when possible.
       *
       * This property is useful when an external scrolling element is used and there's
       * some offset between the scrolling element and the list.
       * For example: a header is placed above the list.
       */scrollOffset:{type:Number,value:0}},observers:["_itemsChanged(items.*)","_selectionEnabledChanged(selectionEnabled)","_multiSelectionChanged(multiSelection)","_setOverflow(scrollTarget, scrollOffset)"],behaviors:[Polymer.Templatizer,Polymer.IronResizableBehavior,Polymer.IronScrollTargetBehavior,Polymer.OptionalMutableDataBehavior],/**
     * The ratio of hidden tiles that should remain in the scroll direction.
     * Recommended value ~0.5, so it will distribute tiles evenly in both directions.
     */_ratio:.5,/**
     * The padding-top value for the list.
     */_scrollerPaddingTop:0,/**
     * This value is the same as `scrollTop`.
     */_scrollPosition:0,/**
     * The sum of the heights of all the tiles in the DOM.
     */_physicalSize:0,/**
     * The average `offsetHeight` of the tiles observed till now.
     */_physicalAverage:0,/**
     * The number of tiles which `offsetHeight` > 0 observed until now.
     */_physicalAverageCount:0,/**
     * The Y position of the item rendered in the `_physicalStart`
     * tile relative to the scrolling list.
     */_physicalTop:0,/**
     * The number of items in the list.
     */_virtualCount:0,/**
     * The estimated scroll height based on `_physicalAverage`
     */_estScrollHeight:0,/**
     * The scroll height of the dom node
     */_scrollHeight:0,/**
     * The height of the list. This is referred as the viewport in the context of list.
     */_viewportHeight:0,/**
     * The width of the list. This is referred as the viewport in the context of list.
     */_viewportWidth:0,/**
     * An array of DOM nodes that are currently in the tree
     * @type {?Array<!TemplatizerNode>}
     */_physicalItems:null,/**
     * An array of heights for each item in `_physicalItems`
     * @type {?Array<number>}
     */_physicalSizes:null,/**
     * A cached value for the first visible index.
     * See `firstVisibleIndex`
     * @type {?number}
     */_firstVisibleIndexVal:null,/**
     * A Polymer collection for the items.
     * @type {?Polymer.Collection}
     */_collection:null,/**
     * A cached value for the last visible index.
     * See `lastVisibleIndex`
     * @type {?number}
     */_lastVisibleIndexVal:null,/**
     * The max number of pages to render. One page is equivalent to the height of the list.
     */_maxPages:2,/**
     * The currently focused physical item.
     */_focusedItem:null,/**
     * The virtual index of the focused item.
     */_focusedVirtualIndex:-1,/**
     * The physical index of the focused item.
     */_focusedPhysicalIndex:-1,/**
     * The the item that is focused if it is moved offscreen.
     * @private {?TemplatizerNode}
     */_offscreenFocusedItem:null,/**
     * The item that backfills the `_offscreenFocusedItem` in the physical items
     * list when that item is moved offscreen.
     */_focusBackfillItem:null,/**
     * The maximum items per row
     */_itemsPerRow:1,/**
     * The width of each grid item
     */_itemWidth:0,/**
     * The height of the row in grid layout.
     */_rowHeight:0,/**
     * The cost of stamping a template in ms.
     */_templateCost:0,/**
     * Needed to pass event.model property to declarative event handlers -
     * see polymer/polymer#4339.
     */_parentModel:!0,/**
     * The bottom of the physical content.
     */get _physicalBottom(){return this._physicalTop+this._physicalSize},/**
     * The bottom of the scroll.
     */get _scrollBottom(){return this._scrollPosition+this._viewportHeight},/**
     * The n-th item rendered in the last physical item.
     */get _virtualEnd(){return this._virtualStart+this._physicalCount-1},/**
     * The height of the physical content that isn't on the screen.
     */get _hiddenContentSize(){var size=this.grid?this._physicalRows*this._rowHeight:this._physicalSize;return size-this._viewportHeight},/**
     * The parent node for the _userTemplate.
     */get _itemsParent(){return Polymer.dom(Polymer.dom(this._userTemplate).parentNode)},/**
     * The maximum scroll top value.
     */get _maxScrollTop(){return this._estScrollHeight-this._viewportHeight+this._scrollOffset},/**
     * The largest n-th value for an item such that it can be rendered in `_physicalStart`.
     */get _maxVirtualStart(){var virtualCount=this._convertIndexToCompleteRow(this._virtualCount);return Math.max(0,virtualCount-this._physicalCount)},set _virtualStart(val){val=this._clamp(val,0,this._maxVirtualStart);if(this.grid){val=val-val%this._itemsPerRow}this._virtualStartVal=val},get _virtualStart(){return this._virtualStartVal||0},/**
     * The k-th tile that is at the top of the scrolling list.
     */set _physicalStart(val){val=val%this._physicalCount;if(0>val){val=this._physicalCount+val}if(this.grid){val=val-val%this._itemsPerRow}this._physicalStartVal=val},get _physicalStart(){return this._physicalStartVal||0},/**
     * The k-th tile that is at the bottom of the scrolling list.
     */get _physicalEnd(){return(this._physicalStart+this._physicalCount-1)%this._physicalCount},set _physicalCount(val){this._physicalCountVal=val},get _physicalCount(){return this._physicalCountVal||0},/**
     * An optimal physical size such that we will have enough physical items
     * to fill up the viewport and recycle when the user scrolls.
     *
     * This default value assumes that we will at least have the equivalent
     * to a viewport of physical items above and below the user's viewport.
     */get _optPhysicalSize(){return 0===this._viewportHeight?1/0:this._viewportHeight*this._maxPages},/**
    * True if the current list is visible.
    */get _isVisible(){return!!(this.offsetWidth||this.offsetHeight)},/**
     * Gets the index of the first visible item in the viewport.
     *
     * @type {number}
     */get firstVisibleIndex(){var idx=this._firstVisibleIndexVal;if(null==idx){var physicalOffset=this._physicalTop+this._scrollOffset;idx=this._iterateItems(function(pidx,vidx){physicalOffset+=this._getPhysicalSizeIncrement(pidx);if(physicalOffset>this._scrollPosition){return this.grid?vidx-vidx%this._itemsPerRow:vidx}// Handle a partially rendered final row in grid mode
if(this.grid&&this._virtualCount-1===vidx){return vidx-vidx%this._itemsPerRow}})||0;this._firstVisibleIndexVal=idx}return idx},/**
     * Gets the index of the last visible item in the viewport.
     *
     * @type {number}
     */get lastVisibleIndex(){var idx=this._lastVisibleIndexVal;if(null==idx){if(this.grid){idx=Math.min(this._virtualCount,this.firstVisibleIndex+this._estRowsInView*this._itemsPerRow-1)}else{var physicalOffset=this._physicalTop+this._scrollOffset;this._iterateItems(function(pidx,vidx){if(physicalOffset<this._scrollBottom){idx=vidx}physicalOffset+=this._getPhysicalSizeIncrement(pidx)})}this._lastVisibleIndexVal=idx}return idx},get _defaultScrollTarget(){return this},get _virtualRowCount(){return Math.ceil(this._virtualCount/this._itemsPerRow)},get _estRowsInView(){return Math.ceil(this._viewportHeight/this._rowHeight)},get _physicalRows(){return Math.ceil(this._physicalCount/this._itemsPerRow)},get _scrollOffset(){return this._scrollerPaddingTop+this.scrollOffset},ready:function(){this.addEventListener("focus",this._didFocus.bind(this),!0)},attached:function(){this._debounce("_render",this._render,ANIMATION_FRAME);// `iron-resize` is fired when the list is attached if the event is added
// before attached causing unnecessary work.
this.listen(this,"iron-resize","_resizeHandler");this.listen(this,"keydown","_keydownHandler")},detached:function(){this.unlisten(this,"iron-resize","_resizeHandler");this.unlisten(this,"keydown","_keydownHandler")},/**
     * Set the overflow property if this element has its own scrolling region
     */_setOverflow:function(scrollTarget){this.style.webkitOverflowScrolling=scrollTarget===this?"touch":"";this.style.overflowY=scrollTarget===this?"auto":"";// Clear cache.
this._lastVisibleIndexVal=null;this._firstVisibleIndexVal=null;this._debounce("_render",this._render,ANIMATION_FRAME)},/**
     * Invoke this method if you dynamically update the viewport's
     * size or CSS padding.
     *
     * @method updateViewportBoundaries
     */updateViewportBoundaries:function(){var styles=window.getComputedStyle(this);this._scrollerPaddingTop=this.scrollTarget===this?0:parseInt(styles["padding-top"],10);this._isRTL=!!("rtl"===styles.direction);this._viewportWidth=this.$.items.offsetWidth;this._viewportHeight=this._scrollTargetHeight;this.grid&&this._updateGridMetrics()},/**
     * Recycles the physical items when needed.
     */_scrollHandler:function(){var scrollTop=Math.max(0,Math.min(this._maxScrollTop,this._scrollTop)),delta=scrollTop-this._scrollPosition,isScrollingDown=0<=delta;// Track the current scroll position.
this._scrollPosition=scrollTop;// Clear indexes for first and last visible indexes.
this._firstVisibleIndexVal=null;this._lastVisibleIndexVal=null;// Random access.
if(Math.abs(delta)>this._physicalSize&&0<this._physicalSize){delta=delta-this._scrollOffset;var idxAdjustment=Math.round(delta/this._physicalAverage)*this._itemsPerRow;this._virtualStart=this._virtualStart+idxAdjustment;this._physicalStart=this._physicalStart+idxAdjustment;// Estimate new physical offset.
this._physicalTop=Math.floor(this._virtualStart/this._itemsPerRow)*this._physicalAverage;this._update()}else if(0<this._physicalCount){var reusables=this._getReusables(isScrollingDown);if(isScrollingDown){this._physicalTop=reusables.physicalTop;this._virtualStart=this._virtualStart+reusables.indexes.length;this._physicalStart=this._physicalStart+reusables.indexes.length}else{this._virtualStart=this._virtualStart-reusables.indexes.length;this._physicalStart=this._physicalStart-reusables.indexes.length}this._update(reusables.indexes,isScrollingDown?null:reusables.indexes);this._debounce("_increasePoolIfNeeded",this._increasePoolIfNeeded.bind(this,0),MICRO_TASK)}},/**
     * Returns an object that contains the indexes of the physical items
     * that might be reused and the physicalTop.
     *
     * @param {boolean} fromTop If the potential reusable items are above the scrolling region.
     */_getReusables:function(fromTop){var ith,lastIth,offsetContent,physicalItemHeight,idxs=[],protectedOffsetContent=this._hiddenContentSize*this._ratio,virtualStart=this._virtualStart,virtualEnd=this._virtualEnd,physicalCount=this._physicalCount,top=this._physicalTop+this._scrollOffset,bottom=this._physicalBottom+this._scrollOffset,scrollTop=this._scrollTop,scrollBottom=this._scrollBottom;if(fromTop){ith=this._physicalStart;lastIth=this._physicalEnd;offsetContent=scrollTop-top}else{ith=this._physicalEnd;lastIth=this._physicalStart;offsetContent=bottom-scrollBottom}while(!0){physicalItemHeight=this._getPhysicalSizeIncrement(ith);offsetContent=offsetContent-physicalItemHeight;if(idxs.length>=physicalCount||offsetContent<=protectedOffsetContent){break}if(fromTop){// Check that index is within the valid range.
if(virtualEnd+idxs.length+1>=this._virtualCount){break}// Check that the index is not visible.
if(top+physicalItemHeight>=scrollTop-this._scrollOffset){break}idxs.push(ith);top=top+physicalItemHeight;ith=(ith+1)%physicalCount}else{// Check that index is within the valid range.
if(0>=virtualStart-idxs.length){break}// Check that the index is not visible.
if(top+this._physicalSize-physicalItemHeight<=scrollBottom){break}idxs.push(ith);top=top-physicalItemHeight;ith=0===ith?physicalCount-1:ith-1}}return{indexes:idxs,physicalTop:top-this._scrollOffset}},/**
     * Update the list of items, starting from the `_virtualStart` item.
     * @param {!Array<number>=} itemSet
     * @param {!Array<number>=} movingUp
     */_update:function(itemSet,movingUp){if(itemSet&&0===itemSet.length||0===this._physicalCount){return}this._manageFocus();this._assignModels(itemSet);this._updateMetrics(itemSet);// Adjust offset after measuring.
if(movingUp){while(movingUp.length){var idx=movingUp.pop();this._physicalTop-=this._getPhysicalSizeIncrement(idx)}}this._positionItems();this._updateScrollerSize()},/**
     * Creates a pool of DOM elements and attaches them to the local dom.
     *
     * @param {number} size Size of the pool
     */_createPool:function(size){this._ensureTemplatized();var i,inst,physicalItems=Array(size);for(i=0;i<size;i++){inst=this.stamp(null);// TODO(blasten):
// First element child is item; Safari doesn't support children[0]
// on a doc fragment. Test this to see if it still matters.
physicalItems[i]=inst.root.querySelector("*");this._itemsParent.appendChild(inst.root)}return physicalItems},_isClientFull:function(){return 0!=this._scrollBottom&&this._physicalBottom-1>=this._scrollBottom&&this._physicalTop<=this._scrollPosition},/**
     * Increases the pool size.
     */_increasePoolIfNeeded:function(count){var nextPhysicalCount=this._clamp(this._physicalCount+count,DEFAULT_PHYSICAL_COUNT,this._virtualCount-this._virtualStart);nextPhysicalCount=this._convertIndexToCompleteRow(nextPhysicalCount);if(this.grid){var correction=nextPhysicalCount%this._itemsPerRow;if(correction&&nextPhysicalCount-correction<=this._physicalCount){nextPhysicalCount+=this._itemsPerRow}nextPhysicalCount-=correction}var delta=nextPhysicalCount-this._physicalCount,nextIncrease=Math.round(.5*this._physicalCount);if(0>delta){return}if(0<delta){var ts=window.performance.now();// Concat arrays in place.
[].push.apply(this._physicalItems,this._createPool(delta));// Push 0s into physicalSizes. Can't use Array.fill because IE11 doesn't support it.
for(var i=0;i<delta;i++){this._physicalSizes.push(0)}this._physicalCount=this._physicalCount+delta;// Update the physical start if it needs to preserve the model of the focused item.
// In this situation, the focused item is currently rendered and its model would
// have changed after increasing the pool if the physical start remained unchanged.
if(this._physicalStart>this._physicalEnd&&this._isIndexRendered(this._focusedVirtualIndex)&&this._getPhysicalIndex(this._focusedVirtualIndex)<this._physicalEnd){this._physicalStart=this._physicalStart+delta}this._update();this._templateCost=(window.performance.now()-ts)/delta;nextIncrease=Math.round(.5*this._physicalCount)}// The upper bounds is not fixed when dealing with a grid that doesn't
// fill it's last row with the exact number of items per row.
if(this._virtualEnd>=this._virtualCount-1||0===nextIncrease){// Do nothing.
}else if(!this._isClientFull()){this._debounce("_increasePoolIfNeeded",this._increasePoolIfNeeded.bind(this,nextIncrease),MICRO_TASK)}else if(this._physicalSize<this._optPhysicalSize){// Yield and increase the pool during idle time until the physical size is optimal.
this._debounce("_increasePoolIfNeeded",this._increasePoolIfNeeded.bind(this,this._clamp(Math.round(50/this._templateCost),1,nextIncrease)),IDLE_TIME)}},/**
     * Renders the a new list.
     */_render:function(){if(!this.isAttached||!this._isVisible){return}if(0!==this._physicalCount){var reusables=this._getReusables(!0);this._physicalTop=reusables.physicalTop;this._virtualStart=this._virtualStart+reusables.indexes.length;this._physicalStart=this._physicalStart+reusables.indexes.length;this._update(reusables.indexes);this._update();this._increasePoolIfNeeded(0)}else if(0<this._virtualCount){// Initial render
this.updateViewportBoundaries();this._increasePoolIfNeeded(DEFAULT_PHYSICAL_COUNT)}},/**
     * Templetizes the user template.
     */_ensureTemplatized:function(){if(this.ctor){return}this._userTemplate=this.queryEffectiveChildren("template");if(!this._userTemplate){console.warn("iron-list requires a template to be provided in light-dom")}var instanceProps={__key__:!0};instanceProps[this.as]=!0;instanceProps[this.indexAs]=!0;instanceProps[this.selectedAs]=!0;instanceProps.tabIndex=!0;this._instanceProps=instanceProps;this.templatize(this._userTemplate,this.mutableData)},_gridChanged:function(newGrid,oldGrid){if("undefined"===typeof oldGrid)return;this.notifyResize();Polymer.flush?Polymer.flush():Polymer.dom.flush();newGrid&&this._updateGridMetrics()},/**
     * Called when the items have changed. That is, reassignments
     * to `items`, splices or updates to a single item.
     */_itemsChanged:function(change){if("items"===change.path){this._virtualStart=0;this._physicalTop=0;this._virtualCount=this.items?this.items.length:0;this._collection=this.items&&Polymer.Collection?Polymer.Collection.get(this.items):null;this._physicalIndexForKey={};this._firstVisibleIndexVal=null;this._lastVisibleIndexVal=null;this._physicalCount=this._physicalCount||0;this._physicalItems=this._physicalItems||[];this._physicalSizes=this._physicalSizes||[];this._physicalStart=0;if(this._scrollTop>this._scrollOffset){this._resetScrollPosition(0)}this._removeFocusedItem();this._debounce("_render",this._render,ANIMATION_FRAME)}else if("items.splices"===change.path){this._adjustVirtualIndex(change.value.indexSplices);this._virtualCount=this.items?this.items.length:0;// Only blur if at least one item is added or removed.
var itemAddedOrRemoved=change.value.indexSplices.some(function(splice){return 0<splice.addedCount||0<splice.removed.length});if(itemAddedOrRemoved){// Only blur activeElement if it is a descendant of the list (#505, #507).
var activeElement=this._getActiveElement();if(this.contains(activeElement)){activeElement.blur()}}// Render only if the affected index is rendered.
var affectedIndexRendered=change.value.indexSplices.some(function(splice){return splice.index+splice.addedCount>=this._virtualStart&&splice.index<=this._virtualEnd},this);if(!this._isClientFull()||affectedIndexRendered){this._debounce("_render",this._render,ANIMATION_FRAME)}}else if("items.length"!==change.path){this._forwardItemPath(change.path,change.value)}},_forwardItemPath:function(path,value){path=path.slice(6);// 'items.'.length == 6
var dot=path.indexOf(".");if(-1===dot){dot=path.length}var isIndexRendered,pidx,inst,offscreenInstance=this.modelForElement(this._offscreenFocusedItem);if(IS_V2){var vidx=parseInt(path.substring(0,dot),10);isIndexRendered=this._isIndexRendered(vidx);if(isIndexRendered){pidx=this._getPhysicalIndex(vidx);inst=this.modelForElement(this._physicalItems[pidx])}else if(offscreenInstance){inst=offscreenInstance}if(!inst||inst[this.indexAs]!==vidx){return}}else{// Polymer 1.x - get physical instance by key (`#1`), not index.
var key=path.substring(0,dot);if(offscreenInstance&&offscreenInstance.__key__===key){inst=offscreenInstance}else{pidx=this._physicalIndexForKey[key];inst=this.modelForElement(this._physicalItems[pidx]);if(!inst||inst.__key__!==key){return}}}path=path.substring(dot+1);path=this.as+(path?"."+path:"");IS_V2?inst._setPendingPropertyOrPath(path,value,!1,!0):inst.notifyPath(path,value,!0);inst._flushProperties&&inst._flushProperties(!0);// TODO(blasten): V1 doesn't do this and it's a bug
if(isIndexRendered){this._updateMetrics([pidx]);this._positionItems();this._updateScrollerSize()}},/**
     * @param {!Array<!PolymerSplice>} splices
     */_adjustVirtualIndex:function(splices){splices.forEach(function(splice){// deselect removed items
splice.removed.forEach(this._removeItem,this);// We only need to care about changes happening above the current position
if(splice.index<this._virtualStart){var delta=Math.max(splice.addedCount-splice.removed.length,splice.index-this._virtualStart);this._virtualStart=this._virtualStart+delta;if(0<=this._focusedVirtualIndex){this._focusedVirtualIndex=this._focusedVirtualIndex+delta}}},this)},_removeItem:function(item){this.$.selector.deselect(item);// remove the current focused item
if(this._focusedItem&&this.modelForElement(this._focusedItem)[this.as]===item){this._removeFocusedItem()}},/**
     * Executes a provided function per every physical index in `itemSet`
     * `itemSet` default value is equivalent to the entire set of physical indexes.
     *
     * @param {!function(number, number)} fn
     * @param {!Array<number>=} itemSet
     */_iterateItems:function(fn,itemSet){var pidx,vidx,rtn,i;if(2===arguments.length&&itemSet){for(i=0;i<itemSet.length;i++){pidx=itemSet[i];vidx=this._computeVidx(pidx);if(null!=(rtn=fn.call(this,pidx,vidx))){return rtn}}}else{pidx=this._physicalStart;vidx=this._virtualStart;for(;pidx<this._physicalCount;pidx++,vidx++){if(null!=(rtn=fn.call(this,pidx,vidx))){return rtn}}for(pidx=0;pidx<this._physicalStart;pidx++,vidx++){if(null!=(rtn=fn.call(this,pidx,vidx))){return rtn}}}},/**
     * Returns the virtual index for a given physical index
     *
     * @param {number} pidx Physical index
     * @return {number}
     */_computeVidx:function(pidx){if(pidx>=this._physicalStart){return this._virtualStart+(pidx-this._physicalStart)}return this._virtualStart+(this._physicalCount-this._physicalStart)+pidx},/**
     * Assigns the data models to a given set of items.
     * @param {!Array<number>=} itemSet
     */_assignModels:function(itemSet){this._iterateItems(function(pidx,vidx){var el=this._physicalItems[pidx],item=this.items&&this.items[vidx];if(null!=item){var inst=this.modelForElement(el);inst.__key__=this._collection?this._collection.getKey(item):null;this._forwardProperty(inst,this.as,item);this._forwardProperty(inst,this.selectedAs,this.$.selector.isSelected(item));this._forwardProperty(inst,this.indexAs,vidx);this._forwardProperty(inst,"tabIndex",this._focusedVirtualIndex===vidx?0:-1);this._physicalIndexForKey[inst.__key__]=pidx;inst._flushProperties&&inst._flushProperties(!0);el.removeAttribute("hidden")}else{el.setAttribute("hidden","")}},itemSet)},/**
     * Updates the height for a given set of items.
     *
     * @param {!Array<number>=} itemSet
     */_updateMetrics:function(itemSet){// Make sure we distributed all the physical items
// so we can measure them.
Polymer.flush?Polymer.flush():Polymer.dom.flush();var newPhysicalSize=0,oldPhysicalSize=0,prevAvgCount=this._physicalAverageCount,prevPhysicalAvg=this._physicalAverage;this._iterateItems(function(pidx,vidx){oldPhysicalSize+=this._physicalSizes[pidx];this._physicalSizes[pidx]=this._physicalItems[pidx].offsetHeight;newPhysicalSize+=this._physicalSizes[pidx];this._physicalAverageCount+=this._physicalSizes[pidx]?1:0},itemSet);if(this.grid){this._updateGridMetrics();this._physicalSize=Math.ceil(this._physicalCount/this._itemsPerRow)*this._rowHeight}else{oldPhysicalSize=1===this._itemsPerRow?oldPhysicalSize:Math.ceil(this._physicalCount/this._itemsPerRow)*this._rowHeight;this._physicalSize=this._physicalSize+newPhysicalSize-oldPhysicalSize;this._itemsPerRow=1}// Update the average if it measured something.
if(this._physicalAverageCount!==prevAvgCount){this._physicalAverage=Math.round((prevPhysicalAvg*prevAvgCount+newPhysicalSize)/this._physicalAverageCount)}},_updateGridMetrics:function(){this._itemWidth=0<this._physicalCount?this._physicalItems[0].getBoundingClientRect().width:200;this._rowHeight=0<this._physicalCount?this._physicalItems[0].offsetHeight:200;this._itemsPerRow=this._itemWidth?Math.floor(this._viewportWidth/this._itemWidth):this._itemsPerRow},/**
     * Updates the position of the physical items.
     */_positionItems:function(){this._adjustScrollPosition();var y=this._physicalTop;if(this.grid){var totalItemWidth=this._itemsPerRow*this._itemWidth,rowOffset=(this._viewportWidth-totalItemWidth)/2;this._iterateItems(function(pidx,vidx){var modulus=vidx%this._itemsPerRow,x=Math.floor(modulus*this._itemWidth+rowOffset);if(this._isRTL){x=-1*x}this.translate3d(x+"px",y+"px",0,this._physicalItems[pidx]);if(this._shouldRenderNextRow(vidx)){y+=this._rowHeight}})}else{const order=[];this._iterateItems(function(pidx,vidx){const item=this._physicalItems[pidx];this.translate3d(0,y+"px",0,item);y+=this._physicalSizes[pidx];const itemId=item.id;if(itemId){order.push(itemId)}});if(order.length){this.setAttribute("aria-owns",order.join(" "))}}},_getPhysicalSizeIncrement:function(pidx){if(!this.grid){return this._physicalSizes[pidx]}if(this._computeVidx(pidx)%this._itemsPerRow!==this._itemsPerRow-1){return 0}return this._rowHeight},/**
     * Returns, based on the current index,
     * whether or not the next index will need
     * to be rendered on a new row.
     *
     * @param {number} vidx Virtual index
     * @return {boolean}
     */_shouldRenderNextRow:function(vidx){return vidx%this._itemsPerRow===this._itemsPerRow-1},/**
     * Adjusts the scroll position when it was overestimated.
     */_adjustScrollPosition:function(){var deltaHeight=0===this._virtualStart?this._physicalTop:Math.min(this._scrollPosition+this._physicalTop,0);// Note: the delta can be positive or negative.
if(0!==deltaHeight){this._physicalTop=this._physicalTop-deltaHeight;var scrollTop=this._scrollTop;// juking scroll position during interial scrolling on iOS is no bueno
if(!IOS_TOUCH_SCROLLING&&0<scrollTop){this._resetScrollPosition(scrollTop-deltaHeight)}}},/**
     * Sets the position of the scroll.
     */_resetScrollPosition:function(pos){if(this.scrollTarget&&0<=pos){this._scrollTop=pos;this._scrollPosition=this._scrollTop}},/**
     * Sets the scroll height, that's the height of the content,
     *
     * @param {boolean=} forceUpdate If true, updates the height no matter what.
     */_updateScrollerSize:function(forceUpdate){if(this.grid){this._estScrollHeight=this._virtualRowCount*this._rowHeight}else{this._estScrollHeight=this._physicalBottom+Math.max(this._virtualCount-this._physicalCount-this._virtualStart,0)*this._physicalAverage}forceUpdate=forceUpdate||0===this._scrollHeight;forceUpdate=forceUpdate||this._scrollPosition>=this._estScrollHeight-this._physicalSize;forceUpdate=forceUpdate||this.grid&&this.$.items.style.height<this._estScrollHeight;// Amortize height adjustment, so it won't trigger large repaints too often.
if(forceUpdate||Math.abs(this._estScrollHeight-this._scrollHeight)>=this._viewportHeight){this.$.items.style.height=this._estScrollHeight+"px";this._scrollHeight=this._estScrollHeight}},/**
     * Scroll to a specific item in the virtual list regardless
     * of the physical items in the DOM tree.
     *
     * @method scrollToItem
     * @param {(Object)} item The item to be scrolled to
     */scrollToItem:function(item){return this.scrollToIndex(this.items.indexOf(item))},/**
     * Scroll to a specific index in the virtual list regardless
     * of the physical items in the DOM tree.
     *
     * @method scrollToIndex
     * @param {number} idx The index of the item
     */scrollToIndex:function(idx){if("number"!==typeof idx||0>idx||idx>this.items.length-1){return}Polymer.flush?Polymer.flush():Polymer.dom.flush();// Items should have been rendered prior scrolling to an index.
if(0===this._physicalCount){return}idx=this._clamp(idx,0,this._virtualCount-1);// Update the virtual start only when needed.
if(!this._isIndexRendered(idx)||idx>=this._maxVirtualStart){this._virtualStart=this.grid?idx-2*this._itemsPerRow:idx-1}this._manageFocus();this._assignModels();this._updateMetrics();// Estimate new physical offset.
this._physicalTop=Math.floor(this._virtualStart/this._itemsPerRow)*this._physicalAverage;var currentTopItem=this._physicalStart,currentVirtualItem=this._virtualStart,targetOffsetTop=0,hiddenContentSize=this._hiddenContentSize;// scroll to the item as much as we can.
while(currentVirtualItem<idx&&targetOffsetTop<=hiddenContentSize){targetOffsetTop=targetOffsetTop+this._getPhysicalSizeIncrement(currentTopItem);currentTopItem=(currentTopItem+1)%this._physicalCount;currentVirtualItem++}this._updateScrollerSize(!0);this._positionItems();this._resetScrollPosition(this._physicalTop+this._scrollOffset+targetOffsetTop);this._increasePoolIfNeeded(0);// clear cached visible index.
this._firstVisibleIndexVal=null;this._lastVisibleIndexVal=null},/**
     * Reset the physical average and the average count.
     */_resetAverage:function(){this._physicalAverage=0;this._physicalAverageCount=0},/**
     * A handler for the `iron-resize` event triggered by `IronResizableBehavior`
     * when the element is resized.
     */_resizeHandler:function(){this._debounce("_render",function(){// clear cached visible index.
this._firstVisibleIndexVal=null;this._lastVisibleIndexVal=null;// Skip the resize event on touch devices when the address bar slides up.
var delta=Math.abs(this._viewportHeight-this._scrollTargetHeight);this.updateViewportBoundaries();if(this._isVisible){// Reinstall the scroll event listener.
this.toggleScrollListener(!0);this._resetAverage();this._render()}else{// Uninstall the scroll event listener.
this.toggleScrollListener(!1)}},ANIMATION_FRAME)},/**
     * Selects the given item.
     *
     * @method selectItem
     * @param {Object} item The item instance.
     */selectItem:function(item){return this.selectIndex(this.items.indexOf(item))},/**
     * Selects the item at the given index in the items array.
     *
     * @method selectIndex
     * @param {number} index The index of the item in the items array.
     */selectIndex:function(index){if(0>index||index>=this._virtualCount){return}if(!this.multiSelection&&this.selectedItem){this.clearSelection()}if(this._isIndexRendered(index)){var model=this.modelForElement(this._physicalItems[this._getPhysicalIndex(index)]);if(model){model[this.selectedAs]=!0}this.updateSizeForIndex(index)}if(this.$.selector.selectIndex){// v2
this.$.selector.selectIndex(index)}else{// v1
this.$.selector.select(this.items[index])}},/**
     * Deselects the given item.
     *
     * @method deselect
     * @param {Object} item The item instance.
     */deselectItem:function(item){return this.deselectIndex(this.items.indexOf(item))},/**
     * Deselects the item at the given index in the items array.
     *
     * @method deselectIndex
     * @param {number} index The index of the item in the items array.
     */deselectIndex:function(index){if(0>index||index>=this._virtualCount){return}if(this._isIndexRendered(index)){var model=this.modelForElement(this._physicalItems[this._getPhysicalIndex(index)]);model[this.selectedAs]=!1;this.updateSizeForIndex(index)}if(this.$.selector.deselectIndex){// v2
this.$.selector.deselectIndex(index)}else{// v1
this.$.selector.deselect(this.items[index])}},/**
     * Selects or deselects a given item depending on whether the item
     * has already been selected.
     *
     * @method toggleSelectionForItem
     * @param {Object} item The item object.
     */toggleSelectionForItem:function(item){return this.toggleSelectionForIndex(this.items.indexOf(item))},/**
     * Selects or deselects the item at the given index in the items array
     * depending on whether the item has already been selected.
     *
     * @method toggleSelectionForIndex
     * @param {number} index The index of the item in the items array.
     */toggleSelectionForIndex:function(index){var isSelected=this.$.selector.isIndexSelected?this.$.selector.isIndexSelected(index):this.$.selector.isSelected(this.items[index]);isSelected?this.deselectIndex(index):this.selectIndex(index)},/**
     * Clears the current selection in the list.
     *
     * @method clearSelection
     */clearSelection:function(){this._iterateItems(function(pidx,vidx){this.modelForElement(this._physicalItems[pidx])[this.selectedAs]=!1});this.$.selector.clearSelection()},/**
     * Add an event listener to `tap` if `selectionEnabled` is true,
     * it will remove the listener otherwise.
     */_selectionEnabledChanged:function(selectionEnabled){var handler=selectionEnabled?this.listen:this.unlisten;handler.call(this,this,"tap","_selectionHandler")},/**
     * Select an item from an event object.
     */_selectionHandler:function(e){var model=this.modelForElement(e.target);if(!model){return}var modelTabIndex,activeElTabIndex,target=Polymer.dom(e).path[0],activeEl=this._getActiveElement(),physicalItem=this._physicalItems[this._getPhysicalIndex(model[this.indexAs])];// Safari does not focus certain form controls via mouse
// https://bugs.webkit.org/show_bug.cgi?id=118043
if("input"===target.localName||"button"===target.localName||"select"===target.localName){return}// Set a temporary tabindex
modelTabIndex=model.tabIndex;model.tabIndex=SECRET_TABINDEX;activeElTabIndex=activeEl?activeEl.tabIndex:-1;model.tabIndex=modelTabIndex;// Only select the item if the tap wasn't on a focusable child
// or the element bound to `tabIndex`
if(activeEl&&physicalItem!==activeEl&&physicalItem.contains(activeEl)&&activeElTabIndex!==SECRET_TABINDEX){return}this.toggleSelectionForItem(model[this.as])},_multiSelectionChanged:function(multiSelection){this.clearSelection();this.$.selector.multi=multiSelection},/**
     * Updates the size of a given list item.
     *
     * @method updateSizeForItem
     * @param {Object} item The item instance.
     */updateSizeForItem:function(item){return this.updateSizeForIndex(this.items.indexOf(item))},/**
     * Updates the size of the item at the given index in the items array.
     *
     * @method updateSizeForIndex
     * @param {number} index The index of the item in the items array.
     */updateSizeForIndex:function(index){if(!this._isIndexRendered(index)){return null}this._updateMetrics([this._getPhysicalIndex(index)]);this._positionItems();return null},/**
     * Creates a temporary backfill item in the rendered pool of physical items
     * to replace the main focused item. The focused item has tabIndex = 0
     * and might be currently focused by the user.
     *
     * This dynamic replacement helps to preserve the focus state.
     */_manageFocus:function(){var fidx=this._focusedVirtualIndex;if(0<=fidx&&fidx<this._virtualCount){// if it's a valid index, check if that index is rendered
// in a physical item.
if(this._isIndexRendered(fidx)){this._restoreFocusedItem()}else{this._createFocusBackfillItem()}}else if(0<this._virtualCount&&0<this._physicalCount){// otherwise, assign the initial focused index.
this._focusedPhysicalIndex=this._physicalStart;this._focusedVirtualIndex=this._virtualStart;this._focusedItem=this._physicalItems[this._physicalStart]}},/**
     * Converts a random index to the index of the item that completes it's row.
     * Allows for better order and fill computation when grid == true.
     */_convertIndexToCompleteRow:function(idx){// when grid == false _itemPerRow can be unset.
this._itemsPerRow=this._itemsPerRow||1;return this.grid?Math.ceil(idx/this._itemsPerRow)*this._itemsPerRow:idx},_isIndexRendered:function(idx){return idx>=this._virtualStart&&idx<=this._virtualEnd},_isIndexVisible:function(idx){return idx>=this.firstVisibleIndex&&idx<=this.lastVisibleIndex},_getPhysicalIndex:function(vidx){return IS_V2?(this._physicalStart+(vidx-this._virtualStart))%this._physicalCount:this._physicalIndexForKey[this._collection.getKey(this.items[vidx])]},focusItem:function(idx){this._focusPhysicalItem(idx)},_focusPhysicalItem:function(idx){if(0>idx||idx>=this._virtualCount){return}this._restoreFocusedItem();// scroll to index to make sure it's rendered
if(!this._isIndexRendered(idx)){this.scrollToIndex(idx)}var physicalItem=this._physicalItems[this._getPhysicalIndex(idx)],model=this.modelForElement(physicalItem),focusable;// set a secret tab index
model.tabIndex=SECRET_TABINDEX;// check if focusable element is the physical item
if(physicalItem.tabIndex===SECRET_TABINDEX){focusable=physicalItem}// search for the element which tabindex is bound to the secret tab index
if(!focusable){focusable=Polymer.dom(physicalItem).querySelector("[tabindex=\""+SECRET_TABINDEX+"\"]")}// restore the tab index
model.tabIndex=0;// focus the focusable element
this._focusedVirtualIndex=idx;focusable&&focusable.focus()},_removeFocusedItem:function(){if(this._offscreenFocusedItem){this._itemsParent.removeChild(this._offscreenFocusedItem)}this._offscreenFocusedItem=null;this._focusBackfillItem=null;this._focusedItem=null;this._focusedVirtualIndex=-1;this._focusedPhysicalIndex=-1},_createFocusBackfillItem:function(){var fpidx=this._focusedPhysicalIndex;if(this._offscreenFocusedItem||0>this._focusedVirtualIndex){return}if(!this._focusBackfillItem){// Create a physical item.
var inst=this.stamp(null);this._focusBackfillItem=inst.root.querySelector("*");this._itemsParent.appendChild(inst.root)}// Set the offcreen focused physical item.
this._offscreenFocusedItem=this._physicalItems[fpidx];this.modelForElement(this._offscreenFocusedItem).tabIndex=0;this._physicalItems[fpidx]=this._focusBackfillItem;this._focusedPhysicalIndex=fpidx;// Hide the focused physical.
this.translate3d(0,HIDDEN_Y,0,this._offscreenFocusedItem)},_restoreFocusedItem:function(){if(!this._offscreenFocusedItem||0>this._focusedVirtualIndex){return}// Assign models to the focused index.
this._assignModels();// Get the new physical index for the focused index.
var fpidx=this._focusedPhysicalIndex=this._getPhysicalIndex(this._focusedVirtualIndex),onScreenItem=this._physicalItems[fpidx];if(!onScreenItem){return}var onScreenInstance=this.modelForElement(onScreenItem),offScreenInstance=this.modelForElement(this._offscreenFocusedItem);// Restores the physical item only when it has the same model
// as the offscreen one. Use key for comparison since users can set
// a new item via set('items.idx').
if(onScreenInstance[this.as]===offScreenInstance[this.as]){// Flip the focus backfill.
this._focusBackfillItem=onScreenItem;onScreenInstance.tabIndex=-1;// Restore the focused physical item.
this._physicalItems[fpidx]=this._offscreenFocusedItem;// Hide the physical item that backfills.
this.translate3d(0,HIDDEN_Y,0,this._focusBackfillItem)}else{this._removeFocusedItem();this._focusBackfillItem=null}this._offscreenFocusedItem=null},_didFocus:function(e){var targetModel=this.modelForElement(e.target),focusedModel=this.modelForElement(this._focusedItem),hasOffscreenFocusedItem=null!==this._offscreenFocusedItem,fidx=this._focusedVirtualIndex;if(!targetModel){return}if(focusedModel===targetModel){// If the user focused the same item, then bring it into view if it's not visible.
if(!this._isIndexVisible(fidx)){this.scrollToIndex(fidx)}}else{this._restoreFocusedItem();// Restore tabIndex for the currently focused item.
if(focusedModel){focusedModel.tabIndex=-1}// Set the tabIndex for the next focused item.
targetModel.tabIndex=0;fidx=targetModel[this.indexAs];this._focusedVirtualIndex=fidx;this._focusedPhysicalIndex=this._getPhysicalIndex(fidx);this._focusedItem=this._physicalItems[this._focusedPhysicalIndex];if(hasOffscreenFocusedItem&&!this._offscreenFocusedItem){this._update()}}},_keydownHandler:function(e){switch(e.keyCode){case/* ARROW_DOWN */40:if(this._focusedVirtualIndex<this._virtualCount-1)e.preventDefault();this._focusPhysicalItem(this._focusedVirtualIndex+(this.grid?this._itemsPerRow:1));break;case/* ARROW_RIGHT */39:if(this.grid)this._focusPhysicalItem(this._focusedVirtualIndex+(this._isRTL?-1:1));break;case/* ARROW_UP */38:if(0<this._focusedVirtualIndex)e.preventDefault();this._focusPhysicalItem(this._focusedVirtualIndex-(this.grid?this._itemsPerRow:1));break;case/* ARROW_LEFT */37:if(this.grid)this._focusPhysicalItem(this._focusedVirtualIndex+(this._isRTL?1:-1));break;case/* ENTER */13:this._focusPhysicalItem(this._focusedVirtualIndex);if(this.selectionEnabled)this._selectionHandler(e);break;}},_clamp:function(v,min,max){return Math.min(max,Math.max(min,v))},_debounce:function(name,cb,asyncModule){if(IS_V2){this._debouncers=this._debouncers||{};this._debouncers[name]=Polymer.Debouncer.debounce(this._debouncers[name],asyncModule,cb.bind(this));Polymer.enqueueDebouncer(this._debouncers[name])}else{Polymer.dom.addDebouncer(this.debounce(name,cb))}},_forwardProperty:function(inst,name,value){if(IS_V2){inst._setPendingProperty(name,value)}else{inst[name]=value}},/* Templatizer bindings for v2 */_forwardHostPropV2:function(prop,value){(this._physicalItems||[]).concat([this._offscreenFocusedItem,this._focusBackfillItem]).forEach(function(item){if(item){this.modelForElement(item).forwardHostProp(prop,value)}},this)},_notifyInstancePropV2:function(inst,prop,value){if(Polymer.Path.matches(this.as,prop)){var idx=inst[this.indexAs];if(prop==this.as){this.items[idx]=value}this.notifyPath(Polymer.Path.translate(this.as,"items."+idx,prop),value)}},/* Templatizer bindings for v1 */_getStampedChildren:function(){return this._physicalItems},_forwardInstancePath:function(inst,path,value){if(0===path.indexOf(this.as+".")){this.notifyPath("items."+inst.__key__+"."+path.slice(this.as.length+1),value)}},_forwardParentPath:function(path,value){(this._physicalItems||[]).concat([this._offscreenFocusedItem,this._focusBackfillItem]).forEach(function(item){if(item){this.modelForElement(item).notifyPath(path,value,!0)}},this)},_forwardParentProp:function(prop,value){(this._physicalItems||[]).concat([this._offscreenFocusedItem,this._focusBackfillItem]).forEach(function(item){if(item){this.modelForElement(item)[prop]=value}},this)},/* Gets the activeElement of the shadow root/host that contains the list. */_getActiveElement:function(){var itemsHost=this._itemsParent.node.domHost;return Polymer.dom(itemsHost?itemsHost.root:document).activeElement}})})();</script><dom-module id="vaadin-combo-box-item" assetpath="../bower_components/vaadin-combo-box/src/"><template><style>:host{display:block;}:host([hidden]){display:none;}</style><div part="content" id="content"></div></template></dom-module><script>(function(){/**
     * The default element used for items in the vaadin-combo-box.
     *
     * ### Styling
     *
     * The following shadow DOM parts are available for styling:
     *
     * Part name | Description
     * ---|---
     * `content` | The element that wraps the item label or template content
     *
     * The following state attributes are exposed for styling:
     *
     * Attribute    | Description | Part name
     * -------------|-------------|------------
     * `selected` | Set when the item is selected | :host
     * `focused` | Set when the item is focused | :host
     *
     * See [ThemableMixin – how to apply styles for shadow parts](https://github.com/vaadin/vaadin-themable-mixin/wiki)
     *
     * @memberof Vaadin
     * @mixes Vaadin.ThemableMixin
     * @private
     */class ComboBoxItemElement extends Vaadin.ThemableMixin(Vaadin.DirMixin(Polymer.Element)){static get is(){return"vaadin-combo-box-item"}static get properties(){return{/**
           * The index of the item
           */index:Number,/**
           * The item to render
           * @type {(String|Object)}
           */item:Object,/**
           * The text label corresponding to the item
           */label:String,/**
           * True when item is selected
           */selected:{type:Boolean,value:!1,reflectToAttribute:!0},/**
           * True when item is focused
           */focused:{type:Boolean,value:!1,reflectToAttribute:!0},/**
           * The template instance corresponding to the item
           */_itemTemplateInstance:Object,/**
           * Custom function for rendering the content of the `<vaadin-combo-box-item>` propagated from the combo box element.
           */renderer:Function,/**
           * Saved instance of a custom renderer function.
           */_oldRenderer:Function}}static get observers(){return["_rendererOrItemChanged(renderer, index, item.*)","_updateLabel(label, _itemTemplateInstance)","_updateTemplateInstanceVariable(\"index\", index, _itemTemplateInstance)","_updateTemplateInstanceVariable(\"item\", item, _itemTemplateInstance)","_updateTemplateInstanceVariable(\"selected\", selected, _itemTemplateInstance)","_updateTemplateInstanceVariable(\"focused\", focused, _itemTemplateInstance)"]}connectedCallback(){super.connectedCallback();if(!this._itemTemplateInstance){// 2.0 has __dataHost. Might want to consider assigning combobox reference directly to item.
const overlay=this.getRootNode().host.getRootNode().host,dropdown=overlay.__dataHost,comboBoxOverlay=dropdown.getRootNode().host;this._comboBox=comboBoxOverlay.getRootNode().host;this._comboBox._ensureTemplatized();if(this._comboBox._TemplateClass){this._itemTemplateInstance=new this._comboBox._TemplateClass({});this.$.content.textContent="";this.$.content.appendChild(this._itemTemplateInstance.root)}}const hostDir=this._comboBox.getAttribute("dir");if(hostDir){this.setAttribute("dir",hostDir)}}_render(){if(!this.renderer){return}const model={index:this.index,item:this.item};this.renderer(this.$.content,this._comboBox,model)}_rendererOrItemChanged(renderer,index,item){if(item===void 0||index===void 0){return}if(this._oldRenderer!==renderer){this.$.content.innerHTML=""}if(renderer){this._oldRenderer=renderer;this._render()}}_updateLabel(label,_itemTemplateInstance){if(_itemTemplateInstance===void 0&&this.$.content&&!this.renderer){// Only set label to textContent no template
this.$.content.textContent=label}}_updateTemplateInstanceVariable(variable,value,_itemTemplateInstance){if(variable===void 0||value===void 0||_itemTemplateInstance===void 0){return}_itemTemplateInstance[variable]=value}}customElements.define(ComboBoxItemElement.is,ComboBoxItemElement)})();</script><script>(function(){'use strict';const DISABLED_ATTR="disable-upgrade";/**
   * Element class mixin that allows the element to boot up in a non-enabled
   * state when the `disable-upgrade` attribute is present. This mixin is
   * designed to be used with element classes like Polymer.Element that perform
   * initial startup work when they are first connected. When the
   * `disable-upgrade` attribute is removed, if the element is connected, it
   * boots up and "enables" as it otherwise would; if it is not connected, the
   * element boots up when it is next connected.
   *
   * Using `disable-upgrade` with Polymer.Element prevents any data propagation
   * to the element, any element DOM from stamping, or any work done in
   * connected/disconnctedCallback from occuring, but it does not prevent work
   * done in the element constructor.
   *
   * Note, this mixin must be applied on top of any element class that
   * itself implements a `connectedCallback` so that it can control the work
   * done in `connectedCallback`. For example,
   *
   *     MyClass = Polymer.DisableUpgradeMixin(class extends BaseClass {...});
   *
   * @mixinFunction
   * @polymer
   * @appliesMixin Polymer.ElementMixin
   * @memberof Polymer
   */Polymer.DisableUpgradeMixin=Polymer.dedupingMixin(base=>{/**
     * @constructor
     * @extends {base}
     * @implements {Polymer_ElementMixin}
     * @private
     */const superClass=Polymer.ElementMixin(base);/**
     * @polymer
     * @mixinClass
     * @implements {Polymer_DisableUpgradeMixin}
     */class DisableUpgradeClass extends superClass{/** @override */static get observedAttributes(){return super.observedAttributes.concat(DISABLED_ATTR)}/** @override */attributeChangedCallback(name,old,value,namespace){if(name==DISABLED_ATTR){if(!this.__dataEnabled&&null==value&&this.isConnected){super.connectedCallback()}}else{super.attributeChangedCallback(name,old,value,namespace)}}/*
        NOTE: cannot gate on attribute because this is called before
        attributes are delivered. Therefore, we stub this out and
        call `super._initializeProperties()` manually.
      */ /** @override */_initializeProperties(){}// prevent user code in connected from running
/** @override */connectedCallback(){if(this.__dataEnabled||!this.hasAttribute(DISABLED_ATTR)){super.connectedCallback()}}// prevent element from turning on properties
/** @override */_enableProperties(){if(!this.hasAttribute(DISABLED_ATTR)){if(!this.__dataEnabled){super._initializeProperties()}super._enableProperties()}}// only go if "enabled"
/** @override */disconnectedCallback(){if(this.__dataEnabled){super.disconnectedCallback()}}}return DisableUpgradeClass})})();</script><dom-module id="vaadin-combo-box-dropdown" assetpath="../bower_components/vaadin-combo-box/src/"><template><style>:host{display:block;}:host > #overlay{display:none;}</style><vaadin-combo-box-overlay id="overlay" hidden$="[[hidden]]" opened="[[opened]]" template="{{template}}" style="align-items: stretch; margin: 0;" theme$="[[theme]]"><slot></slot></vaadin-combo-box-overlay></template></dom-module><dom-module id="vaadin-combo-box-overlay-styles" theme-for="vaadin-combo-box-overlay" assetpath="../bower_components/vaadin-combo-box/src/"><template><style>:host{width:var(--vaadin-combo-box-overlay-width, var(--_vaadin-combo-box-overlay-default-width, auto));}</style></template></dom-module><script>(function(){/**
     * The overlay element.
     *
     * ### Styling
     *
     * See [`<vaadin-overlay>` documentation](https://github.com/vaadin/vaadin-overlay/blob/master/src/vaadin-overlay.html)
     * for `<vaadin-combo-box-overlay>` parts.
     *
     * See [ThemableMixin – how to apply styles for shadow parts](https://github.com/vaadin/vaadin-themable-mixin/wiki)
     *
     * @memberof Vaadin
     * @private
     */class ComboBoxOverlayElement extends Vaadin.OverlayElement{static get is(){return"vaadin-combo-box-overlay"}connectedCallback(){super.connectedCallback();const dropdown=this.__dataHost,comboBoxOverlay=dropdown.getRootNode().host,comboBox=comboBoxOverlay&&comboBoxOverlay.getRootNode().host,hostDir=comboBox&&comboBox.getAttribute("dir");if(hostDir){this.setAttribute("dir",hostDir)}}ready(){super.ready();const loader=document.createElement("div");loader.setAttribute("part","loader");const content=this.shadowRoot.querySelector("[part~=\"content\"]");content.parentNode.insertBefore(loader,content)}}customElements.define(ComboBoxOverlayElement.is,ComboBoxOverlayElement);/**
     * Element for internal use only.
     *
     * @memberof Vaadin
     * @private
     */class ComboBoxDropdownElement extends Polymer.DisableUpgradeMixin(Polymer.mixinBehaviors(Polymer.IronResizableBehavior,Polymer.Element)){static get is(){return"vaadin-combo-box-dropdown"}static get properties(){return{opened:{type:Boolean,observer:"_openedChanged"},template:{type:Object,notify:!0},/**
           * The element to position/align the dropdown by.
           */positionTarget:{type:Object},/**
           * If `true`, overlay is aligned above the `positionTarget`
           */alignedAbove:{type:Boolean,value:!1},/**
           * Used to propagate the `theme` attribute from the host element.
           */theme:String}}constructor(){super();this._boundSetPosition=this._setPosition.bind(this);this._boundOutsideClickListener=this._outsideClickListener.bind(this)}connectedCallback(){super.connectedCallback();this.addEventListener("iron-resize",this._boundSetPosition)}ready(){super.ready();// Preventing the default modal behaviour of the overlay on input clicking
this.$.overlay.addEventListener("vaadin-overlay-outside-click",e=>{e.preventDefault()})}disconnectedCallback(){super.disconnectedCallback();this.removeEventListener("iron-resize",this._boundSetPosition);// Making sure the overlay is closed and removed from DOM after detaching the dropdown.
this.opened=!1}notifyResize(){super.notifyResize();if(this.positionTarget&&this.opened){this._setPosition();// Schedule another position update (to cover virtual keyboard opening for example)
requestAnimationFrame(this._setPosition.bind(this))}}/**
       * Fired after the `vaadin-combo-box-dropdown` opens.
       *
       * @event vaadin-combo-box-dropdown-opened
       */ /**
       * Fired after the `vaadin-combo-box-dropdown` closes.
       *
       * @event vaadin-combo-box-dropdown-closed
       */_openedChanged(opened,oldValue){if(!!opened===!!oldValue){return}if(opened){this.$.overlay.style.position=this._isPositionFixed(this.positionTarget)?"fixed":"absolute";this._setPosition();window.addEventListener("scroll",this._boundSetPosition,!0);document.addEventListener("click",this._boundOutsideClickListener,!0);this.dispatchEvent(new CustomEvent("vaadin-combo-box-dropdown-opened",{bubbles:!0,composed:!0}))}else{window.removeEventListener("scroll",this._boundSetPosition,!0);document.removeEventListener("click",this._boundOutsideClickListener,!0);this.dispatchEvent(new CustomEvent("vaadin-combo-box-dropdown-closed",{bubbles:!0,composed:!0}))}}// We need to listen on 'click' event and capture it and close the overlay before
// propagating the event to the listener in the button. Otherwise, if the clicked button would call
// open(), this would happen: https://www.youtube.com/watch?v=Z86V_ICUCD4
_outsideClickListener(event){const eventPath=event.composedPath();if(0>eventPath.indexOf(this.positionTarget)&&0>eventPath.indexOf(this.$.overlay)){this.opened=!1}}_isPositionFixed(element){const offsetParent=this._getOffsetParent(element);return"fixed"===window.getComputedStyle(element).position||offsetParent&&this._isPositionFixed(offsetParent)}_getOffsetParent(element){if(element.assignedSlot){return element.assignedSlot.parentElement}else if(element.parentElement){return element.offsetParent}const parent=element.parentNode;if(parent&&11===parent.nodeType&&parent.host){return parent.host;// parent is #shadowRoot
}}_verticalOffset(overlayRect,targetRect){return this.alignedAbove?-overlayRect.height:targetRect.height}_shouldAlignAbove(targetRect){const spaceBelow=(window.innerHeight-targetRect.bottom-Math.min(document.body.scrollTop,0))/window.innerHeight;return .3>spaceBelow}_getCustomWidth(){return window.ShadyCSS?window.ShadyCSS.getComputedStyleValue(this,"--vaadin-combo-box-overlay-width"):getComputedStyle(this).getPropertyValue("--vaadin-combo-box-overlay-width")}_setOverlayWidth(){const inputWidth=this.positionTarget.clientWidth+"px",customWidth=this._getCustomWidth();if(window.ShadyCSS&&!window.ShadyCSS.nativeCss){window.ShadyCSS.styleSubtree(this.$.overlay,{"--vaadin-combo-box-overlay-width":customWidth,"--_vaadin-combo-box-overlay-default-width":inputWidth})}else{this.$.overlay.style.setProperty("--_vaadin-combo-box-overlay-default-width",inputWidth);if(""===customWidth){this.$.overlay.style.removeProperty("--vaadin-combo-box-overlay-width")}else{this.$.overlay.style.setProperty("--vaadin-combo-box-overlay-width",customWidth)}}}_setPosition(e){if(this.hidden){return}if(e&&e.target){const target=e.target===document?document.body:e.target,parent=this.$.overlay.parentElement;if(!(target.contains(this.$.overlay)||target.contains(this.positionTarget))||parent!==document.body){return}}const targetRect=this.positionTarget.getBoundingClientRect();this.alignedAbove=this._shouldAlignAbove(targetRect);const overlayRect=this.$.overlay.getBoundingClientRect();this._translateX=targetRect.left-overlayRect.left+(this._translateX||0);this._translateY=targetRect.top-overlayRect.top+(this._translateY||0)+this._verticalOffset(overlayRect,targetRect);const _devicePixelRatio=window.devicePixelRatio||1;this._translateX=Math.round(this._translateX*_devicePixelRatio)/_devicePixelRatio;this._translateY=Math.round(this._translateY*_devicePixelRatio)/_devicePixelRatio;this.$.overlay.style.transform=`translate3d(${this._translateX}px, ${this._translateY}px, 0)`;this.$.overlay.style.justifyContent=this.alignedAbove?"flex-end":"flex-start";this._setOverlayWidth();// TODO: fire only when position actually changes changes
this.dispatchEvent(new CustomEvent("position-changed"))}}customElements.define(ComboBoxDropdownElement.is,ComboBoxDropdownElement)})();</script><dom-module id="vaadin-combo-box-dropdown-wrapper" assetpath="../bower_components/vaadin-combo-box/src/"><template><vaadin-combo-box-dropdown id="dropdown" hidden="[[_hidden(_items.*, loading)]]" position-target="[[positionTarget]]" on-template-changed="_templateChanged" on-position-changed="_setOverlayHeight" disable-upgrade="" theme="[[theme]]"><template><style>#scroller{overflow:auto;transform:translate3d(0, 0, 0);-webkit-overflow-scrolling:touch;box-shadow:0 0 0 white;}</style><div id="scroller" on-click="_stopPropagation"><iron-list id="selector" role="listbox" items="[[_getItems(opened, _items)]]" scroll-target="[[_scroller]]"><template><vaadin-combo-box-item on-click="_onItemClick" index="[[__requestItemByIndex(item, index)]]" item="[[item]]" label="[[getItemLabel(item, _itemLabelPath)]]" selected="[[_isItemSelected(item, _selectedItem, _itemIdPath)]]" renderer="[[renderer]]" role$="[[_getAriaRole(index)]]" aria-selected$="[[_getAriaSelected(_focusedIndex,index)]]" focused="[[_isItemFocused(_focusedIndex,index)]]" tabindex="-1" theme$="[[theme]]"></vaadin-combo-box-item></template></iron-list></div></template></vaadin-combo-box-dropdown></template></dom-module><script>(function(){'use strict';const TOUCH_DEVICE=(()=>{try{document.createEvent("TouchEvent");return!0}catch(e){return!1}})();/**
     * Element for internal use only.
     *
     * @memberof Vaadin
     * @private
     */class ComboBoxDropdownWrapperElement extends class extends Polymer.Element{}{static get is(){return"vaadin-combo-box-dropdown-wrapper"}static get properties(){return{/**
           * True if the device supports touch events.
           */touchDevice:{type:Boolean,value:TOUCH_DEVICE},opened:Boolean,/**
           * The element to position/align the dropdown by.
           */positionTarget:{type:Object},/**
           * Custom function for rendering the content of the `<vaadin-combo-box-item>` propagated from the combo box element.
           */renderer:Function,/**
           * `true` when new items are being loaded.
           */loading:{type:Boolean,value:!1,reflectToAttribute:!0,observer:"_setOverlayHeight"},/**
           * Used to propagate the `theme` attribute from the host element.
           */theme:String,_selectedItem:{type:Object},_items:{type:Object},_focusedIndex:{type:Number,value:-1,observer:"_focusedIndexChanged"},_focusedItem:{type:String,computed:"_getFocusedItem(_focusedIndex)"},_itemLabelPath:{type:String,value:"label"},_itemValuePath:{type:String,value:"value"},_selector:Object,_itemIdPath:String}}static get observers(){return["_selectorChanged(_selector)","_loadingChanged(loading)","_openedChanged(opened, _items, loading)"]}_fireTouchAction(sourceEvent){this.dispatchEvent(new CustomEvent("vaadin-overlay-touch-action",{detail:{sourceEvent:sourceEvent}}))}_getItems(opened,items){return opened?items:[]}_openedChanged(opened,items,loading){if(this.$.dropdown.hasAttribute("disable-upgrade")){if(!opened){return}else{this._initDropdown()}}// Do not attach if no items
// Do not dettach if opened but user types an invalid search
this.$.dropdown.opened=!!(opened&&(loading||this.$.dropdown.opened||items&&items.length))}_initDropdown(){this.$.dropdown.removeAttribute("disable-upgrade");this._templateChanged();this._loadingChanged(this.loading);this.$.dropdown.$.overlay.addEventListener("touchend",e=>this._fireTouchAction(e));this.$.dropdown.$.overlay.addEventListener("touchmove",e=>this._fireTouchAction(e));// Prevent blurring the input when clicking inside the overlay.
this.$.dropdown.$.overlay.addEventListener("mousedown",e=>e.preventDefault());// IE11: when scrolling with mouse, the focus goes to the scroller.
// This causes the overlay closing due to defocusing the input field.
// Prevent focusing the scroller by setting `unselectable="on"`.
if(/Trident/.test(navigator.userAgent)){this._scroller.setAttribute("unselectable","on")}}_templateChanged(e){if(this.$.dropdown.hasAttribute("disable-upgrade")){return}this._selector=this.$.dropdown.$.overlay.content.querySelector("#selector");this._scroller=this.$.dropdown.$.overlay.content.querySelector("#scroller")}_loadingChanged(loading){if(this.$.dropdown.hasAttribute("disable-upgrade")){return}if(loading){this.$.dropdown.$.overlay.setAttribute("loading","")}else{this.$.dropdown.$.overlay.removeAttribute("loading")}}_selectorChanged(selector){this._patchWheelOverScrolling()}_setOverlayHeight(){if(!this.opened||!this.positionTarget||!this._selector){return}const targetRect=this.positionTarget.getBoundingClientRect();this._scroller.style.maxHeight=(window.ShadyCSS?window.ShadyCSS.getComputedStyleValue(this,"--vaadin-combo-box-overlay-max-height"):getComputedStyle(this).getPropertyValue("--vaadin-combo-box-overlay-max-height"))||"65vh";const maxHeight=this._maxOverlayHeight(targetRect);// overlay max height is restrained by the #scroller max height which is set to 65vh in CSS.
this.$.dropdown.$.overlay.style.maxHeight=maxHeight;// we need to set height for iron-list to make its `firstVisibleIndex` work correctly.
this._selector.style.maxHeight=maxHeight;this.updateViewportBoundaries()}_maxOverlayHeight(targetRect){const margin=8,minHeight=116;// Height of two items in combo-box
if(this.$.dropdown.alignedAbove){return Math.max(targetRect.top-margin+Math.min(document.body.scrollTop,0),minHeight)+"px"}else{return Math.max(document.documentElement.clientHeight-targetRect.bottom-margin,minHeight)+"px"}}_getFocusedItem(focusedIndex){if(0<=focusedIndex){return this._items[focusedIndex]}}_isItemSelected(item,selectedItem,itemIdPath){if(item instanceof Vaadin.ComboBoxPlaceholder){return!1}else if(itemIdPath&&item!==void 0&&selectedItem!==void 0){return this.get(itemIdPath,item)===this.get(itemIdPath,selectedItem)}else{return item===selectedItem}}_onItemClick(e){if(e.detail&&e.detail.sourceEvent&&e.detail.sourceEvent.stopPropagation){this._stopPropagation(e.detail.sourceEvent)}this.dispatchEvent(new CustomEvent("selection-changed",{detail:{item:e.model.item}}))}/**
       * Gets the index of the item with the provided label.
       * @return {Number}
       */indexOfLabel(label){if(this._items&&label){for(let i=0;i<this._items.length;i++){if(this.getItemLabel(this._items[i]).toString().toLowerCase()===label.toString().toLowerCase()){return i}}}return-1}/**
       * If dataProvider is used, dispatch a request for the item’s index if
       * the item is a placeholder object.
       *
       * @return {Number}
       */__requestItemByIndex(item,index){if(item instanceof Vaadin.ComboBoxPlaceholder&&index!==void 0){this.dispatchEvent(new CustomEvent("index-requested",{detail:{index}}))}return index}/**
       * Gets the label string for the item based on the `_itemLabelPath`.
       * @return {String}
       */getItemLabel(item,itemLabelPath){itemLabelPath=itemLabelPath||this._itemLabelPath;let label=item&&itemLabelPath?this.get(itemLabelPath,item):void 0;if(label===void 0||null===label){label=item?item.toString():""}return label}_isItemFocused(focusedIndex,itemIndex){return focusedIndex==itemIndex}_getAriaSelected(focusedIndex,itemIndex){return this._isItemFocused(focusedIndex,itemIndex).toString()}_getAriaRole(itemIndex){return itemIndex!==void 0?"option":!1}_focusedIndexChanged(index){if(0<=index){this._scrollIntoView(index)}}_scrollIntoView(index){if(!(this.opened&&0<=index)){return}const visibleItemsCount=this._visibleItemsCount();if(visibleItemsCount===void 0){// Scroller is not visible. Moving is unnecessary.
return}let targetIndex=index;if(index>this._selector.lastVisibleIndex-1){// Index is below the bottom, scrolling down. Make the item appear at the bottom.
// First scroll to target (will be at the top of the scroller) to make sure it's rendered.
this._selector.scrollToIndex(index);// Then calculate the index for the following scroll (to get the target to bottom of the scroller).
targetIndex=index-visibleItemsCount+1}else if(index>this._selector.firstVisibleIndex){// The item is already visible, scrolling is unnecessary per se. But we need to trigger iron-list to set
// the correct scrollTop on the scrollTarget. Scrolling to firstVisibleIndex.
targetIndex=this._selector.firstVisibleIndex}this._selector.scrollToIndex(Math.max(0,targetIndex));// Sometimes the item is partly below the bottom edge, detect and adjust.
const pidx=this._selector._getPhysicalIndex(index),physicalItem=this._selector._physicalItems[pidx];if(!physicalItem){return}const physicalItemRect=physicalItem.getBoundingClientRect(),scrollerRect=this._scroller.getBoundingClientRect(),scrollTopAdjust=physicalItemRect.bottom-scrollerRect.bottom+this._viewportTotalPaddingBottom;if(0<scrollTopAdjust){this._scroller.scrollTop+=scrollTopAdjust}}ensureItemsRendered(){this._selector._render()}adjustScrollPosition(){if(this.opened&&this._items){this._scrollIntoView(this._focusedIndex)}}/**
       * We want to prevent the kinetic scrolling energy from being transferred from the overlay contents over to the parent.
       * Further improvement ideas: after the contents have been scrolled to the top or bottom and scrolling has stopped, it could allow
       * scrolling the parent similarly to touch scrolling.
       */_patchWheelOverScrolling(){const selector=this._selector;selector.addEventListener("wheel",e=>{const scroller=selector._scroller||selector.scrollTarget,scrolledToTop=0===scroller.scrollTop,scrolledToBottom=1>=scroller.scrollHeight-scroller.scrollTop-scroller.clientHeight;if(scrolledToTop&&0>e.deltaY){e.preventDefault()}else if(scrolledToBottom&&0<e.deltaY){e.preventDefault()}})}updateViewportBoundaries(){this._cachedViewportTotalPaddingBottom=void 0;this._selector.updateViewportBoundaries()}get _viewportTotalPaddingBottom(){if(this._cachedViewportTotalPaddingBottom===void 0){const itemsStyle=window.getComputedStyle(this._selector.$.items);this._cachedViewportTotalPaddingBottom=[itemsStyle.paddingBottom,itemsStyle.borderBottomWidth].map(v=>{return parseInt(v,10)}).reduce((sum,v)=>{return sum+v})}return this._cachedViewportTotalPaddingBottom}_visibleItemsCount(){if(!this._selector){return}// Ensure items are rendered
this._selector.flushDebouncer("_debounceTemplate");// Ensure items are positioned
this._selector.scrollToIndex(this._selector.firstVisibleIndex);// Ensure viewport boundaries are up-to-date
this.updateViewportBoundaries();return this._selector.lastVisibleIndex-this._selector.firstVisibleIndex+1}_selectItem(item){item="number"===typeof item?this._items[item]:item;if(this._selector.selectedItem!==item){this._selector.selectItem(item)}}_preventDefault(e){if(e.cancelable){e.preventDefault()}}_stopPropagation(e){e.stopPropagation()}_hidden(itemsChange){return!this.loading&&(!this._items||!this._items.length)}}customElements.define(ComboBoxDropdownWrapperElement.is,ComboBoxDropdownWrapperElement)})();</script><script>window.Vaadin=window.Vaadin||{};/**
   * @polymerMixin
   */Vaadin.ComboBoxDataProviderMixin=superClass=>class DataProviderMixin extends superClass{static get properties(){return{/**
         * Number of items fetched at a time from the dataprovider.
         */pageSize:{type:Number,value:50,observer:"_pageSizeChanged"},/**
         * Total number of items.
         */size:{type:Number,observer:"_sizeChanged"},/**
         * Function that provides items lazily. Receives arguments `params`, `callback`
         *
         * `params.page` Requested page index
         *
         * `params.pageSize` Current page size
         *
         * `params.filter` Currently applied filter
         *
         * `callback(items, size)` Callback function with arguments:
         *   - `items` Current page of items
         *   - `size` Total number of items.
         */dataProvider:{type:Object,observer:"_dataProviderChanged"},_pendingRequests:{value:()=>{return{}}},__placeHolder:{value:new Vaadin.ComboBoxPlaceholder}}}static get observers(){return["_dataProviderFilterChanged(filter, dataProvider)","_dataProviderClearFilter(dataProvider, opened, value)","_warnDataProviderValue(dataProvider, value)","_ensureFirstPage(opened)"]}_dataProviderClearFilter(dataProvider,opened,value){// Can't depend on filter in this obsever as we don't want
// to clear the filter whenever it's set
if(dataProvider&&this.filter){this.size=void 0;this._pendingRequests={};this.filter="";this.clearCache()}}ready(){super.ready();this.clearCache();this.$.overlay.addEventListener("index-requested",e=>{const index=e.detail.index;if(index!==void 0){const page=this._getPageForIndex(index);if(this._shouldLoadPage(page)){this._loadPage(page)}}})}_dataProviderFilterChanged(){if(this.dataProvider&&this.opened){this.size=void 0;this._pendingRequests={};this.clearCache()}}_ensureFirstPage(opened){if(opened&&this._shouldLoadPage(0)){this._loadPage(0)}}_shouldLoadPage(page){if(!this.filteredItems||this._forceNextRequest){this._forceNextRequest=!1;return!0}const loadedItem=this.filteredItems[page*this.pageSize];if(loadedItem!==void 0){return loadedItem instanceof Vaadin.ComboBoxPlaceholder}else{return this.size===void 0}}_loadPage(page){// make sure same page isn't requested multiple times.
if(!this._pendingRequests[page]&&this.dataProvider){this.loading=!0;const params={page,pageSize:this.pageSize,filter:this.filter},callback=(items,size)=>{if(this._pendingRequests[page]===callback){if(!this.filteredItems){const filteredItems=[];filteredItems.splice(params.page*params.pageSize,items.length,...items);this.filteredItems=filteredItems}else{this.splice("filteredItems",params.page*params.pageSize,items.length,...items)}// Update selectedItem from filteredItems if value is set
if(this._isValidValue(this.value)&&this._getItemValue(this.selectedItem)!==this.value){this._selectItemForValue(this.value)}this.size=size;delete this._pendingRequests[page];if(0===Object.keys(this._pendingRequests).length){this.loading=!1}if(0===page&&this.__repositionOverlayDebouncer&&items.length>(this.__maxRenderedItems||0)){setTimeout(()=>this.__repositionOverlayDebouncer.flush());this.__maxRenderedItems=items.length}}};this._pendingRequests[page]=callback;this.dataProvider(params,callback)}}_getPageForIndex(index){return Math.floor(index/this.pageSize)}/**
     * Clears the cached pages and reloads data from dataprovider when needed.
     */clearCache(){if(!this.dataProvider){return}this._pendingRequests={};const filteredItems=[];for(let i=0;i<(this.size||0);i++){filteredItems.push(this.__placeHolder)}this.filteredItems=filteredItems;if(this.opened){this._loadPage(0)}else{this._forceNextRequest=!0}}_sizeChanged(size=0){const filteredItems=(this.filteredItems||[]).slice(0,size);for(let i=0;i<size;i++){filteredItems[i]=filteredItems[i]!==void 0?filteredItems[i]:this.__placeHolder}this.filteredItems=filteredItems}_pageSizeChanged(pageSize,oldPageSize){if(Math.floor(pageSize)!==pageSize||1>pageSize){this.pageSize=oldPageSize;throw new Error("`pageSize` value must be an integer > 0")}this.clearCache()}_dataProviderChanged(dataProvider,oldDataProvider){this._ensureItemsOrDataProvider(()=>{this.dataProvider=oldDataProvider})}_ensureItemsOrDataProvider(restoreOldValueCallback){if(this.items!==void 0&&this.dataProvider!==void 0){restoreOldValueCallback();throw new Error("Using `items` and `dataProvider` together is not supported")}else if(this.dataProvider&&!this.filteredItems){this.filteredItems=[]}}_warnDataProviderValue(dataProvider,value){if(dataProvider&&""!==value&&(this.selectedItem===void 0||null===this.selectedItem)){const valueIndex=this._indexOfValue(value,this.filteredItems);if(0>valueIndex||!this._getItemLabel(this.filteredItems[valueIndex])){/* eslint-disable no-console */console.warn("Warning: unable to determine the label for the provided `value`. "+"Nothing to display in the text field. This usually happens when "+"setting an initial `value` before any items are returned from "+"the `dataProvider` callback. Consider setting `selectedItem` "+"instead of `value`");/* eslint-enable no-console */}}}};</script><dom-module id="vaadin-combo-box" assetpath="../bower_components/vaadin-combo-box/src/"><template><style>:host{display:inline-block;}:host([hidden]){display:none !important;}:host([opened]){pointer-events:auto;}[part="text-field"]{width:100%;min-width:0;}</style><vaadin-text-field part="text-field" id="input" pattern="[[pattern]]" prevent-invalid-input="[[preventInvalidInput]]" value="{{_inputElementValue}}" autocomplete="off" invalid="[[invalid]]" label="[[label]]" name="[[name]]" placeholder="[[placeholder]]" required="[[required]]" disabled="[[disabled]]" readonly="[[readonly]]" error-message="[[errorMessage]]" autocapitalize="none" autofocus="[[autofocus]]" on-change="_stopPropagation" on-input="_inputValueChanged" clear-button-visible="[[clearButtonVisible]]" theme$="[[theme]]"><slot name="prefix" slot="prefix"></slot><div part="toggle-button" id="toggleButton" slot="suffix" role="button" aria-label="Toggle"></div></vaadin-text-field><vaadin-combo-box-dropdown-wrapper id="overlay" opened="[[opened]]" renderer="[[renderer]]" position-target="[[_getPositionTarget()]]" _focused-index="[[_focusedIndex]]" _item-id-path="[[itemIdPath]]" _item-label-path="[[itemLabelPath]]" loading="[[loading]]" theme="[[theme]]"></vaadin-combo-box-dropdown-wrapper></template></dom-module><script>(function(){/**
       * `<vaadin-combo-box>` is a combo box element combining a dropdown list with an
       * input field for filtering the list of items. If you want to replace the default
       * input field with a custom implementation, you should use the
       * [`<vaadin-combo-box-light>`](#/elements/vaadin-combo-box-light) element.
       *
       * Items in the dropdown list must be provided as a list of `String` values.
       * Defining the items is done using the `items` property, which can be assigned
       * with data-binding, using an attribute or directly with the JavaScript property.
       *
       * ```html
       * <vaadin-combo-box
       *     label="Fruit"
       *     items="[[data]]">
       * </vaadin-combo-box>
       * ```
       *
       * ```js
       * combobox.items = ['apple', 'orange', 'banana'];
       * ```
       *
       * When the selected `value` is changed, a `value-changed` event is triggered.
       *
       * This element can be used within an `iron-form`.
       *
       * ### Item rendering
       *
       * `<vaadin-combo-box>` supports using custom renderer callback function for defining the
       * content of `<vaadin-combo-box-item>`.
       *
       * The renderer function provides `root`, `comboBox`, `model` arguments when applicable.
       * Generate DOM content by using `model` object properties if needed, append it to the `root`
       * element and control the state of the host element by accessing `comboBox`. Before generating new
       * content, users are able to check if there is already content in `root` for reusing it.
       *
       * ```html
       * <vaadin-combo-box id="combo-box"></vaadin-combo-box>
       * ```
       * ```js
       * const comboBox = document.querySelector('#combo-box');
       * comboBox.items = [{'label': 'Hydrogen', 'value': 'H'}];
       * comboBox.renderer = function(root, comboBox, model) {
       *   root.innerHTML = model.index + ': ' +
       *                    model.item.label + ' ' +
       *                    '<b>' + model.item.value + '</b>';
       * };
       * ```
       *
       * Renderer is called on the opening of the combo-box and each time the related model is updated.
       * DOM generated during the renderer call can be reused
       * in the next renderer call and will be provided with the `root` argument.
       * On first call it will be empty.
       *
       * ### Item Template
       *
       * Alternatively, the content of the `<vaadin-combo-box-item>` can be populated by using
       * custom item template provided in the light DOM:
       *
       * ```html
       * <vaadin-combo-box items='[{"label": "Hydrogen", "value": "H"}]'>
       *   <template>
       *     [[index]]: [[item.label]] <b>[[item.value]</b>
       *   </template>
       * </vaadin-combo-box>
       * ```
       *
       * The following properties are available for item template bindings:
       *
       * Property name | Type | Description
       * --------------|------|------------
       * `index`| Number | Index of the item in the `items` array
       * `item` | String or Object | The item reference
       * `selected` | Boolean | True when item is selected
       * `focused` | Boolean | True when item is focused
       *
       * ### Lazy Loading with Function Data Provider
       *
       * In addition to assigning an array to the items property, you can alternatively
       * provide the `<vaadin-combo-box>` data through the
       * [`dataProvider`](#/elements/vaadin-combo-box#property-dataProvider) function property.
       * The `<vaadin-combo-box>` calls this function lazily, only when it needs more data
       * to be displayed.
       *
       * See the [`dataProvider`](#/elements/vaadin-combo-box#property-dataProvider) in
       * the API reference below for the detailed data provider arguments description,
       * and the “Lazy Loading“ example on “Basics” page in the demos.
       *
       * __Note that when using function data providers, the total number of items
       * needs to be set manually. The total number of items can be returned
       * in the second argument of the data provider callback:__
       *
       * ```javascript
       * comboBox.dataProvider = function(params, callback) {
       *   var url = 'https://api.example/data' +
       *       '?page=' + params.page +        // the requested page index
       *       '&per_page=' + params.pageSize; // number of items on the page
       *   var xhr = new XMLHttpRequest();
       *   xhr.onload = function() {
       *     var response = JSON.parse(xhr.responseText);
       *     callback(
       *       response.employees, // requested page of items
       *       response.totalSize  // total number of items
       *     );
       *   };
       *   xhr.open('GET', url, true);
       *   xhr.send();
       * };
       * ```
       *
       * ### Styling
       *
       * The following custom properties are available for styling:
       *
       * Custom property | Description | Default
       * ----------------|-------------|-------------
       * `--vaadin-combo-box-overlay-max-height` | Property that determines the max height of overlay | `65vh`
       *
       * The following shadow DOM parts are available for styling:
       *
       * Part name | Description
       * ----------------|----------------
       * `text-field` | The text field
       * `toggle-button` | The toggle button
       *
       * See [`<vaadin-overlay>` documentation](https://github.com/vaadin/vaadin-overlay/blob/master/src/vaadin-overlay.html)
       * for `<vaadin-combo-box-overlay>` parts.
       *
       * See [`<vaadin-text-field>` documentation](https://vaadin.com/components/vaadin-text-field/html-api/elements/Vaadin.TextFieldElement)
       * for the text field parts.
       *
       * The following state attributes are available for styling:
       *
       * Attribute    | Description | Part name
       * -------------|-------------|------------
       * `opened` | Set when the combo box dropdown is open | :host
       * `disabled` | Set to a disabled combo box | :host
       * `readonly` | Set to a read only combo box | :host
       * `has-value` | Set when the element has a value | :host
       * `invalid` | Set when the element is invalid | :host
       * `focused` | Set when the element is focused | :host
       * `focus-ring` | Set when the element is keyboard focused | :host
       * `loading` | Set when new items are expected | :host
       *
       * In addition to `<vaadin-combo-box>` itself, the following internal
       * components are themable:
       *
       * - `<vaadin-text-field>`
       * - `<vaadin-combo-box-overlay>`
       * - `<vaadin-combo-box-item>`
       *
       * Note: the `theme` attribute value set on `<vaadin-combo-box>` is
       * propagated to the internal themable components listed above.
       *
       * See [ThemableMixin – how to apply styles for shadow parts](https://github.com/vaadin/vaadin-themable-mixin/wiki)
       *
       * @memberof Vaadin
       * @mixes Vaadin.ElementMixin
       * @mixes Vaadin.ControlStateMixin
       * @mixes Vaadin.ComboBoxDataProviderMixin
       * @mixes Vaadin.ComboBoxMixin
       * @mixes Vaadin.ThemableMixin
       * @mixes Vaadin.ThemePropertyMixin
       * @demo demo/index.html
       */class ComboBoxElement extends Vaadin.ElementMixin(Vaadin.ControlStateMixin(Vaadin.ThemePropertyMixin(Vaadin.ThemableMixin(Vaadin.ComboBoxDataProviderMixin(Vaadin.ComboBoxMixin(Polymer.Element)))))){constructor(){super();/**
           * @property
           */this.theme}static get is(){return"vaadin-combo-box"}static get version(){return"5.2.0"}static get properties(){return{/**
             * The label for this element.
             */label:{type:String,reflectToAttribute:!0},/**
             * Set to true to mark the input as required.
             */required:{type:Boolean,value:!1},/**
             * Set to true to disable this input.
             */disabled:{type:Boolean,value:!1},/**
             * Set to true to prevent the user from entering invalid input.
             */preventInvalidInput:{type:Boolean},/**
             * A pattern to validate the `input` with.
             */pattern:{type:String},/**
             * The error message to display when the input is invalid.
             */errorMessage:{type:String},autofocus:{type:Boolean},/**
             * A placeholder string in addition to the label.
             */placeholder:{type:String,value:""},readonly:{type:Boolean,value:!1},/**
             * Set to true to display the clear icon which clears the input.
             */clearButtonVisible:{type:Boolean,value:!1}}}static get observers(){return["_updateAriaExpanded(opened)"]}attributeChanged(name,type){// Safari has an issue with repainting shadow root element styles when a host attribute changes.
// Need this workaround (toggle any inline css property on and off) until the issue gets fixed.
const isSafari=/^((?!chrome|android).)*safari/i.test(navigator.userAgent);if(isSafari&&this.root){Array.prototype.forEach.call(this.root.querySelectorAll("*"),el=>{el.style["-webkit-backface-visibility"]="visible";el.style["-webkit-backface-visibility"]=""})}}ready(){super.ready();this._nativeInput=this.inputElement.focusElement;this._toggleElement=this.$.toggleButton;this._clearElement=this.inputElement.shadowRoot.querySelector("[part=\"clear-button\"]");// Stop propagation of Esc in capturing phase so that
// vaadin-text-field will not handle Esc as a shortcut
// to clear the value.
// We need to set this listener for "this.inputElement"
// instead of just "this", otherwise keyboard navigation behaviour
// breaks a bit on Safari and some related tests fail.
this.inputElement.addEventListener("keydown",e=>{if(this._isEventKey(e,"esc")){this._stopPropagation(e);// Trigger _onEscape method of vaadin-combo-box-mixin because
// bubbling phase is not reached.
this._onEscape(e)}},!0);this._nativeInput.setAttribute("role","combobox");this._nativeInput.setAttribute("aria-autocomplete","list");this._updateAriaExpanded()}connectedCallback(){super.connectedCallback();this._preventInputBlur()}disconnectedCallback(){super.disconnectedCallback();this._restoreInputBlur()}_getPositionTarget(){return this.$.input}_updateAriaExpanded(){if(this._nativeInput){this._nativeInput.setAttribute("aria-expanded",this.opened);this._toggleElement.setAttribute("aria-expanded",this.opened)}}get inputElement(){return this.$.input}/**
         * Focusable element used by vaadin-control-state-mixin
         */get focusElement(){// inputElement might not be defined on property changes before ready.
return this.inputElement||this}}customElements.define(ComboBoxElement.is,ComboBoxElement);/**
       * @namespace Vaadin
       */window.Vaadin.ComboBoxElement=ComboBoxElement})();</script><dom-module id="lumo-date-picker-overlay" theme-for="vaadin-date-picker-overlay" assetpath="../bower_components/vaadin-date-picker/theme/lumo/"><template><style include="lumo-menu-overlay">[part="overlay"]{width:calc(
              var(--lumo-size-m) * 7
            + var(--lumo-space-xs) * 2
            + 57px
          );height:100%;max-height:calc(var(--lumo-size-m) * 14);overflow:hidden;-webkit-tap-highlight-color:transparent;}[part="overlay"]{flex-direction:column;}[part="content"]{padding:0;height:100%;overflow:hidden;-webkit-mask-image:none;mask-image:none;}@media (max-width: 420px), (max-height: 420px){[part="overlay"]{width:100vw;height:70vh;max-height:70vh;}}</style></template></dom-module><dom-module id="lumo-date-picker-overlay-content" theme-for="vaadin-date-picker-overlay-content" assetpath="../bower_components/vaadin-date-picker/theme/lumo/"><template><style>:host{position:relative;background-color:transparent;background-image:linear-gradient(var(--lumo-shade-5pct), var(--lumo-shade-5pct));background-size:57px 100%;background-position:top right;background-repeat:no-repeat;cursor:default;}[part="months"]{--vaadin-infinite-scroller-item-height:calc(
              var(--lumo-font-size-l) + var(--lumo-space-m)
            + var(--lumo-font-size-xs) + var(--lumo-space-s)
            + var(--lumo-size-m) * 6
            + var(--lumo-space-s)
          );--vaadin-infinite-scroller-buffer-offset:20%;-webkit-mask-image:linear-gradient(transparent, #000 10%, #000 85%, transparent);mask-image:linear-gradient(transparent, #000 10%, #000 85%, transparent);position:relative;margin-right:57px;}[part="years"]{--vaadin-infinite-scroller-buffer-width:97px;width:57px;height:auto;top:0;bottom:0;font-size:var(--lumo-font-size-s);box-shadow:inset 2px 0 4px 0 var(--lumo-shade-5pct);-webkit-mask-image:linear-gradient(transparent, #000 35%, #000 65%, transparent);mask-image:linear-gradient(transparent, #000 35%, #000 65%, transparent);}[part="year-number"],
      [part="year-separator"]{opacity:0.5;transition:0.2s opacity;}[part="years"]:hover [part="year-number"],
      [part="years"]:hover [part="year-separator"]{opacity:1;}#scrollers{position:static;display:block;}#scrollers[desktop] [part="months"]{right:auto;}[part="years"]::before{border:none;width:1em;height:1em;background-color:var(--lumo-base-color);background-image:linear-gradient(var(--lumo-tint-5pct), var(--lumo-tint-5pct));transform:translate(-75%, -50%) rotate(45deg);border-top-right-radius:calc(var(--lumo-border-radius) / 2);box-shadow:2px -2px 6px 0 var(--lumo-shade-5pct);z-index:1;}[part="year-number"],
      [part="year-separator"]{display:flex;align-items:center;justify-content:center;height:50%;transform:translateY(-50%);}[part="years"] [part="year-separator"]::after{color:var(--lumo-disabled-text-color);content:"•";}[part="years"] [part="year-number"][current]{color:var(--lumo-primary-text-color);}[part="toolbar"]{padding:var(--lumo-space-s);box-shadow:0 -1px 0 0 var(--lumo-contrast-10pct);border-bottom-left-radius:var(--lumo-border-radius);margin-right:57px;}@supports (mask-image: linear-gradient(#000, #000)) or (-webkit-mask-image: linear-gradient(#000, #000)){[part="toolbar"]{box-shadow:none;}}[part="toolbar"] [part$="button"]{background-color:transparent;margin:0;min-width:0;padding:0 0.75em;}:host([fullscreen]) [part="toolbar"]{order:-1;background-color:var(--lumo-base-color);}:host([fullscreen]) [part="overlay-header"]{order:-2;height:var(--lumo-size-m);padding:var(--lumo-space-s);position:absolute;left:0;right:0;justify-content:center;}:host([fullscreen]) [part="toggle-button"],
      :host([fullscreen]) [part="clear-button"],
      [part="overlay-header"] [part="label"]{display:none;}[part="years-toggle-button"]{position:relative;right:auto;display:flex;align-items:center;height:var(--lumo-size-s);padding:0 0.5em;border-radius:var(--lumo-border-radius);z-index:3;color:var(--lumo-primary-text-color);font-weight:500;-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale;}:host([years-visible]) [part="years-toggle-button"]{background-color:var(--lumo-primary-color);color:var(--lumo-primary-contrast-color);}[part="years-toggle-button"]::before{content:none;}@media screen and (max-width: 374px){:host{background-image:none;}[part="years"]{background-color:var(--lumo-shade-5pct);}[part="toolbar"],
        [part="months"]{margin-right:0;}[part="years"]{--vaadin-infinite-scroller-buffer-width:90px;width:50px;}:host([years-visible]) [part="months"]{padding-left:50px;}}</style></template></dom-module><dom-module id="lumo-month-calendar" theme-for="vaadin-month-calendar" assetpath="../bower_components/vaadin-date-picker/theme/lumo/"><template><style>:host{-moz-user-select:none;-ms-user-select:none;-webkit-user-select:none;-webkit-tap-highlight-color:transparent;user-select:none;font-size:var(--lumo-font-size-m);color:var(--lumo-body-text-color);text-align:center;padding:0 var(--lumo-space-xs);}[part="month-header"]{color:var(--lumo-header-text-color);font-size:var(--lumo-font-size-l);line-height:1;font-weight:500;margin-bottom:var(--lumo-space-m);}[part="weekdays"],
      [part="weekday"],
      [part="week-numbers"]{font-size:var(--lumo-font-size-xs);line-height:1;color:var(--lumo-tertiary-text-color);}[part="weekdays"]{margin-bottom:var(--lumo-space-s);}[part="weekday"]:empty,
      [part="week-numbers"]{width:var(--lumo-size-xs);}[part="date"],
      [part="week-number"]{box-sizing:border-box;display:inline-flex;align-items:center;justify-content:center;height:var(--lumo-size-m);position:relative;}[part="date"]{transition:color 0.1s;}[part="date"][today]{color:var(--lumo-primary-text-color);}[part="date"]::before{content:"";position:absolute;z-index:-1;top:50%;left:50%;transform:translate(-50%, -50%);min-width:2em;min-height:2em;width:80%;height:80%;max-height:100%;max-width:100%;border-radius:var(--lumo-border-radius);}[part="date"][focused]::before{box-shadow:0 0 0 2px var(--lumo-primary-color-50pct);}:host(:not([focused])) [part="date"][focused]::before{animation:vaadin-date-picker-month-calendar-focus-date 1.4s infinite;}@keyframes vaadin-date-picker-month-calendar-focus-date{50%{box-shadow:0 0 0 2px transparent;}}[part="date"][role="button"]:not([disabled]):not([selected]):hover::before{background-color:var(--lumo-primary-color-10pct);}[part="date"][selected]{color:var(--lumo-primary-contrast-color);}[part="date"][selected]::before{background-color:var(--lumo-primary-color);}[part="date"][disabled]{color:var(--lumo-disabled-text-color);}@media (pointer: coarse){[part="date"]:hover:not([selected])::before,
        [part="date"][focused]:not([selected])::before{display:none;}[part="date"][role="button"]:not([disabled]):active::before{display:block;}[part="date"][selected]::before{box-shadow:none;}}:host([disabled]) *{color:var(--lumo-disabled-text-color) !important;}</style></template></dom-module><custom-style><style>@keyframes vaadin-date-picker-month-calendar-focus-date{50%{box-shadow:0 0 0 2px transparent;}}</style></custom-style><dom-module id="lumo-date-picker" theme-for="vaadin-date-picker" assetpath="../bower_components/vaadin-date-picker/theme/lumo/"><template><style include="lumo-field-button">:host{outline:none;}[part="toggle-button"]::before{content:var(--lumo-icons-calendar);}[part="clear-button"]::before{content:var(--lumo-icons-cross);}@media (max-width: 420px), (max-height: 420px){[part="overlay-content"]{height:70vh;}}</style></template></dom-module><dom-module id="lumo-date-picker-text-field" theme-for="vaadin-date-picker-text-field" assetpath="../bower_components/vaadin-date-picker/theme/lumo/"><template><style>:not(*):placeholder-shown, /* to prevent broken styles on IE */
      :host([dir="rtl"]) [part="value"]:placeholder-shown,
      :host([dir="rtl"]) [part="input-field"] ::slotted(input:placeholder-shown){--_lumo-text-field-overflow-mask-image:none;}:host([dir="rtl"]) [part="value"],
      :host([dir="rtl"]) [part="input-field"] ::slotted(input){--_lumo-text-field-overflow-mask-image:linear-gradient(to left, transparent, #000 1.25em);}</style></template></dom-module><dom-module id="vaadin-date-picker-text-field-styles" theme-for="vaadin-date-picker-text-field" assetpath="../bower_components/vaadin-date-picker/src/"><template><style>:host([dir="rtl"]) [part="input-field"]{direction:ltr;}:host([dir="rtl"]) [part="value"]::placeholder{direction:rtl;text-align:left;}:host([dir="rtl"]) [part="input-field"] ::slotted(input)::placeholder{direction:rtl;text-align:left;}:host([dir="rtl"]) [part="value"]:-ms-input-placeholder,
      :host([dir="rtl"]) [part="input-field"] ::slotted(input):-ms-input-placeholder{direction:rtl;text-align:left;}</style></template></dom-module><script>(function(){/**
      * The text-field element for date input.
      *
      * ### Styling
      *
      * See [`<vaadin-text-field>` documentation](https://github.com/vaadin/vaadin-text-field/blob/master/src/vaadin-text-field.html)
      * for `<vaadin-date-picker-text-field>` parts and available slots (prefix, suffix etc.)
      *
      * See [ThemableMixin – how to apply styles for shadow parts](https://github.com/vaadin/vaadin-themable-mixin/wiki)
      *
      * @memberof Vaadin
      * @extends Vaadin.TextFieldElement
      */class DatePickerTextFieldElement extends Vaadin.TextFieldElement{static get is(){return"vaadin-date-picker-text-field"}}customElements.define(DatePickerTextFieldElement.is,DatePickerTextFieldElement)})();</script><script>Polymer({is:"iron-media-query",properties:{/**
       * The Boolean return value of the media query.
       */queryMatches:{type:Boolean,value:!1,readOnly:!0,notify:!0},/**
       * The CSS media query to evaluate.
       */query:{type:String,observer:"queryChanged"},/**
       * If true, the query attribute is assumed to be a complete media query
       * string rather than a single media feature.
       */full:{type:Boolean,value:!1},/**
       * @type {function(MediaQueryList)}
       */_boundMQHandler:{value:function(){return this.queryHandler.bind(this)}},/**
       * @type {MediaQueryList}
       */_mq:{value:null}},attached:function(){this.style.display="none";this.queryChanged()},detached:function(){this._remove()},_add:function(){if(this._mq){this._mq.addListener(this._boundMQHandler)}},_remove:function(){if(this._mq){this._mq.removeListener(this._boundMQHandler)}this._mq=null},queryChanged:function(){this._remove();var query=this.query;if(!query){return}if(!this.full&&"("!==query[0]){query="("+query+")"}this._mq=window.matchMedia(query);this._add();this.queryHandler(this._mq)},queryHandler:function(mq){this._setQueryMatches(mq.matches)}});</script><script>(function(){/**
     * The overlay element.
     *
     * ### Styling
     *
     * See [`<vaadin-overlay>` documentation](https://github.com/vaadin/vaadin-overlay/blob/master/src/vaadin-overlay.html)
     * for `<vaadin-date-picker-overlay>` parts.
     *
     * See [ThemableMixin – how to apply styles for shadow parts](https://github.com/vaadin/vaadin-themable-mixin/wiki)
     *
     * @extends Vaadin.OverlayElement
     * @memberof Vaadin
     * @private
     */class DatePickerOverlayElement extends Polymer.DisableUpgradeMixin(Vaadin.OverlayElement){static get is(){return"vaadin-date-picker-overlay"}}customElements.define(DatePickerOverlayElement.is,DatePickerOverlayElement)})();</script><script>window.Vaadin=window.Vaadin||{};Vaadin.DatePickerHelper=class VaadinDatePickerHelper{/**
     * Get ISO 8601 week number for the given date.
     *
     * @param {Date} Date object
     * @return {Number} Week number
     */static _getISOWeekNumber(date){// Ported from Vaadin Framework method com.vaadin.client.DateTimeService.getISOWeekNumber(date)
var dayOfWeek=date.getDay();// 0 == sunday
// ISO 8601 use weeks that start on monday so we use
// mon=1,tue=2,...sun=7;
if(0===dayOfWeek){dayOfWeek=7}// Find nearest thursday (defines the week in ISO 8601). The week number
// for the nearest thursday is the same as for the target date.
var nearestThursdayDiff=4-dayOfWeek,nearestThursday=new Date(date.getTime()+1e3*(3600*(24*nearestThursdayDiff))),firstOfJanuary=new Date(0,0);// 4 is thursday
firstOfJanuary.setFullYear(nearestThursday.getFullYear());var timeDiff=nearestThursday.getTime()-firstOfJanuary.getTime(),daysSinceFirstOfJanuary=Math.round(timeDiff/(1e3*(3600*24)));// Rounding the result, as the division doesn't result in an integer
// when the given date is inside daylight saving time period.
return Math.floor(daysSinceFirstOfJanuary/7+1)}/**
     * Check if two dates are equal.
     *
     * @param {Date} date1
     * @param {Date} date2
     * @return {Boolean} True if the given date objects refer to the same date
     */static _dateEquals(date1,date2){return date1 instanceof Date&&date2 instanceof Date&&date1.getFullYear()===date2.getFullYear()&&date1.getMonth()===date2.getMonth()&&date1.getDate()===date2.getDate()}/**
     * Check if the given date is in the range of allowed dates.
     *
     * @param {Date} date The date to check
     * @param {Date} min Range start
     * @param {Date} max Range end
     * @return {Boolean} True if the date is in the range
     */static _dateAllowed(date,min,max){return(!min||date>=min)&&(!max||date<=max)}/**
     * Get closest date from array of dates.
     *
     * @param {Date} date The date to compare dates with
     * @param {Array} dates Array of date objects
     * @return {Date} Closest date
     */static _getClosestDate(date,dates){return dates.filter(date=>date!==void 0).reduce((closestDate,candidate)=>{if(!candidate){return closestDate}if(!closestDate){return candidate}var candidateDiff=Math.abs(date.getTime()-candidate.getTime()),closestDateDiff=Math.abs(closestDate.getTime()-date.getTime());return candidateDiff<closestDateDiff?candidate:closestDate})}/**
     * Extracts the basic component parts of a date (day, month and year)
     * to the expected format.
     */static _extractDateParts(date){return{day:date.getDate(),month:date.getMonth(),year:date.getFullYear()}}};</script><dom-module id="vaadin-month-calendar" assetpath="../bower_components/vaadin-date-picker/src/"><template><style>:host{display:block;}[part="weekdays"],
      #days{display:flex;flex-wrap:wrap;flex-grow:1;}#days-container,
      #weekdays-container{display:flex;}[part="week-numbers"]{display:flex;flex-direction:column;justify-content:space-between;flex-shrink:0;}[part="week-numbers"][hidden],
      [part="weekday"][hidden]{display:none;}[part="weekday"],
      [part="date"]{width:14.285714286%;}[part="weekday"]:empty,
      [part="week-numbers"]{width:12.5%;flex-shrink:0;}</style><div part="month-header" role="heading">[[_getTitle(month, i18n.monthNames)]]</div><div id="monthGrid" on-tap="_handleTap" on-touchend="_preventDefault" on-touchstart="_onMonthGridTouchStart"><div id="weekdays-container"><div hidden="[[!_showWeekSeparator(showWeekNumbers, i18n.firstDayOfWeek)]]" part="weekday"></div><div part="weekdays"><template is="dom-repeat" items="[[_getWeekDayNames(i18n.weekdays, i18n.weekdaysShort, showWeekNumbers, i18n.firstDayOfWeek)]]"><div part="weekday" role="heading" aria-label$="[[item.weekDay]]">[[item.weekDayShort]]</div></template></div></div><div id="days-container"><div part="week-numbers" hidden="[[!_showWeekSeparator(showWeekNumbers, i18n.firstDayOfWeek)]]"><template is="dom-repeat" items="[[_getWeekNumbers(_days)]]"><div part="week-number" role="heading" aria-label$="[[i18n.week]] [[item]]">[[item]]</div></template></div><div id="days"><template is="dom-repeat" items="[[_days]]"><div part="date" today$="[[_isToday(item)]]" selected$="[[_dateEquals(item, selectedDate)]]" focused$="[[_dateEquals(item, focusedDate)]]" date="[[item]]" disabled$="[[!_dateAllowed(item, minDate, maxDate)]]" role$="[[_getRole(item)]]" aria-label$="[[_getAriaLabel(item)]]" aria-disabled$="[[_getAriaDisabled(item, minDate, maxDate)]]">[[_getDate(item)]]</div></template></div></div></div></template><script>(function(){/**
       * @memberof Vaadin
       * @private
       */class MonthCalendarElement extends Vaadin.ThemableMixin(Polymer.GestureEventListeners(Polymer.Element)){static get is(){return"vaadin-month-calendar"}static get properties(){return{/**
             * A `Date` object defining the month to be displayed. Only year and
             * month properties are actually used.
             */month:{type:Date,value:new Date},/**
             * A `Date` object for the currently selected date.
             */selectedDate:{type:Date,notify:!0},/**
             * A `Date` object for the currently focused date.
             */focusedDate:Date,showWeekNumbers:{type:Boolean,value:!1},i18n:{type:Object},/**
             * Flag stating whether taps on the component should be ignored.
             */ignoreTaps:Boolean,_notTapping:Boolean,/**
             * The earliest date that can be selected. All earlier dates will be disabled.
             */minDate:{type:Date,value:null},/**
             * The latest date that can be selected. All later dates will be disabled.
             */maxDate:{type:Date,value:null},_days:{type:Array,computed:"_getDays(month, i18n.firstDayOfWeek, minDate, maxDate)"},disabled:{type:Boolean,reflectToAttribute:!0,computed:"_isDisabled(month, minDate, maxDate)"}}}static get observers(){return["_showWeekNumbersChanged(showWeekNumbers, i18n.firstDayOfWeek)"]}_dateEquals(date1,date2){return Vaadin.DatePickerHelper._dateEquals(date1,date2)}_dateAllowed(date,min,max){return Vaadin.DatePickerHelper._dateAllowed(date,min,max)}/* Returns true if all the dates in the month are out of the allowed range */_isDisabled(month,minDate,maxDate){// First day of the month
var firstDate=new Date(0,0);firstDate.setFullYear(month.getFullYear());firstDate.setMonth(month.getMonth());firstDate.setDate(1);// Last day of the month
var lastDate=new Date(0,0);lastDate.setFullYear(month.getFullYear());lastDate.setMonth(month.getMonth()+1);lastDate.setDate(0);if(minDate&&maxDate&&minDate.getMonth()===maxDate.getMonth()&&minDate.getMonth()===month.getMonth()&&0<=maxDate.getDate()-minDate.getDate()){return!1}return!this._dateAllowed(firstDate,minDate,maxDate)&&!this._dateAllowed(lastDate,minDate,maxDate)}_getTitle(month,monthNames){if(month===void 0||monthNames===void 0){return}return this.i18n.formatTitle(monthNames[month.getMonth()],month.getFullYear())}_onMonthGridTouchStart(){this._notTapping=!1;setTimeout(()=>this._notTapping=!0,300)}_dateAdd(date,delta){date.setDate(date.getDate()+delta)}_applyFirstDayOfWeek(weekDayNames,firstDayOfWeek){if(weekDayNames===void 0||firstDayOfWeek===void 0){return}return weekDayNames.slice(firstDayOfWeek).concat(weekDayNames.slice(0,firstDayOfWeek))}_getWeekDayNames(weekDayNames,weekDayNamesShort,showWeekNumbers,firstDayOfWeek){if(weekDayNames===void 0||weekDayNamesShort===void 0||showWeekNumbers===void 0||firstDayOfWeek===void 0){return}weekDayNames=this._applyFirstDayOfWeek(weekDayNames,firstDayOfWeek);weekDayNamesShort=this._applyFirstDayOfWeek(weekDayNamesShort,firstDayOfWeek);weekDayNames=weekDayNames.map((day,index)=>{return{weekDay:day,weekDayShort:weekDayNamesShort[index]}});return weekDayNames}_getDate(date){return date?date.getDate():""}_showWeekNumbersChanged(showWeekNumbers,firstDayOfWeek){if(showWeekNumbers&&1===firstDayOfWeek){this.setAttribute("week-numbers","")}else{this.removeAttribute("week-numbers")}}_showWeekSeparator(showWeekNumbers,firstDayOfWeek){// Currently only supported for locales that start the week on Monday.
return showWeekNumbers&&1===firstDayOfWeek}_isToday(date){return this._dateEquals(new Date,date)}_getDays(month,firstDayOfWeek){if(month===void 0||firstDayOfWeek===void 0){return}// First day of the month (at midnight).
var date=new Date(0,0);date.setFullYear(month.getFullYear());date.setMonth(month.getMonth());date.setDate(1);// Rewind to first day of the week.
while(date.getDay()!==firstDayOfWeek){this._dateAdd(date,-1)}var days=[],startMonth=date.getMonth(),targetMonth=month.getMonth();while(date.getMonth()===targetMonth||date.getMonth()===startMonth){days.push(date.getMonth()===targetMonth?new Date(date.getTime()):null);// Advance to next day.
this._dateAdd(date,1)}return days}_getWeekNumber(date,days){if(date===void 0||days===void 0){return}if(!date){// Get the first non-null date from the days array.
date=days.reduce((acc,d)=>{return!acc&&d?d:acc})}return Vaadin.DatePickerHelper._getISOWeekNumber(date)}_getWeekNumbers(dates){return dates.map(date=>this._getWeekNumber(date,dates)).filter((week,index,arr)=>arr.indexOf(week)===index)}_handleTap(e){if(!this.ignoreTaps&&!this._notTapping&&e.target.date&&!e.target.hasAttribute("disabled")){this.selectedDate=e.target.date;this.dispatchEvent(new CustomEvent("date-tap",{bubbles:!0,composed:!0}))}}_preventDefault(e){e.preventDefault()}_getRole(date){return date?"button":"presentation"}_getAriaLabel(date){if(!date){return""}var ariaLabel=this._getDate(date)+" "+this.i18n.monthNames[date.getMonth()]+" "+date.getFullYear()+", "+this.i18n.weekdays[date.getDay()];if(this._isToday(date)){ariaLabel+=", "+this.i18n.today}return ariaLabel}_getAriaDisabled(date,min,max){if(date===void 0||min===void 0||max===void 0){return}return this._dateAllowed(date,min,max)?"false":"true"}}customElements.define(MonthCalendarElement.is,MonthCalendarElement)})();</script></dom-module><dom-module id="vaadin-infinite-scroller" assetpath="../bower_components/vaadin-date-picker/src/"><template><style>:host{display:block;overflow:hidden;height:500px;}#scroller{position:relative;height:100%;overflow:auto;outline:none;margin-right:-40px;-webkit-overflow-scrolling:touch;-ms-overflow-style:none;overflow-x:hidden;}#scroller.notouchscroll{-webkit-overflow-scrolling:auto;}#scroller::-webkit-scrollbar{display:none;}.buffer{position:absolute;width:var(--vaadin-infinite-scroller-buffer-width, 100%);box-sizing:border-box;padding-right:40px;top:var(--vaadin-infinite-scroller-buffer-offset, 0);animation:fadein 0.2s;}@keyframes fadein{from{opacity:0;}to{opacity:1;}}</style><div id="scroller" on-scroll="_scroll"><div class="buffer"></div><div class="buffer"></div><div id="fullHeight"></div></div></template></dom-module><script>(function(){/**
     * @memberof Vaadin
     * @private
     */class InfiniteScrollerElement extends Polymer.Element{static get is(){return"vaadin-infinite-scroller"}static get properties(){return{/**
           * Count of individual items in each buffer.
           * The scroller has 2 buffers altogether so bufferSize of 20
           * will result in 40 buffered DOM items in total.
           * Changing after initialization not supported.
           */bufferSize:{type:Number,value:20},/**
           * The amount of initial scroll top. Needed in order for the
           * user to be able to scroll backwards.
           */_initialScroll:{value:5e5},/**
           * The index/position mapped at _initialScroll point.
           */_initialIndex:{value:0},_buffers:Array,_preventScrollEvent:Boolean,_mayHaveMomentum:Boolean,_initialized:Boolean,active:{type:Boolean,observer:"_activated"}}}ready(){super.ready();this._buffers=Array.prototype.slice.call(this.root.querySelectorAll(".buffer"));this.$.fullHeight.style.height=2*this._initialScroll+"px";var tpl=this.querySelector("template");this._TemplateClass=Polymer.Templatize.templatize(tpl,this,{forwardHostProp:function(prop,value){if("index"!==prop){this._buffers.forEach(buffer=>{[].forEach.call(buffer.children,insertionPoint=>{insertionPoint._itemWrapper.instance[prop]=value})})}}});// Firefox interprets elements with overflow:auto as focusable
// https://bugzilla.mozilla.org/show_bug.cgi?id=1069739
var isFirefox=-1<navigator.userAgent.toLowerCase().indexOf("firefox");if(isFirefox){this.$.scroller.tabIndex=-1}}_activated(active){if(active&&!this._initialized){this._createPool();this._initialized=!0}}_finishInit(){if(!this._initDone){// Once the first set of items start fading in, stamp the rest
this._buffers.forEach(buffer=>{[].forEach.call(buffer.children,insertionPoint=>this._ensureStampedInstance(insertionPoint._itemWrapper))},this);if(!this._buffers[0].translateY){this._reset()}this._initDone=!0}}_translateBuffer(up){var index=up?1:0;this._buffers[index].translateY=this._buffers[index?0:1].translateY+this._bufferHeight*(index?-1:1);this._buffers[index].style.transform="translate3d(0, "+this._buffers[index].translateY+"px, 0)";this._buffers[index].updated=!1;this._buffers.reverse()}_scroll(){if(this._scrollDisabled){return}var scrollTop=this.$.scroller.scrollTop;if(scrollTop<this._bufferHeight||scrollTop>2*this._initialScroll-this._bufferHeight){// Scrolled near the end/beginning of the scrollable area -> reset.
this._initialIndex=~~this.position;this._reset()}// Check if we scrolled enough to translate the buffer positions.
var bufferOffset=this.root.querySelector(".buffer").offsetTop,upperThresholdReached=scrollTop>this._buffers[1].translateY+this.itemHeight+bufferOffset,lowerThresholdReached=scrollTop<this._buffers[0].translateY+this.itemHeight+bufferOffset;if(upperThresholdReached||lowerThresholdReached){this._translateBuffer(lowerThresholdReached);this._updateClones()}if(!this._preventScrollEvent){this.dispatchEvent(new CustomEvent("custom-scroll",{bubbles:!1,composed:!0}));this._mayHaveMomentum=!0}this._preventScrollEvent=!1;this._debouncerScrollFinish=Polymer.Debouncer.debounce(this._debouncerScrollFinish,Polymer.Async.timeOut.after(200),()=>{var scrollerRect=this.$.scroller.getBoundingClientRect();if(!this._isVisible(this._buffers[0],scrollerRect)&&!this._isVisible(this._buffers[1],scrollerRect)){this.position=this.position}})}/**
       * Current scroller position as index. Can be a fractional number.
       *
       * @type {Number}
       */set position(index){this._preventScrollEvent=!0;if(index>this._firstIndex&&index<this._firstIndex+2*this.bufferSize){this.$.scroller.scrollTop=this.itemHeight*(index-this._firstIndex)+this._buffers[0].translateY}else{this._initialIndex=~~index;this._reset();this._scrollDisabled=!0;this.$.scroller.scrollTop+=index%1*this.itemHeight;this._scrollDisabled=!1}if(this._mayHaveMomentum){// Stop the possible iOS Safari momentum with -webkit-overflow-scrolling: auto;
this.$.scroller.classList.add("notouchscroll");this._mayHaveMomentum=!1;setTimeout(()=>{// Restore -webkit-overflow-scrolling: touch; after a small delay.
this.$.scroller.classList.remove("notouchscroll")},10)}}/**
       * @private
       */get position(){return(this.$.scroller.scrollTop-this._buffers[0].translateY)/this.itemHeight+this._firstIndex}get itemHeight(){if(!this._itemHeightVal){if(!(window.ShadyCSS&&window.ShadyCSS.nativeCss)){this.updateStyles()}const itemHeight=window.ShadyCSS?window.ShadyCSS.getComputedStyleValue(this,"--vaadin-infinite-scroller-item-height"):getComputedStyle(this).getPropertyValue("--vaadin-infinite-scroller-item-height"),tmpStyleProp="background-position";// Use background-position temp inline style for unit conversion
this.$.fullHeight.style.setProperty(tmpStyleProp,itemHeight);const itemHeightPx=getComputedStyle(this.$.fullHeight).getPropertyValue(tmpStyleProp);this.$.fullHeight.style.removeProperty(tmpStyleProp);this._itemHeightVal=parseFloat(itemHeightPx)}return this._itemHeightVal}get _bufferHeight(){return this.itemHeight*this.bufferSize}_reset(){this._scrollDisabled=!0;this.$.scroller.scrollTop=this._initialScroll;this._buffers[0].translateY=this._initialScroll-this._bufferHeight;this._buffers[1].translateY=this._initialScroll;this._buffers.forEach(buffer=>{buffer.style.transform="translate3d(0, "+buffer.translateY+"px, 0)"});this._buffers[0].updated=this._buffers[1].updated=!1;this._updateClones(!0);this._debouncerUpdateClones=Polymer.Debouncer.debounce(this._debouncerUpdateClones,Polymer.Async.timeOut.after(200),()=>{this._buffers[0].updated=this._buffers[1].updated=!1;this._updateClones()});this._scrollDisabled=!1}_createPool(){var container=this.getBoundingClientRect();this._buffers.forEach(buffer=>{for(var i=0;i<this.bufferSize;i++){const itemWrapper=document.createElement("div");itemWrapper.style.height=this.itemHeight+"px";itemWrapper.instance={};const contentId=InfiniteScrollerElement._contentIndex=InfiniteScrollerElement._contentIndex+1||0,slotName="vaadin-infinite-scroller-item-content-"+contentId,insertionPoint=document.createElement("slot");insertionPoint.setAttribute("name",slotName);insertionPoint._itemWrapper=itemWrapper;buffer.appendChild(insertionPoint);itemWrapper.setAttribute("slot",slotName);this.appendChild(itemWrapper);// This is needed by IE
Polymer.flush();setTimeout(()=>{// Only stamp the visible instances first
if(this._isVisible(itemWrapper,container)){this._ensureStampedInstance(itemWrapper)}},1);// Wait for first reset
}},this);setTimeout(()=>{Polymer.RenderStatus.afterNextRender(this,this._finishInit.bind(this))},1)}_ensureStampedInstance(itemWrapper){if(itemWrapper.firstElementChild){return}var tmpInstance=itemWrapper.instance;itemWrapper.instance=new this._TemplateClass({});itemWrapper.appendChild(itemWrapper.instance.root);Object.keys(tmpInstance).forEach(prop=>{itemWrapper.instance.set(prop,tmpInstance[prop])})}_updateClones(viewPortOnly){this._firstIndex=~~((this._buffers[0].translateY-this._initialScroll)/this.itemHeight)+this._initialIndex;var scrollerRect=viewPortOnly?this.$.scroller.getBoundingClientRect():void 0;this._buffers.forEach((buffer,bufferIndex)=>{if(!buffer.updated){var firstIndex=this._firstIndex+this.bufferSize*bufferIndex;[].forEach.call(buffer.children,(insertionPoint,index)=>{const itemWrapper=insertionPoint._itemWrapper;if(!viewPortOnly||this._isVisible(itemWrapper,scrollerRect)){itemWrapper.instance.index=firstIndex+index}});buffer.updated=!0}},this)}_isVisible(element,container){var rect=element.getBoundingClientRect();return rect.bottom>container.top&&rect.top<container.bottom}}customElements.define(InfiniteScrollerElement.is,InfiniteScrollerElement)})();</script><dom-module id="vaadin-date-picker-overlay-styles" theme-for="vaadin-date-picker-overlay" assetpath="../bower_components/vaadin-date-picker/src/"><template><style>:host{align-items:flex-start;justify-content:flex-start;}:host([bottom-aligned]){justify-content:flex-end;}:host([right-aligned]){align-items:flex-end;}:host([dir="rtl"]){align-items:flex-end;}:host([dir="rtl"][right-aligned]){align-items:flex-start;}[part="overlay"]{display:flex;flex:auto;}[part~="content"]{flex:auto;}</style></template></dom-module><dom-module id="vaadin-date-picker-overlay-content" assetpath="../bower_components/vaadin-date-picker/src/"><template><style>:host{display:flex;flex-direction:column;height:100%;width:100%;outline:none;background:#fff;}[part="overlay-header"]{display:flex;flex-shrink:0;flex-wrap:nowrap;align-items:center;}:host(:not([fullscreen])) [part="overlay-header"]{display:none;}[part="label"]{flex-grow:1;}[part="clear-button"]:not([showclear]){display:none;}[part="years-toggle-button"]{display:flex;}[part="years-toggle-button"][desktop]{display:none;}:host(:not([years-visible])) [part="years-toggle-button"]::before{transform:rotate(180deg);}#scrollers{display:flex;height:100%;width:100%;position:relative;overflow:hidden;}[part="months"],
      [part="years"]{height:100%;}[part="months"]{--vaadin-infinite-scroller-item-height:270px;position:absolute;top:0;left:0;right:0;bottom:0;}#scrollers[desktop] [part="months"]{right:50px;transform:none !important;}[part="years"]{--vaadin-infinite-scroller-item-height:80px;width:50px;position:absolute;right:0;transform:translateX(100%);-webkit-tap-highlight-color:transparent;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;--vaadin-infinite-scroller-buffer-offset:50%;}#scrollers[desktop] [part="years"]{position:absolute;transform:none !important;}[part="years"]::before{content:'';display:block;background:transparent;width:0;height:0;position:absolute;left:0;top:50%;transform:translateY(-50%);border-width:6px;border-style:solid;border-color:transparent;border-left-color:#000;}:host(.animate) [part="months"],
      :host(.animate) [part="years"]{transition:all 200ms;}[part="toolbar"]{display:flex;justify-content:space-between;z-index:2;flex-shrink:0;}[part~="overlay-header"]:not([desktop]){padding-bottom:40px;}[part~="years-toggle-button"]{position:absolute;top:auto;right:8px;bottom:0;z-index:1;padding:8px;}#announcer{display:inline-block;position:fixed;clip:rect(0, 0, 0, 0);clip-path:inset(100%);}</style><div id="announcer" role="alert" aria-live="polite">[[i18n.calendar]]</div><div part="overlay-header" on-touchend="_preventDefault" desktop$="[[_desktopMode]]" aria-hidden="true"><div part="label">[[_formatDisplayed(selectedDate, i18n.formatDate, label)]]</div><div part="clear-button" on-tap="_clear" showclear$="[[_showClear(selectedDate)]]"></div><div part="toggle-button" on-tap="_cancel"></div><div part="years-toggle-button" desktop$="[[_desktopMode]]" on-tap="_toggleYearScroller" aria-hidden="true">[[_yearAfterXMonths(_visibleMonthIndex)]]</div></div><div id="scrollers" desktop$="[[_desktopMode]]" on-track="_track"><vaadin-infinite-scroller id="monthScroller" on-custom-scroll="_onMonthScroll" on-touchstart="_onMonthScrollTouchStart" buffer-size="3" active="[[initialPosition]]" part="months"><template><vaadin-month-calendar i18n="[[i18n]]" month="[[_dateAfterXMonths(index)]]" selected-date="{{selectedDate}}" focused-date="[[focusedDate]]" ignore-taps="[[_ignoreTaps]]" show-week-numbers="[[showWeekNumbers]]" min-date="[[minDate]]" max-date="[[maxDate]]" focused$="[[_focused]]" part="month" theme$="[[theme]]"></vaadin-month-calendar></template></vaadin-infinite-scroller><vaadin-infinite-scroller id="yearScroller" on-tap="_onYearTap" on-custom-scroll="_onYearScroll" on-touchstart="_onYearScrollTouchStart" buffer-size="12" active="[[initialPosition]]" part="years"><template><div part="year-number" role="button" current$="[[_isCurrentYear(index)]]" selected$="[[_isSelectedYear(index, selectedDate)]]">[[_yearAfterXYears(index)]]</div><div part="year-separator" aria-hidden="true"></div></template></vaadin-infinite-scroller></div><div on-touchend="_preventDefault" role="toolbar" part="toolbar"><vaadin-button id="todayButton" part="today-button" disabled="[[!_isTodayAllowed(minDate, maxDate)]]" on-tap="_onTodayTap">[[i18n.today]]</vaadin-button><vaadin-button id="cancelButton" part="cancel-button" on-tap="_cancel">[[i18n.cancel]]</vaadin-button></div><iron-media-query query="(min-width: 375px)" query-matches="{{_desktopMode}}"></iron-media-query></template><script>(function(){/**
       * @memberof Vaadin
       * @private
       */class DatePickerOverlayContentElement extends Vaadin.ThemableMixin(Vaadin.ThemePropertyMixin(Vaadin.DirMixin(Polymer.GestureEventListeners(Polymer.Element)))){static get is(){return"vaadin-date-picker-overlay-content"}static get properties(){return{/**
             * The value for this element.
             */selectedDate:{type:Date,notify:!0},/**
             * Date value which is focused using keyboard.
             */focusedDate:{type:Date,notify:!0,observer:"_focusedDateChanged"},_focusedMonthDate:Number,/**
             * Date which should be visible when there is no value selected.
             */initialPosition:{type:Date,observer:"_initialPositionChanged"},_originDate:{value:new Date},_visibleMonthIndex:Number,_desktopMode:Boolean,_translateX:{observer:"_translateXChanged"},_yearScrollerWidth:{value:50},i18n:{type:Object},showWeekNumbers:{type:Boolean},_ignoreTaps:Boolean,_notTapping:Boolean,/**
             * The earliest date that can be selected. All earlier dates will be disabled.
             */minDate:Date,/**
             * The latest date that can be selected. All later dates will be disabled.
             */maxDate:Date,_focused:Boolean,/**
             * Input label
             */label:String}}get __isRTL(){return"rtl"===this.getAttribute("dir")}ready(){super.ready();this.setAttribute("tabindex",0);this.addEventListener("keydown",this._onKeydown.bind(this));Polymer.Gestures.addListener(this,"tap",this._stopPropagation);this.addEventListener("focus",this._onOverlayFocus.bind(this));this.addEventListener("blur",this._onOverlayBlur.bind(this))}/**
         * Fired when the scroller reaches the target scrolling position.
         * @event scroll-animation-finished
         * @param {Number} detail.position new position
         * @param {Number} detail.oldPosition old position
         */connectedCallback(){super.connectedCallback();this._closeYearScroller();this._toggleAnimateClass(!0);Polymer.Gestures.setTouchAction(this.$.scrollers,"pan-y");Polymer.IronA11yAnnouncer.requestAvailability()}announceFocusedDate(){var focusedDate=this._currentlyFocusedDate(),announce=[];if(Vaadin.DatePickerHelper._dateEquals(focusedDate,new Date)){announce.push(this.i18n.today)}announce=announce.concat([this.i18n.weekdays[focusedDate.getDay()],focusedDate.getDate(),this.i18n.monthNames[focusedDate.getMonth()],focusedDate.getFullYear()]);if(this.showWeekNumbers&&1===this.i18n.firstDayOfWeek){announce.push(this.i18n.week);announce.push(Vaadin.DatePickerHelper._getISOWeekNumber(focusedDate))}this.dispatchEvent(new CustomEvent("iron-announce",{bubbles:!0,composed:!0,detail:{text:announce.join(" ")}}));return}/**
         * Focuses the cancel button
         */focusCancel(){this.$.cancelButton.focus()}/**
         * Scrolls the list to the given Date.
         */scrollToDate(date,animate){this._scrollToPosition(this._differenceInMonths(date,this._originDate),animate)}_focusedDateChanged(focusedDate){this.revealDate(focusedDate)}_isCurrentYear(yearsFromNow){return 0===yearsFromNow}_isSelectedYear(yearsFromNow,selectedDate){if(selectedDate){return selectedDate.getFullYear()===this._originDate.getFullYear()+yearsFromNow}}/**
         * Scrolls the month and year scrollers enough to reveal the given date.
         */revealDate(date){if(date){var diff=this._differenceInMonths(date,this._originDate),scrolledAboveViewport=this.$.monthScroller.position>diff,visibleItems=this.$.monthScroller.clientHeight/this.$.monthScroller.itemHeight,scrolledBelowViewport=this.$.monthScroller.position+visibleItems-1<diff;if(scrolledAboveViewport){this._scrollToPosition(diff,!0)}else if(scrolledBelowViewport){this._scrollToPosition(diff-visibleItems+1,!0)}}}_onOverlayFocus(){this._focused=!0}_onOverlayBlur(){this._focused=!1}_initialPositionChanged(initialPosition){this.scrollToDate(initialPosition)}_repositionYearScroller(){this._visibleMonthIndex=Math.floor(this.$.monthScroller.position);this.$.yearScroller.position=(this.$.monthScroller.position+this._originDate.getMonth())/12}_repositionMonthScroller(){this.$.monthScroller.position=12*this.$.yearScroller.position-this._originDate.getMonth();this._visibleMonthIndex=Math.floor(this.$.monthScroller.position)}_onMonthScroll(){this._repositionYearScroller();this._doIgnoreTaps()}_onYearScroll(){this._repositionMonthScroller();this._doIgnoreTaps()}_onYearScrollTouchStart(){this._notTapping=!1;setTimeout(()=>this._notTapping=!0,300);this._repositionMonthScroller()}_onMonthScrollTouchStart(){this._repositionYearScroller()}_doIgnoreTaps(){this._ignoreTaps=!0;this._debouncer=Polymer.Debouncer.debounce(this._debouncer,Polymer.Async.timeOut.after(300),()=>this._ignoreTaps=!1)}_formatDisplayed(date,formatDate,label){if(date){return formatDate(Vaadin.DatePickerHelper._extractDateParts(date))}else{return label}}_onTodayTap(){var today=new Date;if(.001>Math.abs(this.$.monthScroller.position-this._differenceInMonths(today,this._originDate))){// Select today only if the month scroller is positioned approximately
// at the beginning of the current month
this.selectedDate=today;this._close()}else{this._scrollToCurrentMonth()}}_scrollToCurrentMonth(){if(this.focusedDate){this.focusedDate=new Date}this.scrollToDate(new Date,!0)}_showClear(selectedDate){return!!selectedDate}_onYearTap(e){if(!this._ignoreTaps&&!this._notTapping){var scrollDelta=e.detail.y-(this.$.yearScroller.getBoundingClientRect().top+this.$.yearScroller.clientHeight/2),yearDelta=scrollDelta/this.$.yearScroller.itemHeight;this._scrollToPosition(this.$.monthScroller.position+12*yearDelta,!0)}}_scrollToPosition(targetPosition,animate){if(this._targetPosition!==void 0){this._targetPosition=targetPosition;return}if(!animate){this.$.monthScroller.position=targetPosition;this._targetPosition=void 0;this._repositionYearScroller();return}this._targetPosition=targetPosition;// http://gizma.com/easing/
var easingFunction=(t,b,c,d)=>{t/=d/2;if(1>t){return c/2*t*t+b}t--;return-c/2*(t*(t-2)-1)+b},duration=animate?300:0,start=0,initialPosition=this.$.monthScroller.position,smoothScroll=timestamp=>{start=start||timestamp;var currentTime=timestamp-start;if(currentTime<duration){var currentPos=easingFunction(currentTime,initialPosition,this._targetPosition-initialPosition,duration);this.$.monthScroller.position=currentPos;window.requestAnimationFrame(smoothScroll)}else{this.dispatchEvent(new CustomEvent("scroll-animation-finished",{bubbles:!0,composed:!0,detail:{position:this._targetPosition,oldPosition:initialPosition}}));this.$.monthScroller.position=this._targetPosition;this._targetPosition=void 0}setTimeout(this._repositionYearScroller.bind(this),1)};// Start the animation.
window.requestAnimationFrame(smoothScroll)}_limit(value,range){return Math.min(range.max,Math.max(range.min,value))}_handleTrack(e){// Check if horizontal movement threshold (dx) not exceeded or
// scrolling fast vertically (ddy).
if(10>Math.abs(e.detail.dx)||10<Math.abs(e.detail.ddy)){return}// If we're flinging quickly -> start animating already.
if(Math.abs(e.detail.ddx)>this._yearScrollerWidth/3){this._toggleAnimateClass(!0)}var newTranslateX=this._translateX+e.detail.ddx;this._translateX=this._limit(newTranslateX,{min:0,max:this._yearScrollerWidth})}_track(e){if(this._desktopMode){// No need to track for swipe gestures on desktop.
return}switch(e.detail.state){case"start":this._toggleAnimateClass(!1);break;case"track":this._handleTrack(e);break;case"end":this._toggleAnimateClass(!0);if(this._translateX>=this._yearScrollerWidth/2){this._closeYearScroller()}else{this._openYearScroller()}break;}}_toggleAnimateClass(enable){if(enable){this.classList.add("animate")}else{this.classList.remove("animate")}}_toggleYearScroller(){this._isYearScrollerVisible()?this._closeYearScroller():this._openYearScroller()}_openYearScroller(){this._translateX=0;this.setAttribute("years-visible","")}_closeYearScroller(){this.removeAttribute("years-visible");this._translateX=this._yearScrollerWidth}_isYearScrollerVisible(){return this._translateX<this._yearScrollerWidth/2}_translateXChanged(x){if(!this._desktopMode){this.$.monthScroller.style.transform="translateX("+(x-this._yearScrollerWidth)+"px)";this.$.yearScroller.style.transform="translateX("+x+"px)"}}_yearAfterXYears(index){var result=new Date(this._originDate);result.setFullYear(parseInt(index)+this._originDate.getFullYear());return result.getFullYear()}_yearAfterXMonths(months){return this._dateAfterXMonths(months).getFullYear()}_dateAfterXMonths(months){var result=new Date(this._originDate);result.setDate(1);result.setMonth(parseInt(months)+this._originDate.getMonth());return result}_differenceInMonths(date1,date2){var months=12*(date1.getFullYear()-date2.getFullYear());return months-date2.getMonth()+date1.getMonth()}_differenceInYears(date1,date2){return this._differenceInMonths(date1,date2)/12}_clear(){this.selectedDate=""}_close(){const overlayContent=this.getRootNode().host,overlay=overlayContent?overlayContent.getRootNode().host:null;if(overlay){overlay.opened=!1}this.dispatchEvent(new CustomEvent("close",{bubbles:!0,composed:!0}))}_cancel(){this.focusedDate=this.selectedDate;this._close()}_preventDefault(e){e.preventDefault()}/**
         * Keyboard Navigation
         */_eventKey(e){for(var keys=["down","up","right","left","enter","space","home","end","pageup","pagedown","tab","esc"],i=0,k;i<keys.length;i++){k=keys[i];if(Polymer.IronA11yKeysBehavior.keyboardEventMatchesKeys(e,k)){return k}}}_onKeydown(e){var focus=this._currentlyFocusedDate();// Cannot use (today/cancel).focused flag because vaadin-text-field removes it
// previously in the keydown event.
const isToday=0<=e.composedPath().indexOf(this.$.todayButton),isCancel=0<=e.composedPath().indexOf(this.$.cancelButton),isScroller=!isToday&&!isCancel;var eventKey=this._eventKey(e);if("tab"===eventKey){// We handle tabs here and don't want to bubble up.
e.stopPropagation();const isFullscreen=this.hasAttribute("fullscreen"),isShift=e.shiftKey;if(isFullscreen){e.preventDefault()}else if(isShift&&isScroller||!isShift&&isCancel){// Return focus back to the input field
e.preventDefault();this.dispatchEvent(new CustomEvent("focus-input",{bubbles:!0,composed:!0}))}else if(isShift&&isToday){// Browser returns focus back to the scrollable area. We need to set
// the focused flag, and move the scroll to focused date.
this._focused=!0;setTimeout(()=>this.revealDate(this.focusedDate),1)}else{// Browser moves the focus out of the scroller, hence focused flag must
// set to false.
this._focused=!1}}else if(eventKey){e.preventDefault();e.stopPropagation();switch(eventKey){case"down":this._moveFocusByDays(7);this.focus();break;case"up":this._moveFocusByDays(-7);this.focus();break;case"right":if(isScroller){this._moveFocusByDays(this.__isRTL?-1:1)}break;case"left":if(isScroller){this._moveFocusByDays(this.__isRTL?1:-1)}break;case"enter":if(isScroller||isCancel){this._close()}else if(isToday){this._onTodayTap()}break;case"space":if(isCancel){this._close()}else if(isToday){this._onTodayTap()}else{var focusedDate=this.focusedDate;if(Vaadin.DatePickerHelper._dateEquals(focusedDate,this.selectedDate)){this.selectedDate="";this.focusedDate=focusedDate}else{this.selectedDate=focusedDate}}break;case"home":this._moveFocusInsideMonth(focus,"minDate");break;case"end":this._moveFocusInsideMonth(focus,"maxDate");break;case"pagedown":this._moveFocusByMonths(e.shiftKey?12:1);break;case"pageup":this._moveFocusByMonths(e.shiftKey?-12:-1);break;case"esc":this._cancel();break;}}}_currentlyFocusedDate(){return this.focusedDate||this.selectedDate||this.initialPosition||new Date}_focusDate(dateToFocus){this.focusedDate=dateToFocus;this._focusedMonthDate=dateToFocus.getDate()}_focusClosestDate(focus){this._focusDate(Vaadin.DatePickerHelper._getClosestDate(focus,[this.minDate,this.maxDate]))}_moveFocusByDays(days){var focus=this._currentlyFocusedDate(),dateToFocus=new Date(0,0);dateToFocus.setFullYear(focus.getFullYear());dateToFocus.setMonth(focus.getMonth());dateToFocus.setDate(focus.getDate()+days);if(this._dateAllowed(dateToFocus,this.minDate,this.maxDate)){this._focusDate(dateToFocus)}else{if(this._dateAllowed(focus,this.minDate,this.maxDate)){// Move to min or max date
if(0<days){// down or right
this._focusDate(this.maxDate)}else{// up or left
this._focusDate(this.minDate)}}else{// Move to closest allowed date
this._focusClosestDate(focus)}}}_moveFocusByMonths(months){var focus=this._currentlyFocusedDate(),dateToFocus=new Date(0,0);dateToFocus.setFullYear(focus.getFullYear());dateToFocus.setMonth(focus.getMonth()+months);var targetMonth=dateToFocus.getMonth();dateToFocus.setDate(this._focusedMonthDate||(this._focusedMonthDate=focus.getDate()));if(dateToFocus.getMonth()!==targetMonth){dateToFocus.setDate(0)}if(this._dateAllowed(dateToFocus,this.minDate,this.maxDate)){this.focusedDate=dateToFocus}else{if(this._dateAllowed(focus,this.minDate,this.maxDate)){// Move to min or max date
if(0<months){// pagedown
this._focusDate(this.maxDate)}else{// pageup
this._focusDate(this.minDate)}}else{// Move to closest allowed date
this._focusClosestDate(focus)}}}_moveFocusInsideMonth(focusedDate,property){var dateToFocus=new Date(0,0);dateToFocus.setFullYear(focusedDate.getFullYear());if("minDate"===property){dateToFocus.setMonth(focusedDate.getMonth());dateToFocus.setDate(1)}else{dateToFocus.setMonth(focusedDate.getMonth()+1);dateToFocus.setDate(0)}if(this._dateAllowed(dateToFocus,this.minDate,this.maxDate)){this._focusDate(dateToFocus)}else{if(this._dateAllowed(focusedDate,this.minDate,this.maxDate)){// Move to minDate or maxDate
this._focusDate(this[property])}else{// Move to closest allowed date
this._focusClosestDate(focusedDate)}}}_dateAllowed(date,min,max){return(!min||date>=min)&&(!max||date<=max)}_isTodayAllowed(min,max){var today=new Date,todayMidnight=new Date(0,0);todayMidnight.setFullYear(today.getFullYear());todayMidnight.setMonth(today.getMonth());todayMidnight.setDate(today.getDate());return this._dateAllowed(todayMidnight,min,max)}_stopPropagation(e){e.stopPropagation()}}customElements.define(DatePickerOverlayContentElement.is,DatePickerOverlayContentElement)})();</script></dom-module><script>window.Vaadin=window.Vaadin||{};/**
   * @polymerMixin
   */Vaadin.DatePickerMixin=subclass=>class VaadinDatePickerMixin extends Polymer.mixinBehaviors([Polymer.IronResizableBehavior],subclass){static get properties(){return{/**
         * The current selected date.
         */_selectedDate:{type:Date},_focusedDate:Date,/**
         * The value for this element.
         *
         * Supported date formats:
         * - ISO 8601 `"YYYY-MM-DD"` (default)
         * - 6-digit extended ISO 8601 `"+YYYYYY-MM-DD"`, `"-YYYYYY-MM-DD"`
         *
         * @type {String}
         */value:{type:String,observer:"_valueChanged",notify:!0,value:""},/**
         * Set to true to mark the input as required.
         */required:{type:Boolean,value:!1},/**
         * The name of this element.
         */name:{type:String},/**
         * Date which should be visible when there is no value selected.
         *
         * The same date formats as for the `value` property are supported.
         */initialPosition:String,/**
         * The label for this element.
         */label:String,/**
         * Set true to open the date selector overlay.
         */opened:{type:Boolean,reflectToAttribute:!0,notify:!0,observer:"_openedChanged"},/**
         * Set true to prevent the overlay from opening automatically.
         */autoOpenDisabled:Boolean,/**
         * Set true to display ISO-8601 week numbers in the calendar. Notice that
         * displaying week numbers is only supported when `i18n.firstDayOfWeek`
         * is 1 (Monday).
         */showWeekNumbers:{type:Boolean},_fullscreen:{value:!1,observer:"_fullscreenChanged"},_fullscreenMediaQuery:{value:"(max-width: 420px), (max-height: 420px)"},// An array of ancestor elements whose -webkit-overflow-scrolling is forced from value
// 'touch' to value 'auto' in order to prevent them from clipping the dropdown. iOS only.
_touchPrevented:Array,/**
         * The object used to localize this component.
         * To change the default localization, replace the entire
         * _i18n_ object or just the property you want to modify.
         *
         * The object has the following JSON structure and default values:

            {
              // An array with the full names of months starting
              // with January.
              monthNames: [
                'January', 'February', 'March', 'April', 'May',
                'June', 'July', 'August', 'September',
                'October', 'November', 'December'
              ],

              // An array of weekday names starting with Sunday. Used
              // in screen reader announcements.
              weekdays: [
                'Sunday', 'Monday', 'Tuesday', 'Wednesday',
                'Thursday', 'Friday', 'Saturday'
              ],

              // An array of short weekday names starting with Sunday.
              // Displayed in the calendar.
              weekdaysShort: [
                'Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'
              ],

              // An integer indicating the first day of the week
              // (0 = Sunday, 1 = Monday, etc.).
              firstDayOfWeek: 0,

              // Used in screen reader announcements along with week
              // numbers, if they are displayed.
              week: 'Week',

              // Translation of the Calendar icon button title.
              calendar: 'Calendar',

              // Translation of the Clear icon button title.
              clear: 'Clear',

              // Translation of the Today shortcut button text.
              today: 'Today',

              // Translation of the Cancel button text.
              cancel: 'Cancel',

              // A function to format given `Object` as
              // date string. Object is in the format `{ day: ..., month: ..., year: ... }`
              // Note: The argument month is 0-based. This means that January = 0 and December = 11.
              formatDate: d => {
                // returns a string representation of the given
                // object in 'MM/DD/YYYY' -format
              },

              // A function to parse the given text to an `Object` in the format `{ day: ..., month: ..., year: ... }`.
              // Must properly parse (at least) text formatted by `formatDate`.
              // Setting the property to null will disable keyboard input feature.
              // Note: The argument month is 0-based. This means that January = 0 and December = 11.
              parseDate: text => {
                // Parses a string in 'MM/DD/YY', 'MM/DD' or 'DD' -format to
                // an `Object` in the format `{ day: ..., month: ..., year: ... }`.
              }

              // A function to format given `monthName` and
              // `fullYear` integer as calendar title string.
              formatTitle: (monthName, fullYear) => {
                return monthName + ' ' + fullYear;
              }
            }

         *
         * @default {English/US}
         */i18n:{type:Object,value:()=>{return{monthNames:["January","February","March","April","May","June","July","August","September","October","November","December"],weekdays:["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"],weekdaysShort:["Sun","Mon","Tue","Wed","Thu","Fri","Sat"],firstDayOfWeek:0,week:"Week",calendar:"Calendar",clear:"Clear",today:"Today",cancel:"Cancel",formatDate:d=>{const yearStr=(d.year+"").replace(/\d+/,y=>"0000".substr(y.length)+y);return[d.month+1,d.day,yearStr].join("/")},parseDate:text=>{const parts=text.split("/"),today=new Date;let date,month=today.getMonth(),year=today.getFullYear();if(3===parts.length){year=parseInt(parts[2]);if(3>parts[2].length&&0<=year){year+=50>year?2e3:1900}month=parseInt(parts[0])-1;date=parseInt(parts[1])}else if(2===parts.length){month=parseInt(parts[0])-1;date=parseInt(parts[1])}else if(1===parts.length){date=parseInt(parts[0])}if(date!==void 0){return{day:date,month,year}}},formatTitle:(monthName,fullYear)=>{return monthName+" "+fullYear}}}},/**
         * The earliest date that can be selected. All earlier dates will be disabled.
         *
         * Supported date formats:
         * - ISO 8601 `"YYYY-MM-DD"` (default)
         * - 6-digit extended ISO 8601 `"+YYYYYY-MM-DD"`, `"-YYYYYY-MM-DD"`
         *
         * @type {String}
         */min:{type:String,observer:"_minChanged"},/**
         * The latest date that can be selected. All later dates will be disabled.
         *
         * Supported date formats:
         * - ISO 8601 `"YYYY-MM-DD"` (default)
         * - 6-digit extended ISO 8601 `"+YYYYYY-MM-DD"`, `"-YYYYYY-MM-DD"`
         *
         * @type {String}
         */max:{type:String,observer:"_maxChanged"},/**
         * The earliest date that can be selected. All earlier dates will be disabled.
         */_minDate:{type:Date,// null does not work here because minimizer passes undefined to overlay (#351)
value:""},/**
         * The latest date that can be selected. All later dates will be disabled.
         */_maxDate:{type:Date,value:""},_noInput:{type:Boolean,computed:"_isNoInput(_fullscreen, _ios, i18n, i18n.*)"},_ios:{type:Boolean,value:navigator.userAgent.match(/iP(?:hone|ad;(?: U;)? CPU) OS (\d+)/)},_webkitOverflowScroll:{type:Boolean,value:""===document.createElement("div").style.webkitOverflowScrolling},_ignoreAnnounce:{value:!0},_focusOverlayOnOpen:Boolean,_overlayInitialized:Boolean}}static get observers(){return["_updateHasValue(value)","_selectedDateChanged(_selectedDate, i18n.formatDate)","_focusedDateChanged(_focusedDate, i18n.formatDate)","_announceFocusedDate(_focusedDate, opened, _ignoreAnnounce)"]}ready(){super.ready();this._boundOnScroll=this._onScroll.bind(this);this._boundFocus=this._focus.bind(this);this._boundUpdateAlignmentAndPosition=this._updateAlignmentAndPosition.bind(this);const isClearButton=e=>{const path=e.composedPath(),inputIndex=path.indexOf(this._inputElement);return 1===path.slice(0,inputIndex).filter(el=>el.getAttribute&&"clear-button"===el.getAttribute("part")).length};Polymer.Gestures.addListener(this,"tap",e=>{// FIXME(platosha): use preventDefault in the text field clear button,
// then the following composedPath check could be simplified down
// to `if (!e.defaultPrevented)`.
// https://github.com/vaadin/vaadin-text-field/issues/352
if(!isClearButton(e)&&(!this.autoOpenDisabled||this._noInput)){this.open()}});this.addEventListener("touchend",e=>{if(!isClearButton(e)){e.preventDefault()}});this.addEventListener("keydown",this._onKeydown.bind(this));this.addEventListener("input",this._onUserInput.bind(this));this.addEventListener("focus",e=>this._noInput&&e.target.blur());this.addEventListener("blur",e=>{if(!this.opened){if(this.autoOpenDisabled){const parsedDate=this._getParsedDate();if(this._isValidDate(parsedDate)){this._selectedDate=parsedDate}}if(""===this._inputElement.value&&this.__dispatchChange){this.validate();this.value="";this.__dispatchChange=!1}else{this.validate()}}})}_initOverlay(){this.$.overlay.removeAttribute("disable-upgrade");this._overlayInitialized=!0;this.$.overlay.addEventListener("opened-changed",e=>this.opened=e.detail.value);this._overlayContent.addEventListener("close",this._close.bind(this));this._overlayContent.addEventListener("focus-input",this._focusAndSelect.bind(this));this.$.overlay.addEventListener("vaadin-overlay-escape-press",this._boundFocus);// Keep focus attribute in focusElement for styling
this._overlayContent.addEventListener("focus",()=>this.focusElement._setFocused(!0));this.$.overlay.addEventListener("vaadin-overlay-close",this._onVaadinOverlayClose.bind(this));const bringToFrontListener=e=>{if(this.$.overlay.bringToFront){requestAnimationFrame(()=>{this.$.overlay.bringToFront()})}};this.addEventListener("mousedown",bringToFrontListener);this.addEventListener("touchstart",bringToFrontListener)}/**
     * @protected
     */disconnectedCallback(){super.disconnectedCallback();if(this._overlayInitialized){this.$.overlay.removeEventListener("vaadin-overlay-escape-press",this._boundFocus)}this.opened=!1}/**
     * Opens the dropdown.
     */open(){if(!this.disabled&&!this.readonly){this.opened=!0}}_close(e){if(e){e.stopPropagation()}this._focus();this.close()}/**
     * Closes the dropdown.
     */close(){if(this._overlayInitialized||this.autoOpenDisabled){this.$.overlay.close()}}get _inputElement(){return this._input()}get _nativeInput(){if(this._inputElement){// vaadin-text-field's input is focusElement
// iron-input's input is inputElement
return this._inputElement.focusElement?this._inputElement.focusElement:this._inputElement.inputElement?this._inputElement.inputElement:window.unwrap?window.unwrap(this._inputElement):this._inputElement}}_parseDate(str){// Parsing with RegExp to ensure correct format
var parts=/^([-+]\d{1}|\d{2,4}|[-+]\d{6})-(\d{1,2})-(\d{1,2})$/.exec(str);if(!parts){return}var date=new Date(0,0);// Wrong date (1900-01-01), but with midnight in local time
date.setFullYear(parseInt(parts[1],10));date.setMonth(parseInt(parts[2],10)-1);date.setDate(parseInt(parts[3],10));return date}_isNoInput(fullscreen,ios,i18n){return!this._inputElement||fullscreen||ios||!i18n.parseDate}_formatISO(date){if(!(date instanceof Date)){return""}const pad=(num,fmt="00")=>(fmt+num).substr((fmt+num).length-fmt.length);let yearSign="",yearFmt="0000",yearAbs=date.getFullYear();if(0>yearAbs){yearAbs=-yearAbs;yearSign="-";yearFmt="000000"}else if(1e4<=date.getFullYear()){yearSign="+";yearFmt="000000"}const year=yearSign+pad(yearAbs,yearFmt),month=pad(date.getMonth()+1),day=pad(date.getDate());return[year,month,day].join("-")}_openedChanged(opened){if(opened&&!this._overlayInitialized){this._initOverlay()}if(this._overlayInitialized){this.$.overlay.opened=opened}if(opened){this._updateAlignmentAndPosition()}}_selectedDateChanged(selectedDate,formatDate){if(selectedDate===void 0||formatDate===void 0){return}if(this.__userInputOccurred){this.__dispatchChange=!0}const value=this._formatISO(selectedDate);this.__keepInputValue||this._applyInputValue(selectedDate);if(value!==this.value){this.validate();this.value=value}this.__userInputOccurred=!1;this.__dispatchChange=!1;this._ignoreFocusedDateChange=!0;this._focusedDate=selectedDate;this._ignoreFocusedDateChange=!1}_focusedDateChanged(focusedDate,formatDate){if(focusedDate===void 0||formatDate===void 0){return}this.__userInputOccurred=!0;if(!this._ignoreFocusedDateChange&&!this._noInput){this._applyInputValue(focusedDate)}}_updateHasValue(value){if(value){this.setAttribute("has-value","")}else{this.removeAttribute("has-value")}}__getOverlayTheme(theme,overlayInitialized){if(overlayInitialized){return theme}}_handleDateChange(property,value,oldValue){if(!value){this[property]="";return}var date=this._parseDate(value);if(!date){this.value=oldValue;return}if(!Vaadin.DatePickerHelper._dateEquals(this[property],date)){this[property]=date;this.value&&this.validate()}}_valueChanged(value,oldValue){if(this.__dispatchChange){this.dispatchEvent(new CustomEvent("change",{bubbles:!0}))}this._handleDateChange("_selectedDate",value,oldValue)}_minChanged(value,oldValue){this._handleDateChange("_minDate",value,oldValue)}_maxChanged(value,oldValue){this._handleDateChange("_maxDate",value,oldValue)}_updateAlignmentAndPosition(){if(!this._overlayInitialized){return}if(!this._fullscreen){const inputRect=this._inputElement.getBoundingClientRect(),bottomAlign=inputRect.top>window.innerHeight/2,rightAlign=inputRect.left+this.clientWidth/2>window.innerWidth/2;if(rightAlign){const viewportWidth=Math.min(window.innerWidth,document.documentElement.clientWidth);this.$.overlay.setAttribute("right-aligned","");this.$.overlay.style.removeProperty("left");this.$.overlay.style.right=viewportWidth-inputRect.right+"px"}else{this.$.overlay.removeAttribute("right-aligned");this.$.overlay.style.removeProperty("right");this.$.overlay.style.left=inputRect.left+"px"}if(bottomAlign){const viewportHeight=Math.min(window.innerHeight,document.documentElement.clientHeight);this.$.overlay.setAttribute("bottom-aligned","");this.$.overlay.style.removeProperty("top");this.$.overlay.style.bottom=viewportHeight-inputRect.top+"px"}else{this.$.overlay.removeAttribute("bottom-aligned");this.$.overlay.style.removeProperty("bottom");this.$.overlay.style.top=inputRect.bottom+"px"}}this.$.overlay.setAttribute("dir",getComputedStyle(this._inputElement).getPropertyValue("direction"));this._overlayContent._repositionYearScroller()}_fullscreenChanged(){if(this._overlayInitialized&&this.$.overlay.opened){this._updateAlignmentAndPosition()}}_onOverlayOpened(){this._openedWithFocusRing=this.hasAttribute("focus-ring")||this.focusElement&&this.focusElement.hasAttribute("focus-ring");var parsedInitialPosition=this._parseDate(this.initialPosition),initialPosition=this._selectedDate||this._overlayContent.initialPosition||parsedInitialPosition||new Date;if(parsedInitialPosition||Vaadin.DatePickerHelper._dateAllowed(initialPosition,this._minDate,this._maxDate)){this._overlayContent.initialPosition=initialPosition}else{this._overlayContent.initialPosition=Vaadin.DatePickerHelper._getClosestDate(initialPosition,[this._minDate,this._maxDate])}this._overlayContent.scrollToDate(this._overlayContent.focusedDate||this._overlayContent.initialPosition);// Have a default focused date
this._ignoreFocusedDateChange=!0;this._overlayContent.focusedDate=this._overlayContent.focusedDate||this._overlayContent.initialPosition;this._ignoreFocusedDateChange=!1;window.addEventListener("scroll",this._boundOnScroll,!0);this.addEventListener("iron-resize",this._boundUpdateAlignmentAndPosition);if(this._webkitOverflowScroll){this._touchPrevented=this._preventWebkitOverflowScrollingTouch(this.parentElement)}if(this._focusOverlayOnOpen){this._overlayContent.focus();this._focusOverlayOnOpen=!1}else{this._focus()}if(this._noInput&&this.focusElement){this.focusElement.blur()}this.updateStyles();this._ignoreAnnounce=!1}// A hack needed for iOS to prevent dropdown from being clipped in an
// ancestor container with -webkit-overflow-scrolling: touch;
_preventWebkitOverflowScrollingTouch(element){var result=[];while(element){if("touch"===window.getComputedStyle(element).webkitOverflowScrolling){var oldInlineValue=element.style.webkitOverflowScrolling;element.style.webkitOverflowScrolling="auto";result.push({element:element,oldInlineValue:oldInlineValue})}element=element.parentElement}return result}_selectParsedOrFocusedDate(){// Select the parsed input or focused date
this._ignoreFocusedDateChange=!0;if(this.i18n.parseDate){const inputValue=this._inputValue||"",parsedDate=this._getParsedDate(inputValue);if(this._isValidDate(parsedDate)){this._selectedDate=parsedDate}else{this.__keepInputValue=!0;this._selectedDate=null;this.__keepInputValue=!1}}else if(this._focusedDate){this._selectedDate=this._focusedDate}this._ignoreFocusedDateChange=!1}_onOverlayClosed(){this._ignoreAnnounce=!0;window.removeEventListener("scroll",this._boundOnScroll,!0);this.removeEventListener("iron-resize",this._boundUpdateAlignmentAndPosition);if(this._touchPrevented){this._touchPrevented.forEach(prevented=>prevented.element.style.webkitOverflowScrolling=prevented.oldInlineValue);this._touchPrevented=[]}this.updateStyles();this._selectParsedOrFocusedDate();if(this._nativeInput&&this._nativeInput.selectionStart){this._nativeInput.selectionStart=this._nativeInput.selectionEnd}// No need to revalidate the value after `_selectedDateChanged`
// Needed in case the value was not changed: open and close dropdown.
if(!this.value){this.validate()}}/**
     * Returns true if `value` is valid, and sets the `invalid` flag appropriately.
     *
     * @param {string} value Value to validate. Optional, defaults to user's input value.
     * @return {boolean} True if the value is valid and sets the `invalid` flag appropriately
     */validate(){// Note (Yuriy): Workaround `this._inputValue` is used in order
// to avoid breaking change on custom `checkValidity`.
// Can be removed with next major.
return!(this.invalid=!this.checkValidity(this._inputValue))}/**
     * Returns true if the current input value satisfies all constraints (if any)
     *
     * Override the `checkValidity` method for custom validations.
     *
     * @param {string} value Value to validate. Optional, defaults to the selected date.
     * @return {boolean} True if the value is valid
     */checkValidity(){const inputValid=!this._inputValue||this._selectedDate&&this._inputValue===this._getFormattedDate(this.i18n.formatDate,this._selectedDate),minMaxValid=!this._selectedDate||Vaadin.DatePickerHelper._dateAllowed(this._selectedDate,this._minDate,this._maxDate);let inputValidity=!0;if(this._inputElement){if(this._inputElement.checkValidity){// vaadin native input elements have the checkValidity method
this._inputElement.__forceCheckValidity=!0;inputValidity=this._inputElement.checkValidity();this._inputElement.__forceCheckValidity=!1}else if(this._inputElement.validate){// iron-form-elements have the validate API
inputValidity=this._inputElement.validate()}}return inputValid&&minMaxValid&&inputValidity}_onScroll(e){if(e.target===window||!this._overlayContent.contains(e.target)){this._updateAlignmentAndPosition()}}_focus(){if(this._noInput){this._overlayInitialized&&this._overlayContent.focus()}else{this._inputElement.focus()}}_focusAndSelect(){this._focus();this._setSelectionRange(0,this._inputValue.length)}_applyInputValue(date){this._inputValue=date?this._getFormattedDate(this.i18n.formatDate,date):""}_getFormattedDate(formatDate,date){return formatDate(Vaadin.DatePickerHelper._extractDateParts(date))}_setSelectionRange(a,b){if(this._nativeInput&&this._nativeInput.setSelectionRange){this._nativeInput.setSelectionRange(a,b)}}/**
     * Keyboard Navigation
     */_eventKey(e){for(var keys=["down","up","enter","esc","tab"],i=0,k;i<keys.length;i++){k=keys[i];if(Polymer.IronA11yKeysBehavior.keyboardEventMatchesKeys(e,k)){return k}}}_isValidDate(d){return d&&!isNaN(d.getTime())}_onKeydown(e){if(this._noInput){// The input element cannot be readonly as it would conflict with
// the required attribute. Both are not allowed on an input element.
// Therefore we prevent default on most keydown events.
var allowedKeys=[9// tab
];if(-1===allowedKeys.indexOf(e.keyCode)){e.preventDefault()}}switch(this._eventKey(e)){case"down":case"up":// prevent scrolling the page with arrows
e.preventDefault();if(this.opened){this._overlayContent.focus();this._overlayContent._onKeydown(e)}else{this._focusOverlayOnOpen=!0;this.open()}break;case"enter":{const parsedDate=this._getParsedDate(),isValidDate=this._isValidDate(parsedDate);if(this.opened){if(this._overlayInitialized&&this._overlayContent.focusedDate&&isValidDate){this._selectedDate=this._overlayContent.focusedDate}this.close()}else{if(!isValidDate&&""!==this._inputElement.value){this.validate()}else{const oldValue=this.value;this._selectParsedOrFocusedDate();if(oldValue===this.value){this.validate()}}}break}case"esc":if(this.opened){this._focusedDate=this._selectedDate;this._close()}else if(this.autoOpenDisabled){// Do not restore selected date if Esc was pressed after clearing input field
if(""===this._inputElement.value){this._selectedDate=null}this._applyInputValue(this._selectedDate)}else{this._focusedDate=this._selectedDate;this._selectParsedOrFocusedDate()}break;case"tab":if(this.opened){e.preventDefault();// Clear the selection range (remains visible on IE)
this._setSelectionRange(0,0);if(e.shiftKey){this._overlayContent.focusCancel()}else{this._overlayContent.focus();this._overlayContent.revealDate(this._focusedDate)}}break;}}_getParsedDate(inputValue=this._inputValue){const dateObject=this.i18n.parseDate&&this.i18n.parseDate(inputValue),parsedDate=dateObject&&this._parseDate(dateObject.year+"-"+(dateObject.month+1)+"-"+dateObject.day);return parsedDate}_onUserInput(e){if(!this.opened&&this._inputElement.value&&!this.autoOpenDisabled){this.open()}this._userInputValueChanged();if(e.__fromClearButton){this.validate();this.__dispatchChange=!0;this.value="";this.__dispatchChange=!1}}_userInputValueChanged(value){if(this.opened&&this._inputValue){const parsedDate=this._getParsedDate();if(this._isValidDate(parsedDate)){this._ignoreFocusedDateChange=!0;if(!Vaadin.DatePickerHelper._dateEquals(parsedDate,this._focusedDate)){this._focusedDate=parsedDate}this._ignoreFocusedDateChange=!1}}}_announceFocusedDate(_focusedDate,opened,_ignoreAnnounce){if(opened&&!_ignoreAnnounce){this._overlayContent.announceFocusedDate()}}get _overlayContent(){return this.$.overlay.content.querySelector("#overlay-content")}/**
     * Fired when the user commits a value change.
     *
     * @event change
     */};</script><dom-module id="vaadin-date-picker" assetpath="../bower_components/vaadin-date-picker/src/"><template><style>:host{display:inline-block;}:host([hidden]){display:none !important;}:host([opened]){pointer-events:auto;}[part="text-field"]{width:100%;min-width:0;}</style><vaadin-date-picker-text-field id="input" role="application" autocomplete="off" on-focus="_focus" value="{{_userInputValue}}" invalid="[[invalid]]" label="[[label]]" name="[[name]]" placeholder="[[placeholder]]" required="[[required]]" disabled="[[disabled]]" readonly="[[readonly]]" error-message="[[errorMessage]]" clear-button-visible="[[clearButtonVisible]]" aria-label$="[[label]]" part="text-field" theme$="[[theme]]"><slot name="prefix" slot="prefix"></slot><div part="toggle-button" slot="suffix" on-tap="_toggle" role="button" aria-label$="[[i18n.calendar]]" aria-expanded$="[[_getAriaExpanded(opened)]]"></div></vaadin-date-picker-text-field><vaadin-date-picker-overlay id="overlay" fullscreen$="[[_fullscreen]]" theme$="[[__getOverlayTheme(theme, _overlayInitialized)]]" on-vaadin-overlay-open="_onOverlayOpened" on-vaadin-overlay-close="_onOverlayClosed" disable-upgrade=""><template><vaadin-date-picker-overlay-content id="overlay-content" i18n="[[i18n]]" fullscreen$="[[_fullscreen]]" label="[[label]]" selected-date="{{_selectedDate}}" slot="dropdown-content" focused-date="{{_focusedDate}}" show-week-numbers="[[showWeekNumbers]]" min-date="[[_minDate]]" max-date="[[_maxDate]]" role="dialog" on-date-tap="_close" part="overlay-content" theme$="[[__getOverlayTheme(theme, _overlayInitialized)]]"></vaadin-date-picker-overlay-content></template></vaadin-date-picker-overlay><iron-media-query query="[[_fullscreenMediaQuery]]" query-matches="{{_fullscreen}}"></iron-media-query></template><script>(function(){/**
       *
       * `<vaadin-date-picker>` is a date selection field which includes a scrollable
       * month calendar view.
       * ```html
       * <vaadin-date-picker label="Birthday"></vaadin-date-picker>
       * ```
       * ```js
       * datePicker.value = '2016-03-02';
       * ```
       * When the selected `value` is changed, a `value-changed` event is triggered.
       *
       *
       * ### Styling
       *
       * The following shadow DOM parts are available for styling:
       *
       * Part name | Description | Theme for Element
       * ----------------|----------------|----------------
       * `text-field` | Input element | vaadin-date-picker
       * `clear-button` | Clear button | vaadin-date-picker
       * `toggle-button` | Toggle button | vaadin-date-picker
       * `overlay-content` | The overlay element | vaadin-date-picker
       * `overlay-header` | Fullscreen mode header | vaadin-date-picker-overlay-content
       * `label` | Fullscreen mode value/label | vaadin-date-picker-overlay-content
       * `clear-button` | Fullscreen mode clear button | vaadin-date-picker-overlay-content
       * `toggle-button` | Fullscreen mode toggle button | vaadin-date-picker-overlay-content
       * `years-toggle-button` | Fullscreen mode years scroller toggle | vaadin-date-picker-overlay-content
       * `months` | Months scroller | vaadin-date-picker-overlay-content
       * `years` | Years scroller | vaadin-date-picker-overlay-content
       * `toolbar` | Footer bar with buttons | vaadin-date-picker-overlay-content
       * `today-button` | Today button | vaadin-date-picker-overlay-content
       * `cancel-button` | Cancel button | vaadin-date-picker-overlay-content
       * `month` | Month calendar | vaadin-date-picker-overlay-content
       * `year-number` | Year number | vaadin-date-picker-overlay-content
       * `year-separator` | Year separator | vaadin-date-picker-overlay-content
       * `month-header` | Month title | vaadin-month-calendar
       * `weekdays` | Weekday container | vaadin-month-calendar
       * `weekday` | Weekday element | vaadin-month-calendar
       * `week-numbers` | Week numbers container | vaadin-month-calendar
       * `week-number` | Week number element | vaadin-month-calendar
       * `date` | Date element | vaadin-month-calendar
       *
       * See [ThemableMixin – how to apply styles for shadow parts](https://github.com/vaadin/vaadin-themable-mixin/wiki)
       *
       * The following state attributes are available for styling:
       *
       * Attribute    | Description | Part name
       * -------------|-------------|------------
       * `invalid` | Set when the element is invalid | :host
       * `opened` | Set when the date selector overlay is opened | :host
       * `readonly` | Set when the element is readonly | :host
       * `disabled` | Set when the element is disabled | :host
       * `today` | Set on the date corresponding to the current day | date
       * `focused` | Set on the focused date | date
       * `disabled` | Set on the date out of the allowed range | date
       * `selected` | Set on the selected date | date
       *
       * If you want to replace the default input field with a custom implementation, you should use the
       * [`<vaadin-date-picker-light>`](#vaadin-date-picker-light) element.
       *
       * In addition to `<vaadin-date-picker>` itself, the following internal
       * components are themable:
       *
       * - `<vaadin-text-field>`
       * - `<vaadin-date-picker-overlay>`
       * - `<vaadin-date-picker-overlay-content>`
       * - `<vaadin-month-calendar>`
       *
       * Note: the `theme` attribute value set on `<vaadin-date-picker>` is
       * propagated to the internal themable components listed above.
       *
       * @memberof Vaadin
       * @mixes Vaadin.ElementMixin
       * @mixes Vaadin.ControlStateMixin
       * @mixes Vaadin.ThemableMixin
       * @mixes Vaadin.ThemePropertyMixin
       * @mixes Vaadin.DatePickerMixin
       * @mixes Polymer.GestureEventListeners
       * @demo demo/index.html
       */class DatePickerElement extends Vaadin.ElementMixin(Vaadin.ControlStateMixin(Vaadin.ThemableMixin(Vaadin.ThemePropertyMixin(Vaadin.DatePickerMixin(Polymer.GestureEventListeners(Polymer.Element)))))){static get is(){return"vaadin-date-picker"}static get version(){return"4.2.0"}static get properties(){return{/**
             * Set to true to display the clear icon which clears the input.
             */clearButtonVisible:{type:Boolean,value:!1},/**
             * Set to true to disable this element.
             */disabled:{type:Boolean,value:!1,reflectToAttribute:!0},/**
             * The error message to display when the input is invalid.
             */errorMessage:String,/**
             * A placeholder string in addition to the label. If this is set, the label will always float.
             */placeholder:String,/**
             * Set to true to make this element read-only.
             */readonly:{type:Boolean,value:!1,reflectToAttribute:!0},/**
             * This property is set to true when the control value invalid.
             */invalid:{type:Boolean,reflectToAttribute:!0,notify:!0,value:!1},_userInputValue:String}}static get observers(){return["_userInputValueChanged(_userInputValue)","_setClearButtonLabel(i18n.clear)"]}ready(){super.ready();// In order to have synchronized invalid property, we need to use the same validate logic.
Polymer.RenderStatus.afterNextRender(this,()=>this._inputElement.validate=()=>{});this._inputElement.addEventListener("change",e=>{// For change event on text-field blur, after the field is cleared,
// we schedule change event to be dispatched on date-picker blur.
if(""===this._inputElement.value&&!e.__fromClearButton){this.__dispatchChange=!0}})}_onVaadinOverlayClose(e){if(this._openedWithFocusRing&&this.hasAttribute("focused")){this.focusElement.setAttribute("focus-ring","")}else if(!this.hasAttribute("focused")){this.focusElement.blur()}if(e.detail.sourceEvent&&-1!==e.detail.sourceEvent.composedPath().indexOf(this)){e.preventDefault()}}_toggle(e){e.stopPropagation();this[this._overlayInitialized&&this.$.overlay.opened?"close":"open"]()}_input(){return this.$.input}set _inputValue(value){this._inputElement.value=value}get _inputValue(){return this._inputElement.value}_getAriaExpanded(opened){return(!!opened).toString()}/**
         * Focussable element used by vaadin-control-state-mixin
         */get focusElement(){return this._input()||this}_setClearButtonLabel(i18nClear){// FIXME(platosha): expose i18n API in <vaadin-text-field>
// https://github.com/vaadin/vaadin-text-field/issues/348
this._inputElement.shadowRoot.querySelector("[part=\"clear-button\"]").setAttribute("aria-label",i18nClear)}}customElements.define(DatePickerElement.is,DatePickerElement);/**
       * @namespace Vaadin
       */window.Vaadin.DatePickerElement=DatePickerElement})();</script></dom-module><dom-module id="lumo-dialog" theme-for="vaadin-dialog-overlay" assetpath="../bower_components/vaadin-dialog/theme/lumo/"><template><style include="lumo-overlay">:host::before,
      :host::after{content:"";flex-basis:0;flex-grow:1;}:host::after{flex-grow:1.1;}[part="overlay"]{box-shadow:0 0 0 1px var(--lumo-shade-5pct), var(--lumo-box-shadow-xl);background-image:none;outline:none;-webkit-tap-highlight-color:transparent;}[part="content"]{padding:var(--lumo-space-l);}:host([opening]),
      :host([closing]){animation:0.25s lumo-overlay-dummy-animation;}:host([opening]) [part="overlay"]{animation:0.12s 0.05s vaadin-dialog-enter cubic-bezier(.215, .61, .355, 1) both;}@keyframes vaadin-dialog-enter{0%{opacity:0;transform:scale(0.95);}}:host([closing]) [part="overlay"]{animation:0.1s 0.03s vaadin-dialog-exit cubic-bezier(.55, .055, .675, .19) both;}:host([closing]) [part="backdrop"]{animation-delay:0.05s;}@keyframes vaadin-dialog-exit{100%{opacity:0;transform:scale(1.02);}}</style></template></dom-module><script>const TOUCH_DEVICE=(()=>{try{document.createEvent("TouchEvent");return!0}catch(e){return!1}})();/**
   * @namespace Vaadin
   */window.Vaadin=window.Vaadin||{};/**
   * @polymerMixin
   * @memberof Vaadin
   */Vaadin.DialogDraggableMixin=superClass=>class VaadinDialogDraggableMixin extends superClass{static get properties(){return{_touchDevice:{type:Boolean,value:TOUCH_DEVICE},/* TODO: Expose as a public property (check naming) */__dragHandleClassName:{type:String}}}ready(){super.ready();this._originalBounds={};this._originalMouseCoords={};this._startDrag=this._startDrag.bind(this);this._drag=this._drag.bind(this);this._stopDrag=this._stopDrag.bind(this);this.$.overlay.$.overlay.addEventListener("mousedown",this._startDrag);this.$.overlay.$.overlay.addEventListener("touchstart",this._startDrag)}_startDrag(e){// Don't initiate when there's more than 1 touch (pinch zoom)
if("touchstart"===e.type&&1<e.touches.length){return}if(this.draggable&&(0===e.button||e.touches)){const resizerContainer=this.$.overlay.$.resizerContainer,isResizerContainer=e.target===resizerContainer,isResizerContainerScrollbar=e.offsetX>resizerContainer.clientWidth||e.offsetY>resizerContainer.clientHeight,isContentPart=e.target===this.$.overlay.$.content,isDraggable=e.composedPath().some((node,index)=>{if(node.classList){const isDraggableNode=node.classList.contains(this.__dragHandleClassName||"draggable"),isDraggableLeafOnly=node.classList.contains("draggable-leaf-only"),isLeafNode=0===index;return isDraggableLeafOnly&&isLeafNode||isDraggableNode&&(!isDraggableLeafOnly||isLeafNode)}});if(isResizerContainer&&!isResizerContainerScrollbar||isContentPart||isDraggable){isDraggable||e.preventDefault();this._originalBounds=this._getOverlayBounds();const event=this.__getMouseOrFirstTouchEvent(e);this._originalMouseCoords={top:event.pageY,left:event.pageX};window.addEventListener("mouseup",this._stopDrag);window.addEventListener("touchend",this._stopDrag);window.addEventListener("mousemove",this._drag);window.addEventListener("touchmove",this._drag);if("absolute"!==this.$.overlay.$.overlay.style.position){this._setBounds(this._originalBounds)}}}}_drag(e){const event=this.__getMouseOrFirstTouchEvent(e);if(this._eventInWindow(event)){const top=this._originalBounds.top+(event.pageY-this._originalMouseCoords.top),left=this._originalBounds.left+(event.pageX-this._originalMouseCoords.left);this._setBounds({top,left})}}_stopDrag(){window.removeEventListener("mouseup",this._stopDrag);window.removeEventListener("touchend",this._stopDrag);window.removeEventListener("mousemove",this._drag);window.removeEventListener("touchmove",this._drag)}};</script><dom-module id="vaadin-dialog-resizable-overlay-styles" theme-for="vaadin-dialog-overlay" assetpath="../bower_components/vaadin-dialog/src/"><template><style>[part='overlay']{position:relative;overflow:visible;max-height:100%;display:flex;}[part='content']{box-sizing:border-box;height:100%;}.resizer-container{overflow:auto;flex-grow:1;}[part='overlay'][style] .resizer-container{min-height:100%;width:100%;}:host(:not([resizable])) .resizer{display:none;}.resizer{position:absolute;height:16px;width:16px;}.resizer.edge{height:8px;width:8px;top:-4px;right:-4px;bottom:-4px;left:-4px;}.resizer.edge.n{width:auto;bottom:auto;cursor:ns-resize;}.resizer.ne{top:-4px;right:-4px;cursor:nesw-resize;}.resizer.edge.e{height:auto;left:auto;cursor:ew-resize;}.resizer.se{bottom:-4px;right:-4px;cursor:nwse-resize;}.resizer.edge.s{width:auto;top:auto;cursor:ns-resize;}.resizer.sw{bottom:-4px;left:-4px;cursor:nesw-resize;}.resizer.edge.w{height:auto;right:auto;cursor:ew-resize;}.resizer.nw{top:-4px;left:-4px;cursor:nwse-resize;}_:-ms-fullscreen,
      [part='overlay']{max-height:none;}</style></template></dom-module><script>/**
   * @namespace Vaadin
   */window.Vaadin=window.Vaadin||{};/**
   * @polymerMixin
   * @memberof Vaadin
   */Vaadin.DialogResizableMixin=superClass=>class VaadinDialogResizableMixin extends superClass{ready(){super.ready();this._originalBounds={};this._originalMouseCoords={};this._resizeListeners={start:{},resize:{},stop:{}};this._addResizeListeners()}_addResizeListeners(){// Note: edge controls added before corners
["n","e","s","w","nw","ne","se","sw"].forEach(direction=>{const resizer=document.createElement("div");this._resizeListeners.start[direction]=e=>this._startResize(e,direction);this._resizeListeners.resize[direction]=e=>this._resize(e,direction);this._resizeListeners.stop[direction]=()=>this._stopResize(direction);if(1===direction.length){resizer.classList.add("edge")}resizer.classList.add("resizer");resizer.classList.add(direction);resizer.addEventListener("mousedown",this._resizeListeners.start[direction]);resizer.addEventListener("touchstart",this._resizeListeners.start[direction]);this.$.overlay.$.resizerContainer.appendChild(resizer)})}_startResize(e,direction){// Don't initiate when there's more than 1 touch (pinch zoom)
if("touchstart"===e.type&&1<e.touches.length){return}if(0===e.button||e.touches){e.preventDefault();this._originalBounds=this._getOverlayBounds();const event=this.__getMouseOrFirstTouchEvent(e);this._originalMouseCoords={top:event.pageY,left:event.pageX};window.addEventListener("mousemove",this._resizeListeners.resize[direction]);window.addEventListener("touchmove",this._resizeListeners.resize[direction]);window.addEventListener("mouseup",this._resizeListeners.stop[direction]);window.addEventListener("touchend",this._resizeListeners.stop[direction]);if("absolute"!==this.$.overlay.$.overlay.style.position){this._setBounds(this._originalBounds)}}}_resize(e,resizer){const event=this.__getMouseOrFirstTouchEvent(e);if(this._eventInWindow(event)){const minimumSize=40;resizer.split("").forEach(direction=>{switch(direction){case"n":{const height=this._originalBounds.height-(event.pageY-this._originalMouseCoords.top),top=this._originalBounds.top+(event.pageY-this._originalMouseCoords.top);if(height>minimumSize){this._setBounds({top,height})}break}case"e":{const width=this._originalBounds.width+(event.pageX-this._originalMouseCoords.left);if(width>minimumSize){this._setBounds({width})}break}case"s":{const height=this._originalBounds.height+(event.pageY-this._originalMouseCoords.top);if(height>minimumSize){this._setBounds({height})}break}case"w":{const width=this._originalBounds.width-(event.pageX-this._originalMouseCoords.left),left=this._originalBounds.left+(event.pageX-this._originalMouseCoords.left);if(width>minimumSize){this._setBounds({left,width})}break}}});this.$.overlay.notifyResize()}}_stopResize(direction){window.removeEventListener("mousemove",this._resizeListeners.resize[direction]);window.removeEventListener("touchmove",this._resizeListeners.resize[direction]);window.removeEventListener("mouseup",this._resizeListeners.stop[direction]);window.removeEventListener("touchend",this._resizeListeners.stop[direction]);this.dispatchEvent(new CustomEvent("resize",{detail:this._getResizeDimensions()}))}_getResizeDimensions(){const scrollPosition=this.$.overlay.$.resizerContainer.scrollTop,{width,height}=getComputedStyle(this.$.overlay.$.overlay),content=this.$.overlay.$.content;content.setAttribute("style","position: absolute; top: 0; right: 0; bottom: 0; left: 0; box-sizing: content-box; height: auto;");const{width:contentWidth,height:contentHeight}=getComputedStyle(content);content.removeAttribute("style");this.$.overlay.$.resizerContainer.scrollTop=scrollPosition;return{width,height,contentWidth,contentHeight}}};</script><dom-module id="vaadin-dialog-overlay-styles" theme-for="vaadin-dialog-overlay" assetpath="../bower_components/vaadin-dialog/src/"><template><style>[part="content"]{min-width:12em;}:host([has-bounds-set]) [part="overlay"]{max-width:none;}</style></template></dom-module><dom-module id="vaadin-dialog" assetpath="../bower_components/vaadin-dialog/src/"><template><style>:host{display:none;}</style><vaadin-dialog-overlay id="overlay" on-opened-changed="_onOverlayOpened" on-mousedown="_bringOverlayToFront" on-touchstart="_bringOverlayToFront" theme$="[[theme]]" modeless="[[modeless]]" with-backdrop="[[!modeless]]" resizable$="[[resizable]]" focus-trap=""></vaadin-dialog-overlay></template><script>(function(){let memoizedTemplate;/**
       * @namespace Vaadin
       */window.Vaadin=window.Vaadin||{};/**
       * The overlay element.
       *
       * ### Styling
       *
       * See [`<vaadin-overlay>` documentation](https://github.com/vaadin/vaadin-overlay/blob/master/src/vaadin-overlay.html)
       * for `<vaadin-dialog-overlay>` parts.
       *
       * @memberof Vaadin
       * @private
       */class DialogOverlayElement extends Polymer.mixinBehaviors(Polymer.IronResizableBehavior,Vaadin.OverlayElement){static get is(){return"vaadin-dialog-overlay"}static get template(){if(!memoizedTemplate){memoizedTemplate=super.template.cloneNode(!0);const contentPart=memoizedTemplate.content.querySelector("[part=\"content\"]"),overlayPart=memoizedTemplate.content.querySelector("[part=\"overlay\"]"),resizerContainer=document.createElement("div");resizerContainer.id="resizerContainer";resizerContainer.classList.add("resizer-container");resizerContainer.appendChild(contentPart);overlayPart.appendChild(resizerContainer)}return memoizedTemplate}static get properties(){return{modeless:Boolean,withBackdrop:Boolean}}}customElements.define(DialogOverlayElement.is,DialogOverlayElement);/**
       *
       * `<vaadin-dialog>` is a Web Component for creating customized modal dialogs. The content of the
       * dialog can be populated in two ways: imperatively by using renderer callback function and
       * declaratively by using Polymer's Templates.
       *
       * ### Rendering
       *
       * By default, the dialog uses the content provided by using the renderer callback function.
       *
       * The renderer function provides `root`, `dialog` arguments.
       * Generate DOM content, append it to the `root` element and control the state
       * of the host element by accessing `dialog`. Before generating new content,
       * users are able to check if there is already content in `root` for reusing it.
       *
       * ```html
       * <vaadin-dialog id="dialog"></vaadin-dialog>
       * ```
       * ```js
       * const dialog = document.querySelector('#dialog');
       * dialog.renderer = function(root, dialog) {
       *   root.textContent = "Sample dialog";
       * };
       * ```
       *
       * Renderer is called on the opening of the dialog.
       * DOM generated during the renderer call can be reused
       * in the next renderer call and will be provided with the `root` argument.
       * On first call it will be empty.
       *
       * ### Polymer Templates
       *
       * Alternatively, the content can be provided with Polymer's Template.
       * Dialog finds the first child template and uses that in case renderer callback function
       * is not provided. You can also set a custom template using the `template` property.
       *
       * ```html
       * <vaadin-dialog opened>
       *   <template>
       *     Sample dialog
       *   </template>
       * </vaadin-dialog>
       * ```
       *
       * ### Styling
       *
       * See [`<vaadin-overlay>` documentation](https://github.com/vaadin/vaadin-overlay/blob/master/src/vaadin-overlay.html)
       * for `<vaadin-dialog-overlay>` parts.
       *
       * Note: the `theme` attribute value set on `<vaadin-dialog>` is
       * propagated to the internal `<vaadin-dialog-overlay>` component.
       *
       * See [ThemableMixin – how to apply styles for shadow parts](https://github.com/vaadin/vaadin-themable-mixin/wiki)
       *
       * @memberof Vaadin
       * @mixes Vaadin.ElementMixin
       * @mixes Vaadin.ThemePropertyMixin
       * @demo demo/index.html
       */class DialogElement extends Vaadin.ThemePropertyMixin(Vaadin.ElementMixin(Vaadin.DialogDraggableMixin(Vaadin.DialogResizableMixin(Polymer.Element)))){static get is(){return"vaadin-dialog"}static get version(){return"2.4.5"}static get properties(){return{/**
             * True if the overlay is currently displayed.
             */opened:{type:Boolean,value:!1,notify:!0},/**
             * Set to true to disable closing dialog on outside click
             */noCloseOnOutsideClick:{type:Boolean,value:!1},/**
             * Set to true to disable closing dialog on Escape press
             */noCloseOnEsc:{type:Boolean,value:!1},/**
             * Set the `aria-label` attribute for assistive technologies like
             * screen readers. An `undefined` value for this property (the
             * default) means that the `aria-label` attribute is not present at
             * all.
             */ariaLabel:{type:String},/**
             * Theme to apply to the overlay element
             */theme:String,_contentTemplate:Object,/**
             * Custom function for rendering the content of the dialog.
             * Receives two arguments:
             *
             * - `root` The root container DOM element. Append your content to it.
             * - `dialog` The reference to the `<vaadin-dialog>` element.
             */renderer:Function,/**
             * Set to true to remove backdrop and allow click events on background elements.
             */modeless:{type:Boolean,value:!1},/**
             * Set to true to enable repositioning the dialog by clicking and dragging.
             *
             * By default, only the overlay area can be used to drag the element. But,
             * a child element can be marked as a draggable area by adding a
             * "`draggable`" class to it, this will by default make all of its children draggable also.
             * If you want a child element to be draggable
             * but still have its children non-draggable (by default), mark it with
             * "`draggable-leaf-only`" class name.
             *
             * @type {boolean}
             */draggable:{type:Boolean,value:!1,reflectToAttribute:!0},/**
             * Set to true to enable resizing the dialog by dragging the corners and edges.
             */resizable:{type:Boolean,value:!1,reflectToAttribute:!0},_oldTemplate:Object,_oldRenderer:Object}}static get observers(){return["_openedChanged(opened)","_ariaLabelChanged(ariaLabel)","_templateOrRendererChanged(_contentTemplate, renderer)"]}ready(){super.ready();this.$.overlay.setAttribute("role","dialog");this.$.overlay.addEventListener("vaadin-overlay-outside-click",this._handleOutsideClick.bind(this));this.$.overlay.addEventListener("vaadin-overlay-escape-press",this._handleEscPress.bind(this));this._observer=new Polymer.FlattenedNodesObserver(this,info=>{this._setTemplateFromNodes(info.addedNodes)})}_setTemplateFromNodes(nodes){this._contentTemplate=nodes.filter(node=>node.localName&&"template"===node.localName)[0]||this._contentTemplate}_removeNewRendererOrTemplate(template,oldTemplate,renderer,oldRenderer){if(template!==oldTemplate){this._contentTemplate=void 0}else if(renderer!==oldRenderer){this.renderer=void 0}}/**
         * Manually invoke existing renderer.
         */render(){this.$.overlay.render()}_templateOrRendererChanged(template,renderer){if(template&&renderer){this._removeNewRendererOrTemplate(template,this._oldTemplate,renderer,this._oldRenderer);throw new Error("You should only use either a renderer or a template for dialog content")}this._oldTemplate=template;this._oldRenderer=renderer;if(renderer){this.$.overlay.setProperties({owner:this,renderer:renderer})}}disconnectedCallback(){super.disconnectedCallback();this.opened=!1}_openedChanged(opened){if(opened){this.$.overlay.template=this.querySelector("template")}this.$.overlay.opened=opened}_ariaLabelChanged(ariaLabel){if(ariaLabel!==void 0&&null!==ariaLabel){this.$.overlay.setAttribute("aria-label",ariaLabel)}else{this.$.overlay.removeAttribute("aria-label")}}_onOverlayOpened(e){if(!1===e.detail.value){this.opened=!1}}/**
         * Close the dialog if `noCloseOnOutsideClick` isn't set to true
         */_handleOutsideClick(e){if(this.noCloseOnOutsideClick){e.preventDefault()}}/**
         * Close the dialog if `noCloseOnEsc` isn't set to true
         */_handleEscPress(e){if(this.noCloseOnEsc){e.preventDefault()}}_setBounds(bounds){const overlay=this.$.overlay.$.overlay,parsedBounds=Object.assign({},bounds);if("absolute"!==overlay.style.position){overlay.style.position="absolute";this.$.overlay.setAttribute("has-bounds-set","");this.__forceSafariReflow()}for(const arg in parsedBounds){if("number"===typeof parsedBounds[arg]){parsedBounds[arg]=`${parsedBounds[arg]}px`}}Object.assign(overlay.style,parsedBounds)}_bringOverlayToFront(){if(this.modeless){this.$.overlay.bringToFront()}}_getOverlayBounds(){const overlay=this.$.overlay.$.overlay,overlayBounds=overlay.getBoundingClientRect(),containerBounds=this.$.overlay.getBoundingClientRect(),top=overlayBounds.top-containerBounds.top,left=overlayBounds.left-containerBounds.left,width=overlayBounds.width,height=overlayBounds.height;return{top,left,width,height}}_eventInWindow(e){return 0<=e.clientX&&e.clientX<=window.innerWidth&&0<=e.clientY&&e.clientY<=window.innerHeight}__getMouseOrFirstTouchEvent(e){return e.touches?e.touches[0]:e}/**
         * Safari 13 renders overflowing elements incorrectly.
         * This forces it to recalculate height.
         * @private
         */__forceSafariReflow(){const scrollPosition=this.$.overlay.$.resizerContainer.scrollTop,overlay=this.$.overlay.$.overlay;overlay.style.display="block";window.requestAnimationFrame(()=>{overlay.style.display="";this.$.overlay.$.resizerContainer.scrollTop=scrollPosition})}}customElements.define(DialogElement.is,DialogElement);window.Vaadin.DialogElement=DialogElement})();</script></dom-module><dom-module id="lumo-text-area" theme-for="vaadin-text-area" assetpath="../bower_components/vaadin-text-field/theme/lumo/"><template><style include="lumo-text-field">[part="input-field"],
      [part="input-field"] ::slotted(textarea){padding-top:calc((var(--lumo-text-field-size) - 1em * var(--lumo-line-height-s)) / 2);padding-bottom:calc((var(--lumo-text-field-size) - 1em * var(--lumo-line-height-s)) / 2);height:auto;box-sizing:border-box;transition:background-color 0.1s;line-height:var(--lumo-line-height-s);}:host(:not([readonly])) [part="input-field"]::after{display:none;}:host([readonly]) [part="input-field"]{border:1px dashed var(--lumo-contrast-30pct);}:host([readonly]) [part="input-field"]::after{border:none;}:host(:hover:not([readonly]):not([focused])) [part="input-field"]{background-color:var(--lumo-contrast-20pct);}@media (pointer: coarse){:host(:hover:not([readonly]):not([focused])) [part="input-field"]{background-color:var(--lumo-contrast-10pct);}:host(:active:not([readonly]):not([focused])) [part="input-field"]{background-color:var(--lumo-contrast-20pct);}}[part="value"],
      [part="input-field"] ::slotted(textarea){line-height:inherit;--_lumo-text-field-overflow-mask-image:none;}[part="input-field"] ::slotted(iron-icon){margin-top:calc((var(--lumo-icon-size-m) - 1em * var(--lumo-line-height-s)) / -2);}[part="input-field"] [part="value"],
      [part="input-field"] ::slotted(textarea){white-space:pre-wrap;align-self:stretch;}</style></template></dom-module><dom-module id="vaadin-text-area" assetpath="../bower_components/vaadin-text-field/src/"><template><style include="vaadin-text-field-shared-styles">.vaadin-text-area-container{flex:auto;max-height:inherit;min-height:inherit;}[part="label"],
      [part="error-message"]{flex:none;}[part="input-field"]{overflow:auto;-webkit-overflow-scrolling:touch;}[part="value"]{resize:none;}[part="value"],
      [part="input-field"] ::slotted(*){align-self:flex-start;}@keyframes vaadin-text-area-appear{to{opacity:1;}}:host{animation:1ms vaadin-text-area-appear;}</style><div class="vaadin-text-area-container"><label part="label" on-click="focus" id="[[_labelId]]">[[label]]</label><div part="input-field" id="[[_inputId]]"><slot name="prefix"></slot><slot name="textarea"><textarea part="value"></textarea></slot><div part="clear-button" id="clearButton" role="button" aria-label$="[[i18n.clear]]"></div><slot name="suffix"></slot></div><div part="error-message" id="[[_errorId]]" aria-live="assertive" aria-hidden$="[[_getErrorMessageAriaHidden(invalid, errorMessage, _errorId)]]">[[errorMessage]]</div></div></template><script>(function(){/**
       * `<vaadin-text-area>` is a Web Component for text area control in forms.
       *
       * ```html
       * <vaadin-text-area label="Add description">
       * </vaadin-text-area>
       * ```
       *
       * ### Prefixes and suffixes
       *
       * These are child elements of a `<vaadin-text-area>` that are displayed
       * inline with the input, before or after.
       * In order for an element to be considered as a prefix, it must have the slot
       * attribute set to `prefix` (and similarly for `suffix`).
       *
       * ```html
       * <vaadin-text-area label="Add description">
       *   <div slot="prefix">Details:</div>
       *   <div slot="suffix">The end!</div>
       * </vaadin-text-area>
       * ```
       *
       * ### Styling
       *
       * The following shadow DOM parts are available for styling:
       *
       * Part name | Description
       * ----------------|----------------
       * `label` | The label element
       * `input-field` | The element that wraps prefix, value and suffix
       * `value` | The text value element inside the `input-field` element
       * `error-message` | The error message element
       *
       * The following state attributes are available for styling:
       *
       * Attribute    | Description | Part name
       * -------------|-------------|------------
       * `disabled` | Set to a disabled text field | :host
       * `has-value` | Set when the element has a value | :host
       * `has-label` | Set when the element has a label | :host
       * `invalid` | Set when the element is invalid | :host
       * `focused` | Set when the element is focused | :host
       * `focus-ring` | Set when the element is keyboard focused | :host
       * `readonly` | Set to a readonly text field | :host
       *
       * See [ThemableMixin – how to apply styles for shadow parts](https://github.com/vaadin/vaadin-themable-mixin/wiki)
       *
       * @memberof Vaadin
       * @mixes Vaadin.TextFieldMixin
       * @mixes Vaadin.ThemableMixin
       * @demo demo/index.html
       */class TextAreaElement extends Vaadin.ElementMixin(Vaadin.TextFieldMixin(Vaadin.ThemableMixin(Polymer.Element))){static get is(){return"vaadin-text-area"}static get version(){return"2.6.3"}static get observers(){return["_textAreaValueChanged(value)"]}ready(){super.ready();this._updateHeight();this.addEventListener("animationend",this._onAnimationEnd)}_onAnimationEnd(e){if(0===e.animationName.indexOf("vaadin-text-area-appear")){this._updateHeight()}}get _slottedTagName(){return"textarea"}_textAreaValueChanged(value){this._updateHeight()}_updateHeight(){const inputField=this.root.querySelector("[part=input-field]"),scrollTop=inputField.scrollTop,input=this.inputElement,inputWidth=getComputedStyle(input).width,valueLength=this.value?this.value.length:0;// Only clear the height when the content shortens to minimize scrollbar flickering.
if(this._oldValueLength>=valueLength){// Fix the input element width so its scroll height isn't affected by host's disappearing scrollbars
input.style.maxWidth=inputWidth;input.style.height="auto";// Avoid a jumpy Safari rendering issue
inputField.style.display="block"}this._oldValueLength=valueLength;const inputHeight=input.scrollHeight;if(inputHeight>input.clientHeight){input.style.height=inputHeight+"px"}// Restore
input.style.removeProperty("max-width");inputField.style.removeProperty("display");inputField.scrollTop=scrollTop;this._dispatchIronResizeEventIfNeeded("InputHeight",inputHeight)}/**
         * Fired when the text-area height changes.
         *
         * @event iron-resize
         */}customElements.define(TextAreaElement.is,TextAreaElement);/**
       * @namespace Vaadin
       */window.Vaadin=window.Vaadin||{};Vaadin.TextAreaElement=TextAreaElement})();</script></dom-module><dom-module id="lumo-progress-bar" theme-for="vaadin-progress-bar" assetpath="../bower_components/vaadin-progress-bar/theme/lumo/"><template><style>:host{height:calc(var(--lumo-size-l) / 10);margin:var(--lumo-space-s) 0;}[part="bar"]{border-radius:var(--lumo-border-radius);background-color:var(--lumo-contrast-10pct);}[part="value"]{border-radius:var(--lumo-border-radius);background-color:var(--lumo-primary-color);transform:none;width:calc(var(--vaadin-progress-value) * 100%);will-change:width;transition:0.1s width linear;}:host([indeterminate]) [part="value"]{--lumo-progress-indeterminate-progress-bar-background:linear-gradient(to right, var(--lumo-primary-color-10pct) 10%, var(--lumo-primary-color));--lumo-progress-indeterminate-progress-bar-background-reverse:linear-gradient(to left, var(--lumo-primary-color-10pct) 10%, var(--lumo-primary-color));width:100%;background-color:transparent !important;background-image:var(--lumo-progress-indeterminate-progress-bar-background);opacity:0.75;will-change:transform;animation:vaadin-progress-indeterminate 1.6s infinite cubic-bezier(.645, .045, .355, 1);}@keyframes vaadin-progress-indeterminate{0%{transform:scaleX(0.015);transform-origin:0% 0%;}25%{transform:scaleX(0.4);}50%{transform:scaleX(0.015);transform-origin:100% 0%;background-image:var(--lumo-progress-indeterminate-progress-bar-background);}50.1%{transform:scaleX(0.015);transform-origin:100% 0%;background-image:var(--lumo-progress-indeterminate-progress-bar-background-reverse);}75%{transform:scaleX(0.4);}100%{transform:scaleX(0.015);transform-origin:0% 0%;background-image:var(--lumo-progress-indeterminate-progress-bar-background-reverse);}}:host(:not([aria-valuenow])) [part="value"]::before,
      :host([indeterminate]) [part="value"]::before{content:"";display:block;width:100%;height:100%;border-radius:inherit;background-color:var(--lumo-primary-color);will-change:opacity;animation:vaadin-progress-pulse3 1.6s infinite cubic-bezier(.645, .045, .355, 1);}@keyframes vaadin-progress-pulse3{0%{opacity:1;}10%{opacity:0;}40%{opacity:0;}50%{opacity:1;}50.1%{opacity:1;}60%{opacity:0;}90%{opacity:0;}100%{opacity:1;}}:host([theme~="contrast"]) [part="value"],
      :host([theme~="contrast"]) [part="value"]::before{background-color:var(--lumo-contrast-80pct);--lumo-progress-indeterminate-progress-bar-background:linear-gradient(to right, var(--lumo-contrast-5pct) 10%, var(--lumo-contrast-80pct));--lumo-progress-indeterminate-progress-bar-background-reverse:linear-gradient(to left, var(--lumo-contrast-5pct) 10%, var(--lumo-contrast-60pct));}:host([theme~="error"]) [part="value"],
      :host([theme~="error"]) [part="value"]::before{background-color:var(--lumo-error-color);--lumo-progress-indeterminate-progress-bar-background:linear-gradient(to right, var(--lumo-error-color-10pct) 10%, var(--lumo-error-color));--lumo-progress-indeterminate-progress-bar-background-reverse:linear-gradient(to left, var(--lumo-error-color-10pct) 10%, var(--lumo-error-color));}:host([theme~="success"]) [part="value"],
      :host([theme~="success"]) [part="value"]::before{background-color:var(--lumo-success-color);--lumo-progress-indeterminate-progress-bar-background:linear-gradient(to right, var(--lumo-success-color-10pct) 10%, var(--lumo-success-color));--lumo-progress-indeterminate-progress-bar-background-reverse:linear-gradient(to left, var(--lumo-success-color-10pct) 10%, var(--lumo-success-color));}:host([indeterminate][dir="rtl"]) [part="value"]{--lumo-progress-indeterminate-progress-bar-background:linear-gradient(to left, var(--lumo-primary-color-10pct) 10%, var(--lumo-primary-color));--lumo-progress-indeterminate-progress-bar-background-reverse:linear-gradient(to right, var(--lumo-primary-color-10pct) 10%, var(--lumo-primary-color));animation:vaadin-progress-indeterminate-rtl 1.6s infinite cubic-bezier(.355, .045, .645, 1);}:host(:not([aria-valuenow])[dir="rtl"]) [part="value"]::before,
      :host([indeterminate][dir="rtl"]) [part="value"]::before{animation:vaadin-progress-pulse3 1.6s infinite cubic-bezier(.355, .045, .645, 1);}@keyframes vaadin-progress-indeterminate-rtl{0%{transform:scaleX(0.015);transform-origin:100% 0%;}25%{transform:scaleX(0.4);}50%{transform:scaleX(0.015);transform-origin:0% 0%;background-image:var(--lumo-progress-indeterminate-progress-bar-background);}50.1%{transform:scaleX(0.015);transform-origin:0% 0%;background-image:var(--lumo-progress-indeterminate-progress-bar-background-reverse);}75%{transform:scaleX(0.4);}100%{transform:scaleX(0.015);transform-origin:100% 0%;background-image:var(--lumo-progress-indeterminate-progress-bar-background-reverse);}}:host([theme~="contrast"][dir="rtl"]) [part="value"],
      :host([theme~="contrast"][dir="rtl"]) [part="value"]::before{--lumo-progress-indeterminate-progress-bar-background:linear-gradient(to left, var(--lumo-contrast-5pct) 10%, var(--lumo-contrast-80pct));--lumo-progress-indeterminate-progress-bar-background-reverse:linear-gradient(to right, var(--lumo-contrast-5pct) 10%, var(--lumo-contrast-60pct));}:host([theme~="error"][dir="rtl"]) [part="value"],
      :host([theme~="error"][dir="rtl"]) [part="value"]::before{--lumo-progress-indeterminate-progress-bar-background:linear-gradient(to left, var(--lumo-error-color-10pct) 10%, var(--lumo-error-color));--lumo-progress-indeterminate-progress-bar-background-reverse:linear-gradient(to right, var(--lumo-error-color-10pct) 10%, var(--lumo-error-color));}:host([theme~="success"][dir="rtl"]) [part="value"],
      :host([theme~="success"][dir="rtl"]) [part="value"]::before{--lumo-progress-indeterminate-progress-bar-background:linear-gradient(to left, var(--lumo-success-color-10pct) 10%, var(--lumo-success-color));--lumo-progress-indeterminate-progress-bar-background-reverse:linear-gradient(to right, var(--lumo-success-color-10pct) 10%, var(--lumo-success-color));}</style></template></dom-module><custom-style><style>@keyframes vaadin-progress-pulse3{0%{opacity:1;}10%{opacity:0;}40%{opacity:0;}50%{opacity:1;}50.1%{opacity:1;}60%{opacity:0;}90%{opacity:0;}100%{opacity:1;}}</style></custom-style><script>/**
   * @namespace Vaadin
   */window.Vaadin=window.Vaadin||{};/**
   * @polymerMixin
   * @memberof Vaadin
   */Vaadin.ProgressMixin=superClass=>class VaadinProgressMixin extends superClass{static get properties(){return{/**
           * Current progress value.
           */value:{type:Number,observer:"_valueChanged"},/**
           * Minimum bound of the progress bar.
           */min:{type:Number,value:0,observer:"_minChanged"},/**
           * Maximum bound of the progress bar.
           */max:{type:Number,value:1,observer:"_maxChanged"},/**
           * Indeterminate state of the progress bar.
           * This property takes precedence over other state properties (min, max, value).
           */indeterminate:{type:Boolean,value:!1,reflectToAttribute:!0}}}static get observers(){return["_normalizedValueChanged(value, min, max)"]}ready(){super.ready();this.setAttribute("role","progressbar")}_normalizedValueChanged(value,min,max){const newNormalizedValue=this._normalizeValue(value,min,max);this.style.setProperty("--vaadin-progress-value",newNormalizedValue);this.updateStyles({"--vaadin-progress-value":newNormalizedValue+""})}_valueChanged(newV,oldV){this.setAttribute("aria-valuenow",newV)}_minChanged(newV,oldV){this.setAttribute("aria-valuemin",newV)}_maxChanged(newV,oldV){this.setAttribute("aria-valuemax",newV)}/**
       * Percent of current progress relative to whole progress bar (max - min)
       */_normalizeValue(value,min,max){let nV;if(!value&&0!=value){nV=0}else if(min>=max){nV=1}else{nV=(value-min)/(max-min);nV=Math.min(Math.max(nV,0),1)}return nV}};</script><dom-module id="vaadin-progress-bar" assetpath="../bower_components/vaadin-progress-bar/src/"><template><style>:host{display:block;width:100%;height:8px;}:host([hidden]){display:none !important;}[part="bar"]{height:100%;}[part="value"]{height:100%;transform-origin:0 50%;transform:scaleX(var(--vaadin-progress-value));}:host([dir="rtl"]) [part="value"]{transform-origin:100% 50%;}</style><div part="bar"><div part="value"></div></div></template><script>(function(){/**
       * `<vaadin-progress-bar>` is a Web Component for progress bars.
       *
       * ```html
       * <vaadin-progress-bar min="0" max="1" value="0.5">
       * </vaadin-progress-bar>
       * ```
       *
       * ### Styling
       *
       * The following shadow DOM parts are available for styling:
       *
       * Part name | Description
       * ----------------|----------------
       * `bar` | Progress-bar's background
       * `value` | Progress-bar's foreground
       *
       * See [ThemableMixin – how to apply styles for shadow parts](https://github.com/vaadin/vaadin-themable-mixin/wiki)
       *
       * The following custom properties are available:
       *
       * Custom property | Description | Default
       * ----------------|-------------|-------------
       * `--vaadin-progress-value` | current progress value (between 0 and 1) | 0
       *
       * The following state attributes are available for styling:
       *
       * Attribute       | Description | Part name
       * ----------------|-------------|------------
       * `indeterminate` | Set to an indeterminate progress bar | :host
       *
       * @memberof Vaadin
       * @mixes Vaadin.ProgressMixin
       * @mixes Vaadin.ThemableMixin
       * @demo demo/index.html
       */class ProgressBarElement extends Vaadin.ElementMixin(Vaadin.ThemableMixin(Vaadin.ProgressMixin(Polymer.Element))){static get is(){return"vaadin-progress-bar"}static get version(){return"1.2.0"}}customElements.define(ProgressBarElement.is,ProgressBarElement);/**
       * @namespace Vaadin
       */window.Vaadin.ProgressBarElement=ProgressBarElement})();</script></dom-module><dom-module id="lumo-upload" theme-for="vaadin-upload" assetpath="../bower_components/vaadin-upload/theme/lumo/"><template><style>:host{line-height:var(--lumo-line-height-m);}:host(:not([nodrop])){overflow:hidden;border:1px dashed var(--lumo-contrast-20pct);border-radius:var(--lumo-border-radius);padding:var(--lumo-space-m);transition:background-color 0.6s, border-color 0.6s;}[part="primary-buttons"] > *{display:inline-block;white-space:nowrap;}[part="drop-label"]{display:inline-block;white-space:normal;padding:0 var(--lumo-space-s);color:var(--lumo-secondary-text-color);font-family:var(--lumo-font-family);}:host([dragover-valid]){border-color:var(--lumo-primary-color-50pct);background:var(--lumo-primary-color-10pct);transition:background-color 0.1s, border-color 0.1s;}:host([dragover-valid]) [part="drop-label"]{color:var(--lumo-primary-text-color);}[part="drop-label-icon"]{display:inline-block;}[part="drop-label-icon"]::before{content:var(--lumo-icons-upload);font-family:lumo-icons;font-size:var(--lumo-icon-size-m);line-height:1;vertical-align:-.25em;}</style></template></dom-module><dom-module id="lumo-upload-file" theme-for="vaadin-upload-file" assetpath="../bower_components/vaadin-upload/theme/lumo/"><template><style include="lumo-field-button">:host{padding:var(--lumo-space-s) 0;}:host(:not(:first-child)){border-top:1px solid var(--lumo-contrast-10pct);}[part="row"]{display:flex;align-items:baseline;justify-content:space-between;}[part="status"],
      [part="error"]{color:var(--lumo-secondary-text-color);font-size:var(--lumo-font-size-s);}[part="info"]{display:flex;align-items:baseline;flex:auto;}[part="meta"]{width:0.001px;flex:1 1 auto;}[part="name"]{white-space:nowrap;overflow:hidden;text-overflow:ellipsis;}[part="commands"]{display:flex;align-items:baseline;flex:none;}[part="done-icon"],
      [part="warning-icon"]{margin-right:var(--lumo-space-xs);}[part="done-icon"][hidden] + [part="warning-icon"][hidden]{display:block !important;visibility:hidden;}[part="done-icon"],
      [part="warning-icon"]{font-size:var(--lumo-icon-size-m);font-family:'lumo-icons';line-height:1;}[part="start-button"],
      [part="retry-button"],
      [part="clear-button"]{flex:none;margin-left:var(--lumo-space-xs);}[part="done-icon"]::before,
      [part="warning-icon"]::before,
      [part="start-button"]::before,
      [part="retry-button"]::before,
      [part="clear-button"]::before{vertical-align:-.25em;}[part="done-icon"]::before{content:var(--lumo-icons-checkmark);color:var(--lumo-primary-text-color);}[part="warning-icon"]::before{content:var(--lumo-icons-error);color:var(--lumo-error-text-color);}[part="start-button"]::before{content:var(--lumo-icons-play);}[part="retry-button"]::before{content:var(--lumo-icons-reload);}[part="clear-button"]::before{content:var(--lumo-icons-cross);}[part="error"]{color:var(--lumo-error-text-color);}[part="progress"]{width:auto;margin-left:calc(var(--lumo-icon-size-m) + var(--lumo-space-xs));margin-right:calc(var(--lumo-icon-size-m) + var(--lumo-space-xs));}[part="progress"][complete],
      [part="progress"][error]{display:none;}</style></template></dom-module><custom-style><style>@font-face{font-family:'vaadin-upload-icons';src:url("data:application/font-woff;charset=utf-8;base64,d09GRgABAAAAAAasAAsAAAAABmAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAABPUy8yAAABCAAAAGAAAABgDxIF5mNtYXAAAAFoAAAAVAAAAFQXVtKMZ2FzcAAAAbwAAAAIAAAACAAAABBnbHlmAAABxAAAAfQAAAH0bBJxYWhlYWQAAAO4AAAANgAAADYPD267aGhlYQAAA/AAAAAkAAAAJAfCA8tobXR4AAAEFAAAACgAAAAoHgAAx2xvY2EAAAQ8AAAAFgAAABYCSgHsbWF4cAAABFQAAAAgAAAAIAAOADVuYW1lAAAEdAAAAhYAAAIWmmcHf3Bvc3QAAAaMAAAAIAAAACAAAwAAAAMDtwGQAAUAAAKZAswAAACPApkCzAAAAesAMwEJAAAAAAAAAAAAAAAAAAAAARAAAAAAAAAAAAAAAAAAAAAAQAAA6QUDwP/AAEADwABAAAAAAQAAAAAAAAAAAAAAIAAAAAAAAwAAAAMAAAAcAAEAAwAAABwAAwABAAAAHAAEADgAAAAKAAgAAgACAAEAIOkF//3//wAAAAAAIOkA//3//wAB/+MXBAADAAEAAAAAAAAAAAAAAAEAAf//AA8AAQAAAAAAAAAAAAIAADc5AQAAAAABAAAAAAAAAAAAAgAANzkBAAAAAAEAAAAAAAAAAAACAAA3OQEAAAAAAgAA/8AEAAPAABkAMgAAEz4DMzIeAhczLgMjIg4CBycRIScFIRcOAyMiLgInIx4DMzI+AjcXphZGWmo6SH9kQwyADFiGrmJIhXJbIEYBAFoDWv76YBZGXGw8Rn5lRQyADFmIrWBIhHReIkYCWjJVPSIyVnVDXqN5RiVEYTxG/wBa2loyVT0iMlZ1Q16jeUYnRWE5RgAAAAABAIAAAAOAA4AAAgAAExEBgAMAA4D8gAHAAAAAAwAAAAAEAAOAAAIADgASAAAJASElIiY1NDYzMhYVFAYnETMRAgD+AAQA/gAdIyMdHSMjXYADgPyAgCMdHSMjHR0jwAEA/wAAAQANADMD5gNaAAUAACUBNwUBFwHT/jptATMBppMzAU2a4AIgdAAAAAEAOv/6A8YDhgALAAABJwkBBwkBFwkBNwEDxoz+xv7GjAFA/sCMAToBOoz+wAL6jP7AAUCM/sb+xowBQP7AjAE6AAAAAwAA/8AEAAPAAAcACwASAAABFSE1IREhEQEjNTMJAjMRIRECwP6A/sAEAP0AgIACQP7A/sDAAQABQICA/oABgP8AgAHAAUD+wP6AAYAAAAABAAAAAQAAdhiEdV8PPPUACwQAAAAAANX4FR8AAAAA1fgVHwAA/8AEAAPAAAAACAACAAAAAAAAAAEAAAPA/8AAAAQAAAAAAAQAAAEAAAAAAAAAAAAAAAAAAAAKBAAAAAAAAAAAAAAAAgAAAAQAAAAEAACABAAAAAQAAA0EAAA6BAAAAAAAAAAACgAUAB4AagB4AJwAsADSAPoAAAABAAAACgAzAAMAAAAAAAIAAAAAAAAAAAAAAAAAAAAAAAAADgCuAAEAAAAAAAEAEwAAAAEAAAAAAAIABwDMAAEAAAAAAAMAEwBaAAEAAAAAAAQAEwDhAAEAAAAAAAUACwA5AAEAAAAAAAYAEwCTAAEAAAAAAAoAGgEaAAMAAQQJAAEAJgATAAMAAQQJAAIADgDTAAMAAQQJAAMAJgBtAAMAAQQJAAQAJgD0AAMAAQQJAAUAFgBEAAMAAQQJAAYAJgCmAAMAAQQJAAoANAE0dmFhZGluLXVwbG9hZC1pY29ucwB2AGEAYQBkAGkAbgAtAHUAcABsAG8AYQBkAC0AaQBjAG8AbgBzVmVyc2lvbiAxLjAAVgBlAHIAcwBpAG8AbgAgADEALgAwdmFhZGluLXVwbG9hZC1pY29ucwB2AGEAYQBkAGkAbgAtAHUAcABsAG8AYQBkAC0AaQBjAG8AbgBzdmFhZGluLXVwbG9hZC1pY29ucwB2AGEAYQBkAGkAbgAtAHUAcABsAG8AYQBkAC0AaQBjAG8AbgBzUmVndWxhcgBSAGUAZwB1AGwAYQBydmFhZGluLXVwbG9hZC1pY29ucwB2AGEAYQBkAGkAbgAtAHUAcABsAG8AYQBkAC0AaQBjAG8AbgBzRm9udCBnZW5lcmF0ZWQgYnkgSWNvTW9vbi4ARgBvAG4AdAAgAGcAZQBuAGUAcgBhAHQAZQBkACAAYgB5ACAASQBjAG8ATQBvAG8AbgAuAAAAAwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA==") format('woff');font-weight:normal;font-style:normal;}</style></custom-style><dom-module id="vaadin-upload-file" assetpath="../bower_components/vaadin-upload/src/"><template><style>:host{display:block;}[hidden]{display:none;}</style><div part="row"><div part="info"><div part="done-icon" hidden$="[[!file.complete]]"></div><div part="warning-icon" hidden$="[[!file.error]]"></div><div part="meta"><div part="name" id="name">[[file.name]]</div><div part="status" hidden$="[[!file.status]]" id="status">[[file.status]]</div><div part="error" id="error" hidden$="[[!file.error]]">[[file.error]]</div></div></div><div part="commands"><div part="start-button" file-event="file-start" on-click="_fireFileEvent" hidden$="[[!file.held]]"></div><div part="retry-button" file-event="file-retry" on-click="_fireFileEvent" hidden$="[[!file.error]]"></div><div part="clear-button" file-event="file-abort" on-click="_fireFileEvent"></div></div></div><vaadin-progress-bar part="progress" id="progress" value$="[[_formatProgressValue(file.progress)]]" error$="[[file.error]]" indeterminate$="[[file.indeterminate]]" uploading$="[[file.uploading]]" complete$="[[file.complete]]"></vaadin-progress-bar></template><script>(function(){/**
       * `<vaadin-upload-file>` element represents a file in the file list of `<vaadin-upload>`.
       *
       * ### Styling
       *
       * The following shadow DOM parts are available for styling:
       *
       * Part name | Description
       * ---|---
       * `row` | File container
       * `info` | Container for file status icon, file name, status and error messages
       * `done-icon` | File done status icon
       * `warning-icon` | File warning status icon
       * `meta` | Container for file name, status and error messages
       * `name` | File name
       * `error` | Error message, shown when error happens
       * `status` | Status message
       * `commands` | Container for file command icons
       * `start-button` | Start file upload button
       * `retry-button` | Retry file upload button
       * `clear-button` | Clear file button
       * `progress`| Progress bar
       *
       * The following state attributes are available for styling:
       *
       * Attribute | Description | Part name
       * ---|---|---
       * `error` | An error has happened during uploading | `:host`
       * `indeterminate` | Uploading is in progress, but the progress value is unknown | `:host`
       * `uploading` | Uploading is in progress | `:host`
       * `complete` | Uploading has finished successfully | `:host`
       *
       * See [ThemableMixin – how to apply styles for shadow parts](https://github.com/vaadin/vaadin-themable-mixin/wiki)
       *
       * @memberof Vaadin
       * @mixes Vaadin.ThemableMixin
       * @demo demo/index.html
       */class UploadFileElement extends Vaadin.ThemableMixin(Polymer.Element){static get is(){return"vaadin-upload-file"}static get properties(){return{file:Object}}static get observers(){return["_fileAborted(file.abort)","_toggleHostAttribute(file.error, \"error\")","_toggleHostAttribute(file.indeterminate, \"indeterminate\")","_toggleHostAttribute(file.uploading, \"uploading\")","_toggleHostAttribute(file.complete, \"complete\")"]}_fileAborted(abort){if(abort){this._remove()}}_remove(){this.dispatchEvent(new CustomEvent("file-remove",{detail:{file:this.file},bubbles:!0,composed:!0}))}_formatProgressValue(progress){return progress/100}_fireFileEvent(e){e.preventDefault();return this.dispatchEvent(new CustomEvent(e.target.getAttribute("file-event"),{detail:{file:this.file},bubbles:!0,composed:!0}))}_toggleHostAttribute(value,attributeName){const shouldHave=!!value,has=this.hasAttribute(attributeName);if(has!==shouldHave){if(shouldHave){this.setAttribute(attributeName,"")}else{this.removeAttribute(attributeName)}}}/**
        * Fired when the retry button is pressed. It is listened by `vaadin-upload`
        * which will start a new upload process of this file.
        *
        * @event file-retry
        * @param {Object} detail
        * @param {Object} detail.file file to retry upload of
        */ /**
        * Fired when the start button is pressed. It is listened by `vaadin-upload`
        * which will start a new upload process of this file.
        *
        * @event file-start
        * @param {Object} detail
        * @param {Object} detail.file file to start upload of
        */ /**
         * Fired when abort button is pressed. It is listened by `vaadin-upload` which
         * will abort the upload in progress, but will not remove the file from the list
         * to allow the animation to hide the element to be run.
         *
         * @event file-abort
         * @param {Object} detail
         * @param {Object} detail.file file to abort upload of
         */ /**
         * Fired after the animation to hide the element has finished. It is listened
         * by `vaadin-upload` which will actually remove the file from the upload
         * file list.
         *
         * @event file-remove
         * @param {Object} detail
         * @param {Object} detail.file file to remove from the  upload of
         */}customElements.define(UploadFileElement.is,UploadFileElement);/**
       * @namespace Vaadin
       */window.Vaadin=window.Vaadin||{};Vaadin.UploadFileElement=UploadFileElement})();</script></dom-module><dom-module id="vaadin-upload" assetpath="../bower_components/vaadin-upload/src/"><template><style>:host{display:block;position:relative;}:host([hidden]){display:none !important;}[hidden]{display:none !important;}</style><div part="primary-buttons"><div id="addFiles" on-touchend="_onAddFilesTouchEnd" on-click="_onAddFilesClick"><slot name="add-button"><vaadin-button part="upload-button" id="addButton" disabled="[[maxFilesReached]]">[[_i18nPlural(maxFiles, i18n.addFiles, i18n.addFiles.*)]]</vaadin-button></slot></div><div part="drop-label" hidden$="[[nodrop]]" id="dropLabelContainer"><slot name="drop-label-icon"><div part="drop-label-icon"></div></slot><slot name="drop-label" id="dropLabel">[[_i18nPlural(maxFiles, i18n.dropFiles, i18n.dropFiles.*)]]</slot></div></div><slot name="file-list"><div id="fileList" part="file-list"><template is="dom-repeat" items="[[files]]" as="file"><vaadin-upload-file file="[[file]]"></vaadin-upload-file></template></div></slot><slot></slot><input type="file" id="fileInput" on-change="_onFileInputChange" hidden="" accept$="{{accept}}" multiple$="[[_isMultiple(maxFiles)]]" capture$="[[capture]]"></template><script>(function(){/**
       * `<vaadin-upload>` is a Web Component for uploading multiple files with drag and drop support.
       *
       * Example:
       *
       * ```
       * <vaadin-upload></vaadin-upload>
       * ```
       *
       * ### Styling
       *
       * The following shadow DOM parts are available for styling:
       *
       * Part name | Description
       * ---|---
       * `primary-buttons` | Upload container
       * `upload-button` | Upload button
       * `drop-label` | Label for drop indicator
       * `drop-label-icon` | Icon for drop indicator
       * `file-list` | File list container
       *
       * The following state attributes are available for styling:
       *
       * Attribute | Description | Part name
       * ---|---|---
       * `nodrop` | Set when drag and drop is disabled (e. g., on touch devices) | `:host`
       * `dragover` | A file is being dragged over the element | `:host`
       * `dragover-valid` | A dragged file is valid with `maxFiles` and `accept` criteria | `:host`
       *
       * See [ThemableMixin – how to apply styles for shadow parts](https://github.com/vaadin/vaadin-themable-mixin/wiki)
       *
       * @memberof Vaadin
       * @mixes Vaadin.ThemableMixin
       * @demo demo/index.html
       */class UploadElement extends Vaadin.ElementMixin(Vaadin.ThemableMixin(Polymer.Element)){static get is(){return"vaadin-upload"}static get version(){return"4.3.0"}static get properties(){return{/**
             * Define whether the element supports dropping files on it for uploading.
             * By default it's enabled in desktop and disabled in touch devices
             * because mobile devices do not support drag events in general. Setting
             * it false means that drop is enabled even in touch-devices, and true
             * disables drop in all devices.
             *
             * @default true in touch-devices, false otherwise.
             */nodrop:{type:Boolean,reflectToAttribute:!0,value:function(){try{return!!document.createEvent("TouchEvent")}catch(e){return!1}}},/**
             * The server URL. The default value is an empty string, which means that
             * _window.location_ will be used.
             */target:{type:String,value:""},/**
             * HTTP Method used to send the files. Only POST and PUT are allowed.
             */method:{type:String,value:"POST"},/**
             * Key-Value map to send to the server. If you set this property as an
             * attribute, use a valid JSON string, for example:
             * ```
             * <vaadin-upload headers='{"X-Foo": "Bar"}'></vaadin-upload>
             * ```
             */headers:{type:Object,value:{}},/**
             * Max time in milliseconds for the entire upload process, if exceeded the
             * request will be aborted. Zero means that there is no timeout.
             *
             */timeout:{type:Number,value:0},_dragover:{type:Boolean,value:!1,observer:"_dragoverChanged"},/**
             * The array of files being processed, or already uploaded.
             *
             * Each element is a [`File`](https://developer.mozilla.org/en-US/docs/Web/API/File)
             * object with a number of extra properties  to track the upload process:
             * - `uploadTarget`: The target URL used to upload this file.
             * - `elapsed`: Elapsed time since the upload started.
             * - `elapsedStr`: Human-readable elapsed time.
             * - `remaining`: Number of seconds remaining for the upload to finish.
             * - `remainingStr`: Human-readable remaining time for the upload to finish.
             * - `progress`: Percentage of the file already uploaded.
             * - `speed`: Upload speed in kB/s.
             * - `size`: File size in bytes.
             * - `totalStr`: Human-readable total size of the file.
             * - `loaded`: Bytes transferred so far.
             * - `loadedStr`: Human-readable uploaded size at the moment.
             * - `status`: Status of the upload process.
             * - `error`: Error message in case the upload failed.
             * - `abort`: True if the file was canceled by the user.
             * - `complete`: True when the file was transferred to the server.
             * - `uploading`: True while transferring data to the server.
             */files:{type:Array,notify:!0,value:function(){return[]}},/**
             * Limit of files to upload, by default it is unlimited. If the value is
             * set to one, native file browser will prevent selecting multiple files.
             */maxFiles:{type:Number,value:1/0},/**
             * Specifies if the maximum number of files have been uploaded
             */maxFilesReached:{type:Boolean,value:!1,notify:!0,readOnly:!0,computed:"_maxFilesAdded(maxFiles, files.length)"},/**
             * Specifies the types of files that the server accepts.
             * Syntax: a comma-separated list of MIME type patterns (wildcards are
             * allowed) or file extensions.
             * Notice that MIME types are widely supported, while file extensions
             * are only implemented in certain browsers, so avoid using it.
             * Example: accept="video/*,image/tiff" or accept=".pdf,audio/mp3"
             */accept:{type:String,value:""},/**
             * Specifies the maximum file size in bytes allowed to upload.
             * Notice that it is a client-side constraint, which will be checked before
             * sending the request. Obviously you need to do the same validation in
             * the server-side and be sure that they are aligned.
             */maxFileSize:{type:Number,value:1/0},/**
             * Specifies if the dragover is validated with maxFiles and
             * accept properties.
             */_dragoverValid:{type:Boolean,value:!1,observer:"_dragoverValidChanged"},/**
             * Specifies the 'name' property at Content-Disposition
             */formDataName:{type:String,value:"file"},/**
             * Prevents upload(s) from immediately uploading upon adding file(s).
             * When set, you must manually trigger uploads using the `uploadFiles` method
             */noAuto:{type:Boolean,value:!1},/**
             * Set the withCredentials flag on the request.
             */withCredentials:{type:Boolean,value:!1},/**
             * Pass-through to input's capture attribute. Allows user to trigger device inputs
             * such as camera or microphone immediately.
             */capture:String,/**
             * The object used to localize this component.
             * For changing the default localization, change the entire
             * _i18n_ object or just the property you want to modify.
             *
             * The object has the following JSON structure and default values:

            {
              dropFiles: {
              one: 'Drop file here
              many: 'Drop files here
              },
              addFiles: {
              one: 'Select File...',
              many: 'Upload Files...'
              },
              cancel: 'Cancel',
              error: {
              tooManyFiles: 'Too Many Files.',
              fileIsTooBig: 'File is Too Big.',
              incorrectFileType: 'Incorrect File Type.'
              },
              uploading: {
              status: {
                connecting: 'Connecting...',
                stalled: 'Stalled.',
                processing: 'Processing File...',
                held: 'Queued'
              },
              remainingTime: {
                prefix: 'remaining time: ',
                unknown: 'unknown remaining time'
              },
              error: {
                serverUnavailable: 'Server Unavailable',
                unexpectedServerError: 'Unexpected Server Error',
                forbidden: 'Forbidden'
              }
              },
              units: {
              size: ['B', 'kB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB']
              },
              formatSize: function(bytes) {
              // returns the size followed by the best suitable unit
              },
              formatTime: function(seconds, [secs, mins, hours]) {
              // returns a 'HH:MM:SS' string
              }
            }

            *
            * @default {English}
            */i18n:{type:Object,value:function(){return{dropFiles:{one:"Drop file here",many:"Drop files here"},addFiles:{one:"Upload File...",many:"Upload Files..."},cancel:"Cancel",error:{tooManyFiles:"Too Many Files.",fileIsTooBig:"File is Too Big.",incorrectFileType:"Incorrect File Type."},uploading:{status:{connecting:"Connecting...",stalled:"Stalled.",processing:"Processing File...",held:"Queued"},remainingTime:{prefix:"remaining time: ",unknown:"unknown remaining time"},error:{serverUnavailable:"Server Unavailable",unexpectedServerError:"Unexpected Server Error",forbidden:"Forbidden"}},units:{size:["B","kB","MB","GB","TB","PB","EB","ZB","YB"]}}}}}}ready(){super.ready();this.addEventListener("dragover",this._onDragover.bind(this));this.addEventListener("dragleave",this._onDragleave.bind(this));this.addEventListener("drop",this._onDrop.bind(this));this.addEventListener("file-retry",this._onFileRetry.bind(this));this.addEventListener("file-abort",this._onFileAbort.bind(this));this.addEventListener("file-remove",this._onFileRemove.bind(this));this.addEventListener("file-start",this._onFileStart.bind(this))}_formatSize(bytes){if("function"===typeof this.i18n.formatSize){return this.i18n.formatSize(bytes)}// https://wiki.ubuntu.com/UnitsPolicy
const base=this.i18n.units.sizeBase||1e3,unit=~~(Math.log(bytes)/Math.log(base)),dec=Math.max(0,Math.min(3,unit-1)),size=parseFloat((bytes/Math.pow(base,unit)).toFixed(dec));return size+" "+this.i18n.units.size[unit]}_splitTimeByUnits(time){const unitSizes=[60,60,24,1/0],timeValues=[0];for(var i=0;i<unitSizes.length&&0<time;i++){timeValues[i]=time%unitSizes[i];time=Math.floor(time/unitSizes[i])}return timeValues}_formatTime(seconds,split){if("function"===typeof this.i18n.formatTime){return this.i18n.formatTime(seconds,split)}// Fill HH:MM:SS with leading zeros
while(3>split.length){split.push(0)}return split.reverse().map(number=>{return(10>number?"0":"")+number}).join(":")}_formatFileProgress(file){return file.totalStr+": "+file.progress+"% ("+(0<file.loaded?this.i18n.uploading.remainingTime.prefix+file.remainingStr:this.i18n.uploading.remainingTime.unknown)+")"}_maxFilesAdded(maxFiles,numFiles){return 0<=maxFiles&&numFiles>=maxFiles}_onDragover(event){event.preventDefault();if(!this.nodrop&&!this._dragover){this._dragoverValid=!this.maxFilesReached;this._dragover=!0}event.dataTransfer.dropEffect=!this._dragoverValid||this.nodrop?"none":"copy"}_onDragleave(event){event.preventDefault();if(this._dragover&&!this.nodrop){this._dragover=this._dragoverValid=!1}}_onDrop(event){if(!this.nodrop){event.preventDefault();this._dragover=this._dragoverValid=!1;this._addFiles(event.dataTransfer.files)}}// Override for tests
_createXhr(){return new XMLHttpRequest}_configureXhr(xhr){if("string"==typeof this.headers){try{this.headers=JSON.parse(this.headers)}catch(e){this.headers=void 0}}for(var key in this.headers){xhr.setRequestHeader(key,this.headers[key])}if(this.timeout){xhr.timeout=this.timeout}xhr.withCredentials=this.withCredentials}_setStatus(file,total,loaded,elapsed){file.elapsed=elapsed;file.elapsedStr=this._formatTime(file.elapsed,this._splitTimeByUnits(file.elapsed));file.remaining=Math.ceil(elapsed*(total/loaded-1));file.remainingStr=this._formatTime(file.remaining,this._splitTimeByUnits(file.remaining));file.speed=~~(total/elapsed/1024);file.totalStr=this._formatSize(total);file.loadedStr=this._formatSize(loaded);file.status=this._formatFileProgress(file)}/**
         * Triggers the upload of any files that are not completed
         *
         * @param {Array} [files] - Files being uploaded. Defaults to all outstanding files
         */uploadFiles(files){if(files&&!Array.isArray(files)){files=[files]}files=files||this.files;files=files.filter(file=>!file.complete);Array.prototype.forEach.call(files,this._uploadFile.bind(this))}_uploadFile(file){if(file.uploading){return}const ini=Date.now(),xhr=file.xhr=this._createXhr(file);let stalledId,last;// onprogress is called always after onreadystatechange
xhr.upload.onprogress=e=>{clearTimeout(stalledId);last=Date.now();const elapsed=(last-ini)/1e3,loaded=e.loaded,total=e.total,progress=~~(100*(loaded/total));file.loaded=loaded;file.progress=progress;file.indeterminate=0>=loaded||loaded>=total;if(file.error){file.indeterminate=file.status=void 0}else if(!file.abort){if(100>progress){this._setStatus(file,total,loaded,elapsed);stalledId=setTimeout(()=>{file.status=this.i18n.uploading.status.stalled;this._notifyFileChanges(file)},2e3)}else{file.loadedStr=file.totalStr;file.status=this.i18n.uploading.status.processing;file.uploading=!1}}this._notifyFileChanges(file);this.dispatchEvent(new CustomEvent("upload-progress",{detail:{file,xhr}}))};// More reliable than xhr.onload
xhr.onreadystatechange=()=>{if(4==xhr.readyState){clearTimeout(stalledId);file.indeterminate=file.uploading=!1;if(file.abort){this._notifyFileChanges(file);return}file.status="";// Custom listener can modify the default behavior either
// preventing default, changing the xhr, or setting the file error
const evt=this.dispatchEvent(new CustomEvent("upload-response",{detail:{file,xhr},cancelable:!0}));if(!evt){return}if(0===xhr.status){file.error=this.i18n.uploading.error.serverUnavailable}else if(500<=xhr.status){file.error=this.i18n.uploading.error.unexpectedServerError}else if(400<=xhr.status){file.error=this.i18n.uploading.error.forbidden}file.complete=!file.error;this.dispatchEvent(new CustomEvent(`upload-${file.error?"error":"success"}`,{detail:{file,xhr}}));this._notifyFileChanges(file)}};const formData=new FormData;file.uploadTarget=file.uploadTarget||this.target||"";file.formDataName=this.formDataName;const evt=this.dispatchEvent(new CustomEvent("upload-before",{detail:{file,xhr},cancelable:!0}));if(!evt){return}formData.append(file.formDataName,file,file.name);xhr.open(this.method,file.uploadTarget,!0);this._configureXhr(xhr);file.status=this.i18n.uploading.status.connecting;file.uploading=file.indeterminate=!0;file.complete=file.abort=file.error=file.held=!1;xhr.upload.onloadstart=()=>{this.dispatchEvent(new CustomEvent("upload-start",{detail:{file,xhr}}));this._notifyFileChanges(file)};// Custom listener could modify the xhr just before sending it
// preventing default
const uploadEvt=this.dispatchEvent(new CustomEvent("upload-request",{detail:{file,xhr,formData},cancelable:!0}));if(uploadEvt){xhr.send(formData)}}_retryFileUpload(file){const evt=this.dispatchEvent(new CustomEvent("upload-retry",{detail:{file,xhr:file.xhr},cancelable:!0}));if(evt){this._uploadFile(file)}}_abortFileUpload(file){const evt=this.dispatchEvent(new CustomEvent("upload-abort",{detail:{file,xhr:file.xhr},cancelable:!0}));if(evt){file.abort=!0;if(file.xhr){file.xhr.abort()}this._notifyFileChanges(file)}}_notifyFileChanges(file){var p="files."+this.files.indexOf(file)+".";for(var i in file){if(file.hasOwnProperty(i)){this.notifyPath(p+i,file[i])}}}_addFiles(files){Array.prototype.forEach.call(files,this._addFile.bind(this))}/**
         * Add the file for uploading. Called internally for each file after picking files from dialog or dropping files.
         *
         * @param {File} file File being added
         */_addFile(file){if(this.maxFilesReached){this.dispatchEvent(new CustomEvent("file-reject",{detail:{file,error:this.i18n.error.tooManyFiles}}));return}if(0<=this.maxFileSize&&file.size>this.maxFileSize){this.dispatchEvent(new CustomEvent("file-reject",{detail:{file,error:this.i18n.error.fileIsTooBig}}));return}const fileExt=file.name.match(/\.[^\.]*$|$/)[0],re=new RegExp("^("+this.accept.replace(/[, ]+/g,"|").replace(/\/\*/g,"/.*")+")$","i");if(this.accept&&!(re.test(file.type)||re.test(fileExt))){this.dispatchEvent(new CustomEvent("file-reject",{detail:{file,error:this.i18n.error.incorrectFileType}}));return}file.loaded=0;file.held=!0;file.status=this.i18n.uploading.status.held;this.unshift("files",file);if(!this.noAuto){this._uploadFile(file)}}/**
         * Remove file from upload list. Called internally if file upload was canceled.
         * @param {File} file File to remove
         */_removeFile(file){if(-1<this.files.indexOf(file)){this.splice("files",this.files.indexOf(file),1)}}_onAddFilesTouchEnd(e){// Cancel the event to avoid the following click event
e.preventDefault();// FIXME(platosha): workaround for Polymer Gestures mouseCanceller
// cancelling the following synthetic click. See also:
// https://github.com/Polymer/polymer/issues/5289
this.__resetMouseCanceller();this._onAddFilesClick()}__resetMouseCanceller(){Polymer.Gestures.resetMouseCanceller()}_onAddFilesClick(){if(this.maxFilesReached){return}this.$.fileInput.value="";this.$.fileInput.click()}_onFileInputChange(event){this._addFiles(event.target.files)}_onFileStart(event){this._uploadFile(event.detail.file)}_onFileRetry(event){this._retryFileUpload(event.detail.file)}_onFileAbort(event){this._abortFileUpload(event.detail.file)}_onFileRemove(event){this._removeFile(event.detail.file)}_dragoverChanged(dragover){dragover?this.setAttribute("dragover",dragover):this.removeAttribute("dragover")}_dragoverValidChanged(dragoverValid){dragoverValid?this.setAttribute("dragover-valid",dragoverValid):this.removeAttribute("dragover-valid")}_i18nPlural(value,plural){return 1==value?plural.one:plural.many}_isMultiple(maxFiles){return 1!=maxFiles}/**
        * Fired when a file cannot be added to the queue due to a constrain:
        *  file-size, file-type or maxFiles
        *
        * @event file-reject
        * @param {Object} detail
        * @param {Object} detail.file the file added
        * @param {string} detail.error the cause
        */ /**
        * Fired before the XHR is opened. Could be used for changing the request
        * URL. If the default is prevented, then XHR would not be opened.
        *
        * @event upload-before
        * @param {Object} detail
        * @param {Object} detail.xhr the xhr
        * @param {Object} detail.file the file being uploaded
        * @param {Object} detail.file.uploadTarget the upload request URL, initialized with the value of vaadin-upload `target` property
        */ /**
        * Fired when the XHR has been opened but not sent yet. Useful for appending
        * data keys to the FormData object, for changing some parameters like
        * headers, etc. If the event is defaultPrevented, `vaadin-upload` will not
        * send the request allowing the user to do something on his own.
        *
        * @event upload-request
        * @param {Object} detail
        * @param {Object} detail.xhr the xhr
        * @param {Object} detail.file the file being uploaded
        * @param {Object} detail.formData the FormData object
        */ /**
        * Fired when the XHR is sent.
        *
        * @event upload-start
        * @param {Object} detail
        * @param {Object} detail.xhr the xhr
        * @param {Object} detail.file the file being uploaded
        */ /**
        * Fired as many times as the progress is updated.
        *
        * @event upload-progress
        * @param {Object} detail
        * @param {Object} detail.xhr the xhr
        * @param {Object} detail.file the file being uploaded with loaded info
        */ /**
        * Fired when we have the actual server response, and before the component
        * analyses it. It's useful for developers to make the upload fail depending
        * on the server response. If the event is defaultPrevented the vaadin-upload
        * will return allowing the user to do something on his own like retry the
        * upload, etc. since he has full access to the `xhr` and `file` objects.
        * Otherwise, if the event is not prevented default `vaadin-upload` continues
        * with the normal workflow checking the `xhr.status` and `file.error`
        * which also might be modified by the user to force a customized response.
        *
        * @event upload-response
        * @param {Object} detail
        * @param {Object} detail.xhr the xhr
        * @param {Object} detail.file the file being uploaded
        */ /**
        * Fired in case the upload process succeed.
        *
        * @event upload-success
        * @param {Object} detail
        * @param {Object} detail.xhr the xhr
        * @param {Object} detail.file the file being uploaded with loaded info
        */ /**
        * Fired in case the upload process failed.
        *
        * @event upload-error
        * @param {Object} detail
        * @param {Object} detail.xhr the xhr
        * @param {Object} detail.file the file being uploaded
        */ /**
        * Fired when retry upload is requested. If the default is prevented, then
        * retry would not be performed.
        *
        * @event upload-retry
        * @param {Object} detail
        * @param {Object} detail.xhr the previous upload xhr
        * @param {Object} detail.file the file being uploaded
        */ /**
        * Fired when retry abort is requested. If the default is prevented, then the
        * file upload would not be aborted.
        *
        * @event upload-abort
        * @param {Object} detail
        * @param {Object} detail.xhr the xhr
        * @param {Object} detail.file the file being uploaded
        */}customElements.define(UploadElement.is,UploadElement);/**
       * @namespace Vaadin
       */window.Vaadin.UploadElement=UploadElement})();</script></dom-module><dom-module id="expense-editor"><template><style>.wrapper{display:flex;margin-top:var(--lumo-space-s);overflow:auto;flex:1 1 auto;}h2{margin:0;}#form{min-width:300px;display:flex;flex-direction:column;flex-shrink:0;}#upload{margin-left:var(--lumo-space-l);flex-shrink:0;overflow:auto;}.buttons{margin-top:var(--lumo-space-xs);display:flex;}.buttons .space{flex:1;}.buttons vaadin-button{margin-right:var(--lumo-space-m);}vaadin-text-area{min-height:125px;}img{max-width:350px;}@media (max-width: 900px){[part~="overlay"]{align-self:stretch;border-radius:0;}#upload{margin:10px 0;}.wrapper{flex-direction:column;}.receipt-wrapper img{max-width:100%;}}</style><vaadin-dialog id="dialog" opened="[[_isDialogOpened(_expense)]]"><template><div class="wrapper"><div id="form"><h2>[[_getCaption(_expense)]]</h2><iron-a11y-keys keys="enter" on-keys-pressed="_save"></iron-a11y-keys><vaadin-combo-box name="merchant" items="[[_merchants]]" value="{{_expense.merchant}}" label="Merchant" allow-custom-value="" required="" readonly$="[[!_isNew(_expense)]]"></vaadin-combo-box><vaadin-text-field name="total" value="{{_expense.total}}" label="Total" pattern="[0-9]+[.]?[0-9]*" required="" readonly$="[[!_isNew(_expense)]]"><div slot="prefix">$</div></vaadin-text-field><vaadin-date-picker name="date" label="Date" value="{{_expense.date}}" required="" readonly$="[[!_isNew(_expense)]]"></vaadin-date-picker><vaadin-text-area name="comment" label="Comment" value="{{_expense.comment}}" on-keydown="_onCommentKeydown"></vaadin-text-area></div><vaadin-upload id="upload" accept="image/*" max-files="1" on-upload-before="_handleUpload"><div class="file-list"><div class="receipt-wrapper"><img src$="[[_receiptSrc(_expense.receipt)]]" alt="Receipt" hidden$="[[!_expense.receipt]]"></div></div></vaadin-upload></div><div class="buttons"><vaadin-button on-click="_save" theme="primary" class="save-button">Save</vaadin-button><vaadin-button on-click="close" class="cancel-button">Cancel</vaadin-button><div class="space"></div><vaadin-button on-click="_delete" id="delete" theme="tertiary error" class="delete-button" hidden="[[!_showDelete(_expense)]]">Delete</vaadin-button></div><span>[[_errorText]]</span></template></vaadin-dialog></template><script>(function(){/**
       * @memberof ExpenseManager
       */class ExpenseEditorElement extends ExpenseManager.ReduxMixin(Polymer.Element){static get is(){return"expense-editor"}static get properties(){return{/**
             * The list of available merchants.
             * @type {Array<string>}
             */_merchants:{type:Array,statePath:ExpenseManager.select.merchants},/**
             * The originally selected expense.
             * @type {Object}
             */_sourceExpense:{type:Object,statePath:"expenses.selectedExpense",observer:"_expenseChanged"},/**
             * The expense used for modifications.
             * @type {Object}
             */_expense:Object,/**
             * The text to show in case if some fields are invalid.
             */_errorText:String}}_onCommentKeydown(e){if(13===e.keyCode){// Prevent enter key in the text area from saving the form
e.stopPropagation()}}_receiptSrc(url){return /^(https?|data):/i.test(url)?url:this.rootPath+url}/**
         * @param {Object|null} srcExpense the selected expense, if any.
         */_expenseChanged(srcExpense){// assign expense before dialog is opened
if(srcExpense){this._expense=Object.assign({},srcExpense)}this.$.dialog.opened=!!srcExpense;if(srcExpense){// reset upload after dialog is opened
const upload=this._getDialogChild("vaadin-upload");upload.set("i18n.dropFiles.one","Drop receipt here...");upload.set("i18n.addFiles.one","Select receipt");upload.files=[]}}/**
         * Specifies whether the dialog is opened.
         *
         * @param {{id:string, status:string}=} expense optional. The expense to edit.
         * @return {boolean} true if dialog is opened.
         */_isDialogOpened(expense){return"object"===typeof expense&&null!==expense}/**
         * Checks the form for validity.
         *
         * @return {boolean} true if all the fields are valid.
         */_isValid(){return this._getFormFields().every(el=>el.validate())}/**
         * Returns the result of `querySelector` for the dialog content.
         *
         * @param {string} selector a CSS selector to use
         * @return {HTMLElement} a list of form elements.
         */_getDialogChild(selector){return this.$.dialog.$.overlay.content&&this.$.dialog.$.overlay.content.querySelector(selector)}/**
         * Collects the list of the form fields.
         *
         * @return {Array<HTMLElement>} a list of form elements.
         */_getFormFields(){return Array.from(this._getDialogChild("#form").children).filter(el=>"function"===typeof el.validate)}/**
         * Specifies whether the "delete" button should be displayed or not.
         *
         * @param {{id:string}=} expense optional. The expense to edit.
         * @return {boolean} true if expense has been changed.
         */_showDelete(expense){return expense&&!expense.id}/**
         * Specifies whether a expense is new
         *
         * @param {{id:string, status:string}=} expense optional. The expense to edit.
         * @return {boolean} true if expense has been reimbursed or is in process
         */_isNew(expense){return!expense||!expense.id||"new"===expense.status}/**
         * Closes the editor.
         */close(){this.dispatch("cancelEdit")}/**
         * Returns the caption for the submit button based on the editing expense state.
         *
         * @param {{id:string}} expense optional. The expense to edit.
         * @return {string} caption for the editor.
         */_getCaption(expense){if(expense&&expense.id){return"Edit Expense"}else{return"Add Expense"}}/**
         * Reads a file and return a DataURL.
         * If it's an image it converts and resizes using a canvas.
         *
         * @param {File} file uploaded file.
         * @param {function} callback a callback to invoke on end.
         * @param {string} mimeType a file type matching image.
         * @param {number} maxWidth a max width used to resize image.
         * @param {number} maxHeight a max width used to resize image.
         */_resizeImage(file,callback,mimeType,maxWidth,maxHeight){const img=document.createElement("img"),reader=new FileReader;reader.onload=()=>{if(!/^image/.test(file.type)){callback(reader.result)}else if(file.type===mimeType&&(!maxWidth||!maxWidth)){callback(reader.result)}else{img.addEventListener("load",()=>{const canvas=document.createElement("canvas"),ctx=canvas.getContext("2d");if(img.width>img.height&&img.width>maxWidth){canvas.width=maxWidth;canvas.height=img.height*maxWidth/img.width}else if(img.height>img.width&&img.height>maxHeight){canvas.height=maxHeight;canvas.width=img.width*maxHeight/img.height}else{canvas.height=img.height;canvas.width=img.width}ctx.drawImage(img,0,0,canvas.width,canvas.height);callback(canvas.toDataURL())});img.src=reader.result}};reader.readAsDataURL(file)}/**
         * Processes the file submitted by user and cancels the actual upload.
         *
         * @param {CustomEvent} e upload event.
         */_handleUpload(e){e.preventDefault();const file=e.detail.file;this._resizeImage(file,data=>{this.set("_expense.receipt",data)},"image/jpeg",300,300);this._getDialogChild("vaadin-upload").files=[]}/**
         * Saves the expense, if all fields are valid, and sets the error text otherwise.
         */_save(){this._errorText="";if(this._isValid()){this._expense.total=parseFloat(this._expense.total);this.dispatch("saveExpense",this._expense)}else{this.$.dialog.scrollTop=0;this._errorText="Please fill all required fields"}}/**
         * Deletes the expense.
         */_delete(){this.dispatch("deleteExpense",this._expense)}}customElements.define(ExpenseEditorElement.is,ExpenseEditorElement);/**
       * @namespace ExpenseManager
       */window.ExpenseManager=window.ExpenseManager||{};ExpenseManager.ExpenseEditorElement=ExpenseEditorElement})();</script></dom-module><dom-module id="info-dialog"><template><style>a{color:var(--lumo-primary-text-color);}</style><vaadin-dialog id="dialog" no-close-on-esc="" no-close-on-outside-click="" opened="[[open]]"><template><h2>Welcome to Expense Manager</h2><p>This is a sample Progressive Web App.</p><p>Try adding it to your home screen and using it offline.</p><p>This demo is built using <a tabindex="-1" href="https://www.polymer-project.org" target="_blank" rel="noopener">Polymer</a> and <a tabindex="-1" href="https://vaadin.com/components" target="_blank" rel="noopener">Vaadin components</a>.<br>You can find the source code and fork the project on <a tabindex="-1" href="https://github.com/vaadin/expense-manager-demo" rel="noopener">GitHub</a>.</p><div class="buttons"><vaadin-button theme="primary" on-click="_close">Got it!</vaadin-button></div></template></vaadin-dialog></template><script>(function(){/**
       * @memberof ExpenseManager
       */class InfoDialogElement extends ExpenseManager.ReduxMixin(Polymer.Element){static get is(){return"info-dialog"}static get properties(){return{/**
             * True if the dialog is opened.
             */open:{type:Boolean,statePath:"uiState.infoDialogVisible"}}}/**
         * Closes the dialog.
         */_close(){this.dispatch("hideInfoDialog")}}customElements.define(InfoDialogElement.is,InfoDialogElement);/**
       * @namespace ExpenseManager
       */window.ExpenseManager=window.ExpenseManager||{};ExpenseManager.InfoDialogElement=InfoDialogElement})();</script></dom-module><script>window.ExpenseManager=window.ExpenseManager||{};/**
   * @polymerMixin
   * @memberof ExpenseManager
   * @param {HTMLElement} subclass
   * @return {HTMLElement}
   */ExpenseManager.ResponsiveMixin=subclass=>class ResponsiveMixin extends subclass{static get properties(){return{/**
         * Whether the screen matches the tablet breakpoint.
         */tablet:{type:Boolean,reflectToAttribute:!0},/**
         * Whether the screen matches the phone breakpoint.
         */phone:{type:Boolean,reflectToAttribute:!0}}}};</script><dom-module id="shared-styles"><template><style>.section-title{min-height:var(--lumo-size-s);margin:var(--lumo-space-s) 0 var(--lumo-space-m);font-weight:400;font-size:var(--lumo-font-size-xs);line-height:var(--lumo-line-height-m);border-bottom:1px solid var(--lumo-shade-20pct);color:var(--lumo-secondary-text-color);}</style></template></dom-module><dom-module id="dialog-styles" theme-for="vaadin-dialog-overlay"><template><style include="lumo-typography">[part="overlay"]{display:flex;}[part="content"]{display:flex;flex-direction:column;}@media (max-width: 600px), (max-height: 600px){:host{top:0;left:0;right:0;bottom:0;padding:0;}:host [part="overlay"]{flex:1;width:100%;border-radius:0 !important;}}</style></template></dom-module><dom-module id="history-panel"><template><style include="shared-styles lumo-typography lumo-color">:host{display:block;box-sizing:border-box;background-color:var(--lumo-base-color);background-image:linear-gradient(var(--lumo-shade-5pct) 0%, var(--lumo-shade-5pct) 100%);padding:var(--lumo-space-wide-l);width:300px;color:var(--lumo-body-text-color);}:host([phone]){display:none;}:host([tablet]){width:auto;}.container{display:flex;flex-direction:column;}.total{font-weight:500;font-size:var(--lumo-font-size-l);line-height:1.4;}.total[hidden]{display:none;}.total .sum{display:block;text-align:center;padding:40px 0;font-size:32px;}</style><div class="container"><div class="total" hidden="[[tablet]]"><div class="section-title">To be reimbursed</div><span class="sum">$[[totalOwed]]</span></div></div></template><script>(function(){/**
       * @memberof ExpenseManager
       * @mixes ExpenseManager.ResponsiveMixin
       */class HistoryPanelElement extends ExpenseManager.ReduxMixin(ExpenseManager.ResponsiveMixin(Polymer.Element)){static get is(){return"history-panel"}static get properties(){return{/**
             * The total owed amount.
             */totalOwed:{type:Number,statePath:ExpenseManager.select.total}}}}window.customElements.define(HistoryPanelElement.is,HistoryPanelElement);/**
       * @namespace ExpenseManager
       */window.ExpenseManager=window.ExpenseManager||{};ExpenseManager.HistoryPanelElement=HistoryPanelElement})();</script></dom-module><script>(function(){/**
   * @constructor
   * @param {{
   *   type: (string|null|undefined),
   *   key: (string|null|undefined),
   *   value: *,
   * }=} options
   */Polymer.IronMeta=function(options){Polymer.IronMeta[" "](options);this.type=options&&options.type||"default";this.key=options&&options.key;if(options&&"value"in options){this.value=options.value}};// This function is used to convince Closure not to remove constructor calls
// for instances that are not held anywhere. For example, when
// `new Polymer.IronMeta({...})` is used only for the side effect of adding
// a value.
Polymer.IronMeta[" "]=function(){};Polymer.IronMeta.types={};Polymer.IronMeta.prototype={get value(){var type=this.type,key=this.key;if(type&&key){return Polymer.IronMeta.types[type]&&Polymer.IronMeta.types[type][key]}},set value(value){var type=this.type,key=this.key;if(type&&key){type=Polymer.IronMeta.types[type]=Polymer.IronMeta.types[type]||{};if(null==value){delete type[key]}else{type[key]=value}}},get list(){var type=this.type;if(type){var items=Polymer.IronMeta.types[this.type];if(!items){return[]}return Object.keys(items).map(function(key){return metaDatas[this.type][key]},this)}},byKey:function(key){this.key=key;return this.value}};var metaDatas=Polymer.IronMeta.types;Polymer({is:"iron-meta",properties:{/**
       * The type of meta-data.  All meta-data of the same type is stored
       * together.
       * @type {string}
       */type:{type:String,value:"default"},/**
       * The key used to store `value` under the `type` namespace.
       * @type {?string}
       */key:{type:String},/**
       * The meta-data to store or retrieve.
       * @type {*}
       */value:{type:String,notify:!0},/**
       * If true, `value` is set to the iron-meta instance itself.
       */self:{type:Boolean,observer:"_selfChanged"},__meta:{type:Boolean,computed:"__computeMeta(type, key, value)"}},hostAttributes:{hidden:!0},__computeMeta:function(type,key,value){var meta=new Polymer.IronMeta({type:type,key:key});if(value!==void 0&&value!==meta.value){meta.value=value}else if(this.value!==meta.value){this.value=meta.value}return meta},get list(){return this.__meta&&this.__meta.list},_selfChanged:function(self){if(self){this.value=this}},/**
     * Retrieves meta data value by key.
     *
     * @method byKey
     * @param {string} key The key of the meta-data to be returned.
     * @return {*}
     */byKey:function(key){return new Polymer.IronMeta({type:this.type,key:key}).value}})})();</script><dom-module id="iron-icon" assetpath="../bower_components/iron-icon/"><template><style>:host{@apply --layout-inline;@apply --layout-center-center;position:relative;vertical-align:middle;fill:var(--iron-icon-fill-color, currentcolor);stroke:var(--iron-icon-stroke-color, none);width:var(--iron-icon-width, 24px);height:var(--iron-icon-height, 24px);@apply --iron-icon;}:host([hidden]){display:none;}</style></template><script>Polymer({is:"iron-icon",properties:{/**
         * The name of the icon to use. The name should be of the form:
         * `iconset_name:icon_name`.
         */icon:{type:String},/**
         * The name of the theme to used, if one is specified by the
         * iconset.
         */theme:{type:String},/**
         * If using iron-icon without an iconset, you can set the src to be
         * the URL of an individual icon image file. Note that this will take
         * precedence over a given icon attribute.
         */src:{type:String},/**
         * @type {!Polymer.IronMeta}
         */_meta:{value:Polymer.Base.create("iron-meta",{type:"iconset"})}},observers:["_updateIcon(_meta, isAttached)","_updateIcon(theme, isAttached)","_srcChanged(src, isAttached)","_iconChanged(icon, isAttached)"],_DEFAULT_ICONSET:"icons",_iconChanged:function(icon){var parts=(icon||"").split(":");this._iconName=parts.pop();this._iconsetName=parts.pop()||this._DEFAULT_ICONSET;this._updateIcon()},_srcChanged:function(src){this._updateIcon()},_usesIconset:function(){return this.icon||!this.src},/** @suppress {visibility} */_updateIcon:function(){if(this._usesIconset()){if(this._img&&this._img.parentNode){Polymer.dom(this.root).removeChild(this._img)}if(""===this._iconName){if(this._iconset){this._iconset.removeIcon(this)}}else if(this._iconsetName&&this._meta){this._iconset=/** @type {?Polymer.Iconset} */this._meta.byKey(this._iconsetName);if(this._iconset){this._iconset.applyIcon(this,this._iconName,this.theme);this.unlisten(window,"iron-iconset-added","_updateIcon")}else{this.listen(window,"iron-iconset-added","_updateIcon")}}}else{if(this._iconset){this._iconset.removeIcon(this)}if(!this._img){this._img=document.createElement("img");this._img.style.width="100%";this._img.style.height="100%";this._img.draggable=!1}this._img.src=this.src;Polymer.dom(this.root).appendChild(this._img)}}});</script></dom-module><dom-module id="lumo-checkbox" theme-for="vaadin-checkbox" assetpath="../bower_components/vaadin-checkbox/theme/lumo/"><template><style include="lumo-checkbox-style lumo-checkbox-effects">::-ms-backdrop,
      [part="checkbox"]{line-height:1;}</style></template></dom-module><dom-module id="lumo-checkbox-style" assetpath="../bower_components/vaadin-checkbox/theme/lumo/"><template><style>:host{-webkit-tap-highlight-color:transparent;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;cursor:default;outline:none;}[part="label"]:not([empty]){margin:0.1875em 0.875em 0.1875em 0.375em;}[part="checkbox"]{width:calc(1em + 2px);height:calc(1em + 2px);margin:0.1875em;position:relative;border-radius:var(--lumo-border-radius-s);background-color:var(--lumo-contrast-20pct);transition:transform 0.2s cubic-bezier(.12, .32, .54, 2), background-color 0.15s;pointer-events:none;line-height:1.2;}:host([indeterminate]) [part="checkbox"],
      :host([checked]) [part="checkbox"]{background-color:var(--lumo-primary-color);}[part="checkbox"]::before{content:"\2003";}[part="checkbox"]::after{content:"";display:inline-block;width:0;height:0;border:0 solid var(--lumo-primary-contrast-color);border-width:0.1875em 0 0 0.1875em;box-sizing:border-box;transform-origin:0 0;position:absolute;top:0.8125em;left:0.5em;transform:scale(0.55) rotate(-135deg);opacity:0;}:host([checked]) [part="checkbox"]::after{opacity:1;width:0.625em;height:1.0625em;}:host([indeterminate]) [part="checkbox"]::after{transform:none;opacity:1;top:45%;height:10%;left:22%;right:22%;width:auto;border:0;background-color:var(--lumo-primary-contrast-color);transition:opacity 0.25s;}:host([focus-ring]) [part="checkbox"]{box-shadow:0 0 0 3px var(--lumo-primary-color-50pct);}:host([disabled]){pointer-events:none;color:var(--lumo-disabled-text-color);}:host([disabled]) [part="label"] ::slotted(*){color:inherit;}:host([disabled]) [part="checkbox"]{background-color:var(--lumo-contrast-10pct);}:host([disabled]) [part="checkbox"]::after{border-color:var(--lumo-contrast-30pct);}:host([indeterminate][disabled]) [part="checkbox"]::after{background-color:var(--lumo-contrast-30pct);}:host([dir="rtl"]) [part="label"]:not([empty]){margin:0.1875em 0.375em 0.1875em 0.875em;}</style></template></dom-module><dom-module id="lumo-checkbox-effects" assetpath="../bower_components/vaadin-checkbox/theme/lumo/"><template><style>:host(:hover) [part="checkbox"]::after{transition:width 0.1s, height 0.25s;}[part="checkbox"]::before{color:transparent;display:inline-block;width:100%;height:100%;border-radius:inherit;background-color:inherit;transform:scale(1.4);opacity:0;transition:transform 0.1s, opacity 0.8s;}:host(:not([checked]):not([indeterminate]):not([disabled]):hover) [part="checkbox"]{background-color:var(--lumo-contrast-30pct);}@media (pointer: coarse){:host(:not([checked]):not([indeterminate]):not([disabled]):hover) [part="checkbox"]{background-color:var(--lumo-contrast-20pct);}}:host([active]) [part="checkbox"]{transform:scale(0.9);transition-duration:0.05s;}:host([active][checked]) [part="checkbox"]{transform:scale(1.1);}:host([active]:not([checked])) [part="checkbox"]::before{transition-duration:0.01s, 0.01s;transform:scale(0);opacity:0.4;}</style></template></dom-module><dom-module id="vaadin-checkbox" assetpath="../bower_components/vaadin-checkbox/src/"><template><style>:host{display:inline-block;}:host([hidden]){display:none !important;}label{display:inline-flex;align-items:baseline;outline:none;}[part="checkbox"]{position:relative;display:inline-block;flex:none;}input[type="checkbox"]{position:absolute;top:0;left:0;right:0;width:100%;height:100%;opacity:0;cursor:inherit;margin:0;}:host([disabled]){-webkit-tap-highlight-color:transparent;}</style><label><span part="checkbox"><input type="checkbox" checked="{{checked::change}}" disabled$="[[disabled]]" indeterminate="{{indeterminate::change}}" role="presentation" tabindex="-1"> </span><span part="label"><slot></slot></span></label></template><script>(function(){/**
       * `<vaadin-checkbox>` is a Web Component for customized checkboxes.
       *
       * ```html
       * <vaadin-checkbox>
       *   Make my profile visible
       * </vaadin-checkbox>
       * ```
       *
       * ### Styling
       *
       * The following shadow DOM parts are available for styling:
       *
       * Part name         | Description
       * ------------------|----------------
       * `checkbox`        | The wrapper element for the native <input type="checkbox">
       * `label`           | The wrapper element in which the component's children, namely the label, is slotted
       *
       * The following state attributes are available for styling:
       *
       * Attribute    | Description | Part name
       * -------------|-------------|--------------
       * `active`     | Set when the checkbox is pressed down, either with mouse, touch or the keyboard. | `:host`
       * `disabled`   | Set when the checkbox is disabled. | `:host`
       * `focus-ring` | Set when the checkbox is focused using the keyboard. | `:host`
       * `focused`    | Set when the checkbox is focused. | `:host`
       * `indeterminate` | Set when the checkbox is in indeterminate mode. | `:host`
       * `checked` | Set when the checkbox is checked. | `:host`
       * `empty` | Set when there is no label provided. | `label`
       *
       * See [ThemableMixin – how to apply styles for shadow parts](https://github.com/vaadin/vaadin-themable-mixin/wiki)
       *
       * @memberof Vaadin
       * @mixes Vaadin.ElementMixin
       * @mixes Vaadin.ControlStateMixin
       * @mixes Vaadin.ThemableMixin
       * @mixes Polymer.GestureEventListeners
       * @demo demo/index.html
       */class CheckboxElement extends Vaadin.ElementMixin(Vaadin.ControlStateMixin(Vaadin.ThemableMixin(Polymer.GestureEventListeners(Polymer.Element)))){static get is(){return"vaadin-checkbox"}static get version(){return"2.3.0"}static get properties(){return{/**
             * True if the checkbox is checked.
             */checked:{type:Boolean,value:!1,notify:!0,observer:"_checkedChanged",reflectToAttribute:!0},/**
             * Indeterminate state of the checkbox when it's neither checked nor unchecked, but undetermined.
             * https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input/checkbox#Indeterminate_state_checkboxes
             */indeterminate:{type:Boolean,notify:!0,observer:"_indeterminateChanged",reflectToAttribute:!0,value:!1},/**
             * The value given to the data submitted with the checkbox's name to the server when the control is inside a form.
             */value:{type:String,value:"on"},_nativeCheckbox:{type:Object}}}constructor(){super();/**
           * @type {string}
           * Name of the element.
           */this.name}get name(){return this.checked?this._storedName:""}set name(name){this._storedName=name}ready(){super.ready();this.setAttribute("role","checkbox");this._nativeCheckbox=this.shadowRoot.querySelector("input[type=\"checkbox\"]");this.addEventListener("click",this._handleClick.bind(this));this._addActiveListeners();const attrName=this.getAttribute("name");if(attrName){this.name=attrName}this.shadowRoot.querySelector("[part~=\"label\"]").querySelector("slot").addEventListener("slotchange",this._updateLabelAttribute.bind(this));this._updateLabelAttribute()}_updateLabelAttribute(){const label=this.shadowRoot.querySelector("[part~=\"label\"]"),assignedNodes=label.firstElementChild.assignedNodes();if(this._isAssignedNodesEmpty(assignedNodes)){label.setAttribute("empty","")}else{label.removeAttribute("empty")}}_isAssignedNodesEmpty(nodes){// The assigned nodes considered to be empty if there is no slotted content or only one empty text node
return 0===nodes.length||1==nodes.length&&nodes[0].nodeType==Node.TEXT_NODE&&""===nodes[0].textContent.trim()}_checkedChanged(checked){if(this.indeterminate){this.setAttribute("aria-checked","mixed")}else{this.setAttribute("aria-checked",!!checked)}}_indeterminateChanged(indeterminate){if(indeterminate){this.setAttribute("aria-checked","mixed")}else{this.setAttribute("aria-checked",this.checked)}}_addActiveListeners(){// DOWN
this._addEventListenerToNode(this,"down",e=>{if(this.__interactionsAllowed(e)){this.setAttribute("active","")}});// UP
this._addEventListenerToNode(this,"up",()=>this.removeAttribute("active"));// KEYDOWN
this.addEventListener("keydown",e=>{if(this.__interactionsAllowed(e)&&32===e.keyCode){e.preventDefault();this.setAttribute("active","")}});// KEYUP
this.addEventListener("keyup",e=>{if(this.__interactionsAllowed(e)&&32===e.keyCode){e.preventDefault();this._toggleChecked();this.removeAttribute("active");if(this.indeterminate){this.indeterminate=!1}}})}/** @protected */get focusElement(){return this.shadowRoot.querySelector("input")}/**
         * True if users' interactions (mouse or keyboard)
         * should toggle the checkbox
         */__interactionsAllowed(e){if(this.disabled){return!1}// https://github.com/vaadin/vaadin-checkbox/issues/63
if("a"===e.target.localName){return!1}return!0}_handleClick(e){if(this.__interactionsAllowed(e)){if(!this.indeterminate){if(e.composedPath()[0]!==this._nativeCheckbox){e.preventDefault();this._toggleChecked()}}else{/*
               * Required for IE 11 and Edge.
               * See issue here: https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/7344418/
               */this.indeterminate=!1;e.preventDefault();this._toggleChecked()}}}_toggleChecked(){this.checked=!this.checked;this.dispatchEvent(new CustomEvent("change",{composed:!1,bubbles:!0}))}/**
         * Fired when the user commits a value change.
         *
         * @event change
         */}customElements.define(CheckboxElement.is,CheckboxElement);/**
       * @namespace Vaadin
       */window.Vaadin.CheckboxElement=CheckboxElement})();</script></dom-module><dom-module id="lumo-grid" theme-for="vaadin-grid" assetpath="../bower_components/vaadin-grid/theme/lumo/"><template><style>:host{font-family:var(--lumo-font-family);font-size:var(--lumo-font-size-m);line-height:var(--lumo-line-height-s);color:var(--lumo-body-text-color);background-color:var(--lumo-base-color);box-sizing:border-box;-webkit-text-size-adjust:100%;-webkit-tap-highlight-color:transparent;-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale;--_lumo-grid-border-color:var(--lumo-contrast-20pct);--_lumo-grid-secondary-border-color:var(--lumo-contrast-10pct);--_lumo-grid-border-width:1px;--_lumo-grid-selected-row-color:var(--lumo-primary-color-10pct);}:host(:not([theme~="no-border"])){border:var(--_lumo-grid-border-width) solid var(--_lumo-grid-border-color);}[part~="cell"]{min-height:var(--lumo-size-m);background-color:var(--lumo-base-color);}[part~="cell"] ::slotted(vaadin-grid-cell-content){cursor:default;padding:var(--lumo-space-xs) var(--lumo-space-m);}:host(:not([theme~="no-row-borders"])) [part~="cell"]:not([part~="details-cell"]){border-top:var(--_lumo-grid-border-width) solid var(--_lumo-grid-secondary-border-color);}:host(:not([theme~="no-row-borders"])) [part="row"][first] [part~="cell"]:not([part~="details-cell"]){border-top:0;min-height:calc(var(--lumo-size-m) - var(--_lumo-grid-border-width));}[part~="cell"]:focus{outline:none;}:host([navigating]) [part~="cell"]:focus::before{content:"";position:absolute;top:0;right:0;bottom:0;left:0;pointer-events:none;box-shadow:inset 0 0 0 2px var(--lumo-primary-color-50pct);}:host([dragover])::after{content:"";position:absolute;z-index:100;top:0;right:0;bottom:0;left:0;pointer-events:none;box-shadow:inset 0 0 0 2px var(--lumo-primary-color-50pct);}[part~="row"][dragover]{z-index:100 !important;}[part~="row"][dragover] [part~="cell"]{overflow:visible;}[part~="row"][dragover] [part~="cell"]::after{content:"";position:absolute;top:0;right:0;bottom:0;left:0;height:calc(var(--_lumo-grid-border-width) + 2px);pointer-events:none;background:var(--lumo-primary-color-50pct);}:host([theme~="no-row-borders"]) [dragover] [part~="cell"]::after{height:2px;}[part~="row"][dragover="below"] [part~="cell"]::after{top:100%;bottom:auto;margin-top:-1px;}[part~="row"][dragover="above"] [part~="cell"]::after{top:auto;bottom:100%;margin-bottom:-1px;}[part~="row"][details-opened][dragover="below"] [part~="cell"]:not([part~="details-cell"])::after,
      [part~="row"][details-opened][dragover="above"] [part~="details-cell"]::after{display:none;}[part~="row"][dragover][dragover="on-top"] [part~="cell"]::after{height:100%;}[part~="row"][dragstart]{border-bottom:100px solid transparent;z-index:100 !important;opacity:0.9;}[part~="row"][dragstart] [part~="cell"]{border:none !important;box-shadow:none !important;}[part~="row"][dragstart] [part~="cell"][last-column]{border-radius:0 var(--lumo-border-radius-s) var(--lumo-border-radius-s) 0;}[part~="row"][dragstart] [part~="cell"][first-column]{border-radius:var(--lumo-border-radius-s) 0 0 var(--lumo-border-radius-s);}[ios] [part~="row"][dragstart] [part~="cell"]{background:var(--lumo-primary-color-50pct);}#scroller:not([ios]) [part~="row"][dragstart]:not([dragstart=""])::after{display:block;position:absolute;left:var(--_grid-drag-start-x);top:var(--_grid-drag-start-y);z-index:100;content:attr(dragstart);align-items:center;justify-content:center;box-sizing:border-box;padding:calc(var(--lumo-space-xs) * 0.8);color:var(--lumo-error-contrast-color);background-color:var(--lumo-error-color);border-radius:var(--lumo-border-radius-m);font-family:var(--lumo-font-family);font-size:var(--lumo-font-size-xxs);line-height:1;font-weight:500;text-transform:initial;letter-spacing:initial;min-width:calc(var(--lumo-size-s) * 0.7);text-align:center;}[part~="header-cell"] ::slotted(vaadin-grid-cell-content),
      [part~="footer-cell"] ::slotted(vaadin-grid-cell-content),
      [part~="reorder-ghost"]{font-size:var(--lumo-font-size-s);font-weight:500;}[part~="footer-cell"] ::slotted(vaadin-grid-cell-content){font-weight:400;}[part="row"]:only-child [part~="header-cell"]{min-height:var(--lumo-size-xl);}:host(:not([theme~="no-row-borders"])) [part="row"]:first-child [part~="header-cell"]{border-top:0;}[part="row"]:last-child [part~="header-cell"]{border-bottom:var(--_lumo-grid-border-width) solid transparent;}:host(:not([theme~="no-row-borders"])) [part="row"]:last-child [part~="header-cell"]{border-bottom-color:var(--_lumo-grid-secondary-border-color);}:host([overflow~="top"]) [part="row"]:last-child [part~="header-cell"]{border-bottom-color:var(--_lumo-grid-border-color);}[part="row"]:first-child [part~="footer-cell"]{border-top:var(--_lumo-grid-border-width) solid transparent;}:host(:not([theme~="no-row-borders"])) [part="row"]:first-child [part~="footer-cell"]{border-top-color:var(--_lumo-grid-secondary-border-color);}:host([overflow~="bottom"]) [part="row"]:first-child [part~="footer-cell"]{border-top-color:var(--_lumo-grid-border-color);}:host([reordering]) [part~="cell"]{background:linear-gradient(var(--lumo-shade-20pct), var(--lumo-shade-20pct)) var(--lumo-base-color);}:host([reordering]) [part~="cell"][reorder-status="allowed"]{background:var(--lumo-base-color);}:host([reordering]) [part~="cell"][reorder-status="dragging"]{background:linear-gradient(var(--lumo-contrast-5pct), var(--lumo-contrast-5pct)) var(--lumo-base-color);}[part~="reorder-ghost"]{opacity:0.85;box-shadow:var(--lumo-box-shadow-s);padding:var(--lumo-space-s) var(--lumo-space-m) !important;}[part="resize-handle"]{width:3px;background-color:var(--lumo-primary-color-50pct);opacity:0;transition:opacity 0.2s;}:host(:not([reordering])) *:not([column-resizing]) [part~="cell"]:hover [part="resize-handle"],
      [part="resize-handle"]:active{opacity:1;transition-delay:0.15s;}:host([theme~="column-borders"]) [part~="cell"]:not([last-column]):not([part~="details-cell"]){border-right:var(--_lumo-grid-border-width) solid var(--_lumo-grid-secondary-border-color);}[last-frozen]{border-right:var(--_lumo-grid-border-width) solid transparent;overflow:hidden;}:host([overflow~="left"]) [part~="cell"][last-frozen]:not([part~="details-cell"]){border-right-color:var(--_lumo-grid-border-color);}:host([theme~="row-stripes"]) [part~="row"]:not([odd]) [part~="body-cell"],
      :host([theme~="row-stripes"]) [part~="row"]:not([odd]) [part~="details-cell"]{background-image:linear-gradient(var(--lumo-contrast-5pct), var(--lumo-contrast-5pct));background-repeat:repeat-x;}:host(:not([reordering])) [part~="row"][selected]{z-index:1;}:host(:not([reordering])) [part~="row"][selected] [part~="body-cell"]:not([part~="details-cell"]){background-image:linear-gradient(var(--_lumo-grid-selected-row-color), var(--_lumo-grid-selected-row-color));background-repeat:repeat;}:host(:not([theme~="no-row-borders"])) [part~="row"][selected] [part~="cell"]:not([part~="details-cell"]){box-shadow:0 var(--_lumo-grid-border-width) 0 0 var(--_lumo-grid-selected-row-color);}:host([theme~="compact"]) [part="row"]:only-child [part~="header-cell"]{min-height:var(--lumo-size-m);}:host([theme~="compact"]) [part~="cell"]{min-height:var(--lumo-size-s);}:host([theme~="compact"]) [part="row"][first] [part~="cell"]:not([part~="details-cell"]){min-height:calc(var(--lumo-size-s) - var(--_lumo-grid-border-width));}:host([theme~="compact"]) [part~="cell"] ::slotted(vaadin-grid-cell-content){padding:var(--lumo-space-xs) var(--lumo-space-s);}:host([theme~="wrap-cell-content"]) [part~="cell"] ::slotted(vaadin-grid-cell-content){white-space:normal;}:host([dir="rtl"]) [part~="row"][dragstart] [part~="cell"][last-column]{border-radius:var(--lumo-border-radius-s) 0 0 var(--lumo-border-radius-s);}:host([dir="rtl"]) [part~="row"][dragstart] [part~="cell"][first-column]{border-radius:0 var(--lumo-border-radius-s) var(--lumo-border-radius-s) 0;}:host([dir="rtl"][theme~="column-borders"]) [part~="cell"]:not([last-column]):not([part~="details-cell"]){border-right:none;border-left:var(--_lumo-grid-border-width) solid var(--_lumo-grid-secondary-border-color);}:host([dir="rtl"]) [last-frozen]{border-right:none;border-left:var(--_lumo-grid-border-width) solid transparent;}:host([dir="rtl"][overflow~="right"]) [part~="cell"][last-frozen]:not([part~="details-cell"]){border-left-color:var(--_lumo-grid-border-color);}</style></template></dom-module><dom-module theme-for="vaadin-checkbox" id="vaadin-grid-select-all-checkbox-lumo" assetpath="../bower_components/vaadin-grid/theme/lumo/"><template><style>:host(.vaadin-grid-select-all-checkbox){font-size:var(--lumo-font-size-m);}</style></template></dom-module><script>(function(){var IOS=navigator.userAgent.match(/iP(?:hone|ad;(?: U;)? CPU) OS (\d+)/),IOS_TOUCH_SCROLLING=IOS&&8<=IOS[1],DEFAULT_PHYSICAL_COUNT=3,ANIMATION_FRAME=Polymer.Async.animationFrame,IDLE_TIME=Polymer.Async.idlePeriod,MICRO_TASK=Polymer.Async.microTask;/**
   * @namespace
   */window.PolymerIronList=Polymer.Class({behaviors:[Polymer.IronResizableBehavior,Polymer.IronScrollTargetBehavior],/**
     * The ratio of hidden tiles that should remain in the scroll direction.
     * Recommended value ~0.5, so it will distribute tiles evenly in both directions.
     */_ratio:.5,/**
     * The padding-top value for the list.
     */_scrollerPaddingTop:0,/**
     * This value is the same as `scrollTop`.
     */_scrollPosition:0,/**
     * The sum of the heights of all the tiles in the DOM.
     */_physicalSize:0,/**
     * The average `offsetHeight` of the tiles observed till now.
     */_physicalAverage:0,/**
     * The number of tiles which `offsetHeight` > 0 observed until now.
     */_physicalAverageCount:0,/**
     * The Y position of the item rendered in the `_physicalStart`
     * tile relative to the scrolling list.
     */_physicalTop:0,/**
     * The number of items in the list.
     */_virtualCount:0,/**
     * The estimated scroll height based on `_physicalAverage`
     */_estScrollHeight:0,/**
     * The scroll height of the dom node
     */_scrollHeight:0,/**
     * The height of the list. This is referred as the viewport in the context of list.
     */_viewportHeight:0,/**
     * The width of the list. This is referred as the viewport in the context of list.
     */_viewportWidth:0,/**
     * An array of DOM nodes that are currently in the tree
     * @type {?Array<!TemplatizerNode>}
     */_physicalItems:null,/**
     * An array of heights for each item in `_physicalItems`
     * @type {?Array<number>}
     */_physicalSizes:null,/**
     * A cached value for the first visible index.
     * See `firstVisibleIndex`
     * @type {?number}
     */_firstVisibleIndexVal:null,/**
     * A Polymer collection for the items.
     * @type {?Polymer.Collection}
     */_collection:null,/**
     * A cached value for the last visible index.
     * See `lastVisibleIndex`
     * @type {?number}
     */_lastVisibleIndexVal:null,/**
     * The max number of pages to render. One page is equivalent to the height of the list.
     */_maxPages:2,/**
     * The virtual index of the focused item.
     */_focusedVirtualIndex:-1,/**
     * The maximum items per row
     */_itemsPerRow:1,/**
     * The height of the row in grid layout.
     */_rowHeight:0,/**
     * The cost of stamping a template in ms.
     */_templateCost:0,/**
     * The bottom of the physical content.
     */get _physicalBottom(){return this._physicalTop+this._physicalSize},/**
     * The bottom of the scroll.
     */get _scrollBottom(){return this._scrollPosition+this._viewportHeight},/**
     * The n-th item rendered in the last physical item.
     */get _virtualEnd(){return this._virtualStart+this._physicalCount-1},/**
     * The height of the physical content that isn't on the screen.
     */get _hiddenContentSize(){var size=this.grid?this._physicalRows*this._rowHeight:this._physicalSize;return size-this._viewportHeight},/**
     * The maximum scroll top value.
     */get _maxScrollTop(){return this._estScrollHeight-this._viewportHeight+this._scrollOffset},/**
     * The largest n-th value for an item such that it can be rendered in `_physicalStart`.
     */get _maxVirtualStart(){var virtualCount=this._convertIndexToCompleteRow(this._virtualCount);return Math.max(0,virtualCount-this._physicalCount)},set _virtualStart(val){val=this._clamp(val,0,this._maxVirtualStart);if(this.grid){val=val-val%this._itemsPerRow}this._virtualStartVal=val},get _virtualStart(){return this._virtualStartVal||0},/**
     * The k-th tile that is at the top of the scrolling list.
     */set _physicalStart(val){val=val%this._physicalCount;if(0>val){val=this._physicalCount+val}if(this.grid){val=val-val%this._itemsPerRow}this._physicalStartVal=val},get _physicalStart(){return this._physicalStartVal||0},/**
     * The k-th tile that is at the bottom of the scrolling list.
     */get _physicalEnd(){return(this._physicalStart+this._physicalCount-1)%this._physicalCount},set _physicalCount(val){this._physicalCountVal=val},get _physicalCount(){return this._physicalCountVal||0},/**
     * An optimal physical size such that we will have enough physical items
     * to fill up the viewport and recycle when the user scrolls.
     *
     * This default value assumes that we will at least have the equivalent
     * to a viewport of physical items above and below the user's viewport.
     */get _optPhysicalSize(){return 0===this._viewportHeight?1/0:this._viewportHeight*this._maxPages},/**
     * True if the current list is visible.
     */get _isVisible(){return!!(this.offsetWidth||this.offsetHeight)},/**
     * Gets the index of the first visible item in the viewport.
     *
     * @type {number}
     */get firstVisibleIndex(){var idx=this._firstVisibleIndexVal;if(null==idx){var physicalOffset=this._physicalTop+this._scrollOffset;idx=this._iterateItems(function(pidx,vidx){physicalOffset+=this._getPhysicalSizeIncrement(pidx);if(physicalOffset>this._scrollPosition){return this.grid?vidx-vidx%this._itemsPerRow:vidx}// Handle a partially rendered final row in grid mode
if(this.grid&&this._virtualCount-1===vidx){return vidx-vidx%this._itemsPerRow}})||0;this._firstVisibleIndexVal=idx}return idx},/**
     * Gets the index of the last visible item in the viewport.
     *
     * @type {number}
     */get lastVisibleIndex(){var idx=this._lastVisibleIndexVal;if(null==idx){if(this.grid){idx=Math.min(this._virtualCount,this.firstVisibleIndex+this._estRowsInView*this._itemsPerRow-1)}else{var physicalOffset=this._physicalTop+this._scrollOffset;this._iterateItems(function(pidx,vidx){if(physicalOffset<this._scrollBottom){idx=vidx}physicalOffset+=this._getPhysicalSizeIncrement(pidx)})}this._lastVisibleIndexVal=idx}return idx},get _scrollOffset(){return this._scrollerPaddingTop},attached:function(){this._debounce("_render",this._render,ANIMATION_FRAME);// `iron-resize` is fired when the list is attached if the event is added
// before attached causing unnecessary work.
this.listen(this,"iron-resize","_resizeHandler")},detached:function(){this.unlisten(this,"iron-resize","_resizeHandler")},/**
     * Invoke this method if you dynamically update the viewport's
     * size or CSS padding.
     *
     * @method updateViewportBoundaries
     */updateViewportBoundaries:function(){var styles=window.getComputedStyle(this);this._scrollerPaddingTop=this.scrollTarget===this?0:parseInt(styles["padding-top"],10);this._isRTL=!!("rtl"===styles.direction);this._viewportWidth=this.$.items.offsetWidth;this._viewportHeight=this._scrollTargetHeight;this.grid&&this._updateGridMetrics()},/**
     * Recycles the physical items when needed.
     */_scrollHandler:function(){var scrollTop=Math.max(0,Math.min(this._maxScrollTop,this._scrollTop)),delta=scrollTop-this._scrollPosition,isScrollingDown=0<=delta;// Track the current scroll position.
this._scrollPosition=scrollTop;// Clear indexes for first and last visible indexes.
this._firstVisibleIndexVal=null;this._lastVisibleIndexVal=null;// Random access.
if(Math.abs(delta)>this._physicalSize&&0<this._physicalSize){delta=delta-this._scrollOffset;var idxAdjustment=Math.round(delta/this._physicalAverage)*this._itemsPerRow;this._virtualStart=this._virtualStart+idxAdjustment;this._physicalStart=this._physicalStart+idxAdjustment;// Estimate new physical offset.
this._physicalTop=Math.floor(this._virtualStart/this._itemsPerRow)*this._physicalAverage;this._update()}else if(0<this._physicalCount){var reusables=this._getReusables(isScrollingDown);if(isScrollingDown){this._physicalTop=reusables.physicalTop;this._virtualStart=this._virtualStart+reusables.indexes.length;this._physicalStart=this._physicalStart+reusables.indexes.length}else{this._virtualStart=this._virtualStart-reusables.indexes.length;this._physicalStart=this._physicalStart-reusables.indexes.length}this._update(reusables.indexes,isScrollingDown?null:reusables.indexes);this._debounce("_increasePoolIfNeeded",this._increasePoolIfNeeded.bind(this,0),MICRO_TASK)}},/**
     * Returns an object that contains the indexes of the physical items
     * that might be reused and the physicalTop.
     *
     * @param {boolean} fromTop If the potential reusable items are above the scrolling region.
     */_getReusables:function(fromTop){var ith,offsetContent,physicalItemHeight,idxs=[],protectedOffsetContent=this._hiddenContentSize*this._ratio,virtualStart=this._virtualStart,virtualEnd=this._virtualEnd,physicalCount=this._physicalCount,top=this._physicalTop+this._scrollOffset,bottom=this._physicalBottom+this._scrollOffset,scrollTop=this._scrollTop,scrollBottom=this._scrollBottom;if(fromTop){ith=this._physicalStart;offsetContent=scrollTop-top}else{ith=this._physicalEnd;offsetContent=bottom-scrollBottom}// eslint-disable-next-line no-constant-condition
while(!0){physicalItemHeight=this._getPhysicalSizeIncrement(ith);offsetContent=offsetContent-physicalItemHeight;if(idxs.length>=physicalCount||offsetContent<=protectedOffsetContent){break}if(fromTop){// Check that index is within the valid range.
if(virtualEnd+idxs.length+1>=this._virtualCount){break}// Check that the index is not visible.
if(top+physicalItemHeight>=scrollTop-this._scrollOffset){break}idxs.push(ith);top=top+physicalItemHeight;ith=(ith+1)%physicalCount}else{// Check that index is within the valid range.
if(0>=virtualStart-idxs.length){break}// Check that the index is not visible.
if(top+this._physicalSize-physicalItemHeight<=scrollBottom){break}idxs.push(ith);top=top-physicalItemHeight;ith=0===ith?physicalCount-1:ith-1}}return{indexes:idxs,physicalTop:top-this._scrollOffset}},/**
     * Update the list of items, starting from the `_virtualStart` item.
     * @param {!Array<number>=} itemSet
     * @param {!Array<number>=} movingUp
     */_update:function(itemSet,movingUp){if(itemSet&&0===itemSet.length||0===this._physicalCount){return}this._manageFocus();this._assignModels(itemSet);this._updateMetrics(itemSet);// Adjust offset after measuring.
if(movingUp){while(movingUp.length){var idx=movingUp.pop();this._physicalTop-=this._getPhysicalSizeIncrement(idx)}}this._positionItems();this._updateScrollerSize()},_isClientFull:function(){return 0!=this._scrollBottom&&this._physicalBottom-1>=this._scrollBottom&&this._physicalTop<=this._scrollPosition},/**
     * Increases the pool size.
     */_increasePoolIfNeeded:function(count){var nextPhysicalCount=this._clamp(this._physicalCount+count,DEFAULT_PHYSICAL_COUNT,this._virtualCount-this._virtualStart);nextPhysicalCount=this._convertIndexToCompleteRow(nextPhysicalCount);var delta=nextPhysicalCount-this._physicalCount,nextIncrease=Math.round(.5*this._physicalCount);if(0>delta){return}if(0<delta){var ts=window.performance.now();// Concat arrays in place.
[].push.apply(this._physicalItems,this._createPool(delta));// Push 0s into physicalSizes. Can't use Array.fill because IE11 doesn't support it.
for(var i=0;i<delta;i++){this._physicalSizes.push(0)}this._physicalCount=this._physicalCount+delta;// Update the physical start if it needs to preserve the model of the focused item.
// In this situation, the focused item is currently rendered and its model would
// have changed after increasing the pool if the physical start remained unchanged.
if(this._physicalStart>this._physicalEnd&&this._isIndexRendered(this._focusedVirtualIndex)&&this._getPhysicalIndex(this._focusedVirtualIndex)<this._physicalEnd){this._physicalStart=this._physicalStart+delta}this._update();this._templateCost=(window.performance.now()-ts)/delta;nextIncrease=Math.round(.5*this._physicalCount)}// The upper bounds is not fixed when dealing with a grid that doesn't
// fill it's last row with the exact number of items per row.
if(this._virtualEnd>=this._virtualCount-1||0===nextIncrease){// Do nothing.
}else if(!this._isClientFull()){this._debounce("_increasePoolIfNeeded",this._increasePoolIfNeeded.bind(this,nextIncrease),MICRO_TASK)}else if(this._physicalSize<this._optPhysicalSize){// Yield and increase the pool during idle time until the physical size is optimal.
this._debounce("_increasePoolIfNeeded",this._increasePoolIfNeeded.bind(this,this._clamp(Math.round(50/this._templateCost),1,nextIncrease)),IDLE_TIME)}},/**
     * Renders the a new list.
     */_render:function(){if(!this.isAttached||!this._isVisible){return}if(0!==this._physicalCount){var reusables=this._getReusables(!0);this._physicalTop=reusables.physicalTop;this._virtualStart=this._virtualStart+reusables.indexes.length;this._physicalStart=this._physicalStart+reusables.indexes.length;this._update(reusables.indexes);this._update();this._increasePoolIfNeeded(0)}else if(0<this._virtualCount){// Initial render
this.updateViewportBoundaries();this._increasePoolIfNeeded(DEFAULT_PHYSICAL_COUNT)}},/**
     * Called when the items have changed. That is, reassignments
     * to `items`, splices or updates to a single item.
     */_itemsChanged:function(change){if("items"===change.path){this._virtualStart=0;this._physicalTop=0;this._virtualCount=this.items?this.items.length:0;this._collection=this.items&&Polymer.Collection?Polymer.Collection.get(this.items):null;this._physicalIndexForKey={};this._firstVisibleIndexVal=null;this._lastVisibleIndexVal=null;this._physicalCount=this._physicalCount||0;this._physicalItems=this._physicalItems||[];this._physicalSizes=this._physicalSizes||[];this._physicalStart=0;if(this._scrollTop>this._scrollOffset){this._resetScrollPosition(0)}this._removeFocusedItem();this._debounce("_render",this._render,ANIMATION_FRAME)}},/**
     * Executes a provided function per every physical index in `itemSet`
     * `itemSet` default value is equivalent to the entire set of physical indexes.
     *
     * @param {!function(number, number)} fn
     * @param {!Array<number>=} itemSet
     */_iterateItems:function(fn,itemSet){var pidx,vidx,rtn,i;if(2===arguments.length&&itemSet){for(i=0;i<itemSet.length;i++){pidx=itemSet[i];vidx=this._computeVidx(pidx);if(null!=(rtn=fn.call(this,pidx,vidx))){return rtn}}}else{pidx=this._physicalStart;vidx=this._virtualStart;for(;pidx<this._physicalCount;pidx++,vidx++){if(null!=(rtn=fn.call(this,pidx,vidx))){return rtn}}for(pidx=0;pidx<this._physicalStart;pidx++,vidx++){if(null!=(rtn=fn.call(this,pidx,vidx))){return rtn}}}},/**
     * Returns the virtual index for a given physical index
     *
     * @param {number} pidx Physical index
     * @return {number}
     */_computeVidx:function(pidx){if(pidx>=this._physicalStart){return this._virtualStart+(pidx-this._physicalStart)}return this._virtualStart+(this._physicalCount-this._physicalStart)+pidx},/**
     * Updates the height for a given set of items.
     *
     * @param {!Array<number>=} itemSet
     */_updateMetrics:function(itemSet){// Make sure we distributed all the physical items
// so we can measure them.
Polymer.flush?Polymer.flush():Polymer.dom.flush();var newPhysicalSize=0,oldPhysicalSize=0,prevAvgCount=this._physicalAverageCount,prevPhysicalAvg=this._physicalAverage;this._iterateItems(function(pidx,vidx){oldPhysicalSize+=this._physicalSizes[pidx];this._physicalSizes[pidx]=this._physicalItems[pidx].offsetHeight;newPhysicalSize+=this._physicalSizes[pidx];this._physicalAverageCount+=this._physicalSizes[pidx]?1:0},itemSet);if(this.grid){this._updateGridMetrics();this._physicalSize=Math.ceil(this._physicalCount/this._itemsPerRow)*this._rowHeight}else{oldPhysicalSize=1===this._itemsPerRow?oldPhysicalSize:Math.ceil(this._physicalCount/this._itemsPerRow)*this._rowHeight;this._physicalSize=this._physicalSize+newPhysicalSize-oldPhysicalSize;this._itemsPerRow=1}// Update the average if it measured something.
if(this._physicalAverageCount!==prevAvgCount){this._physicalAverage=Math.round((prevPhysicalAvg*prevAvgCount+newPhysicalSize)/this._physicalAverageCount)}},/**
     * Updates the position of the physical items.
     */_positionItems:function(){this._adjustScrollPosition();var y=this._physicalTop;this._iterateItems(function(pidx,vidx){this.translate3d(0,y+"px",0,this._physicalItems[pidx]);y+=this._physicalSizes[pidx]})},_getPhysicalSizeIncrement:function(pidx){if(!this.grid){return this._physicalSizes[pidx]}if(this._computeVidx(pidx)%this._itemsPerRow!==this._itemsPerRow-1){return 0}return this._rowHeight},/**
     * Adjusts the scroll position when it was overestimated.
     */_adjustScrollPosition:function(){var deltaHeight=0===this._virtualStart?this._physicalTop:Math.min(this._scrollPosition+this._physicalTop,0);// Note: the delta can be positive or negative.
if(0!==deltaHeight){this._physicalTop=this._physicalTop-deltaHeight;var scrollTop=this._scrollTop;// juking scroll position during interial scrolling on iOS is no bueno
if(!IOS_TOUCH_SCROLLING&&0<scrollTop){this._resetScrollPosition(scrollTop-deltaHeight)}}},/**
     * Sets the position of the scroll.
     */_resetScrollPosition:function(pos){if(this.scrollTarget&&0<=pos){this._scrollTop=pos;this._scrollPosition=this._scrollTop}},/**
     * Sets the scroll height, that's the height of the content,
     *
     * @param {boolean=} forceUpdate If true, updates the height no matter what.
     */_updateScrollerSize:function(forceUpdate){if(this.grid){this._estScrollHeight=this._virtualRowCount*this._rowHeight}else{this._estScrollHeight=this._physicalBottom+Math.max(this._virtualCount-this._physicalCount-this._virtualStart,0)*this._physicalAverage}forceUpdate=forceUpdate||0===this._scrollHeight;forceUpdate=forceUpdate||this._scrollPosition>=this._estScrollHeight-this._physicalSize;forceUpdate=forceUpdate||this.grid&&this.$.items.style.height<this._estScrollHeight;// Amortize height adjustment, so it won't trigger large repaints too often.
if(forceUpdate||Math.abs(this._estScrollHeight-this._scrollHeight)>=this._viewportHeight){this.$.items.style.height=this._estScrollHeight+"px";this._scrollHeight=this._estScrollHeight}},/**
     * Scroll to a specific index in the virtual list regardless
     * of the physical items in the DOM tree.
     *
     * @method scrollToIndex
     * @param {number} idx The index of the item
     */scrollToIndex:function(idx){if("number"!==typeof idx||0>idx||idx>this.items.length-1){return}Polymer.flush?Polymer.flush():Polymer.dom.flush();// Items should have been rendered prior scrolling to an index.
if(0===this._physicalCount){return}idx=this._clamp(idx,0,this._virtualCount-1);// Update the virtual start only when needed.
if(!this._isIndexRendered(idx)||idx>=this._maxVirtualStart){this._virtualStart=this.grid?idx-2*this._itemsPerRow:idx-1}this._manageFocus();this._assignModels();this._updateMetrics();// Estimate new physical offset.
this._physicalTop=Math.floor(this._virtualStart/this._itemsPerRow)*this._physicalAverage;var currentTopItem=this._physicalStart,currentVirtualItem=this._virtualStart,targetOffsetTop=0,hiddenContentSize=this._hiddenContentSize;// scroll to the item as much as we can.
while(currentVirtualItem<idx&&targetOffsetTop<=hiddenContentSize){targetOffsetTop=targetOffsetTop+this._getPhysicalSizeIncrement(currentTopItem);currentTopItem=(currentTopItem+1)%this._physicalCount;currentVirtualItem++}this._updateScrollerSize(!0);this._positionItems();this._resetScrollPosition(this._physicalTop+this._scrollOffset+targetOffsetTop);this._increasePoolIfNeeded(0);// clear cached visible index.
this._firstVisibleIndexVal=null;this._lastVisibleIndexVal=null},/**
     * Reset the physical average and the average count.
     */_resetAverage:function(){this._physicalAverage=0;this._physicalAverageCount=0},/**
     * A handler for the `iron-resize` event triggered by `IronResizableBehavior`
     * when the element is resized.
     */_resizeHandler:function(){this._debounce("_render",function(){// clear cached visible index.
this._firstVisibleIndexVal=null;this._lastVisibleIndexVal=null;// Skip the resize event on touch devices when the address bar slides up.
this.updateViewportBoundaries();if(this._isVisible){// Reinstall the scroll event listener.
this.toggleScrollListener(!0);this._resetAverage();this._render()}else{// Uninstall the scroll event listener.
this.toggleScrollListener(!1)}},ANIMATION_FRAME)},/**
     * Converts a random index to the index of the item that completes it's row.
     * Allows for better order and fill computation when grid == true.
     */_convertIndexToCompleteRow:function(idx){// when grid == false _itemPerRow can be unset.
this._itemsPerRow=this._itemsPerRow||1;return this.grid?Math.ceil(idx/this._itemsPerRow)*this._itemsPerRow:idx},_isIndexRendered:function(idx){return idx>=this._virtualStart&&idx<=this._virtualEnd},_getPhysicalIndex:function(vidx){return(this._physicalStart+(vidx-this._virtualStart))%this._physicalCount},_clamp:function(v,min,max){return Math.min(max,Math.max(min,v))},_debounce:function(name,cb,asyncModule){this._debouncers=this._debouncers||{};this._debouncers[name]=Polymer.Debouncer.debounce(this._debouncers[name],asyncModule,cb.bind(this));Polymer.enqueueDebouncer(this._debouncers[name])}})})();</script><script>(function(){/**
     * This Element is used internally by vaadin-grid.
     *
     * @private
     */class GridScrollerElement extends window.PolymerIronList{static get is(){return"vaadin-grid-scroller"}static get properties(){return{size:{type:Number,notify:!0},_vidxOffset:{value:0}}}static get observers(){return["_effectiveSizeChanged(_effectiveSize)"]}connectedCallback(){super.connectedCallback();this._scrollHandler()}/**
      * @protected
      */_updateScrollerItem(item,index){}/**
      * @protected
      */_afterScroll(){}/**
      * @protected
      */_getRowTarget(){}/**
      * @protected
      */_createScrollerRows(){}/**
      * @protected
      */_canPopulate(){}/**
      * @private
      */scrollToIndex(index){this._warnPrivateAPIAccess("scrollToIndex");if(0<index){this._pendingScrollToIndex=null}if(!parseInt(this.$.items.style.borderTopWidth)&&0<index){// Schedule another scroll to be invoked once init is complete
this._pendingScrollToIndex=index}this._scrollingToIndex=!0;index=Math.min(Math.max(index,0),this._effectiveSize-1);this.$.table.scrollTop=index/this._effectiveSize*(this.$.table.scrollHeight-this.$.table.offsetHeight);this._scrollHandler();if(this._accessIronListAPI(()=>this._maxScrollTop)&&this._virtualCount<this._effectiveSize){this._adjustVirtualIndexOffset(1e6)}this._accessIronListAPI(()=>super.scrollToIndex(index-this._vidxOffset));this._scrollHandler();// Ensure scroll position
const row=Array.from(this.$.items.children).filter(child=>child.index===index)[0];if(row){const headerOffset=row.getBoundingClientRect().top-this.$.header.getBoundingClientRect().bottom;if(1<Math.abs(headerOffset)){this.$.table.scrollTop+=headerOffset;this._scrollHandler()}}this._scrollingToIndex=!1}_effectiveSizeChanged(size){let fvi,fviOffset=0;// first visible (adjusted) index
this._iterateItems((pidx,vidx)=>{if(vidx===this._firstVisibleIndex){const row=this._physicalItems[pidx];fvi=row.index;fviOffset=row.getBoundingClientRect().top}});if(this.items&&size<this.items.length){// Size was reduced, scroll to 0 first
this._scrollTop=0}if(!Array.isArray(this.items)){// Edge/IE seems to have the lowest maximum
const maxVirtualItems=this._edge||this._ie?3e4:1e5;this.items={length:Math.min(size,maxVirtualItems)}}this._accessIronListAPI(()=>super._itemsChanged({path:"items"}));this._virtualCount=Math.min(this.items.length,size)||0;if(0===this._scrollTop){this._accessIronListAPI(()=>this._scrollToIndex(Math.min(size-1,fvi)));this._iterateItems((pidx,vidx)=>{const row=this._physicalItems[pidx];if(row.index===fvi){this.$.table.scrollTop+=Math.round(row.getBoundingClientRect().top-fviOffset)}// Restore keyboard focus to the right cell
if(row.index===this._focusedItemIndex&&this._itemsFocusable&&this.$.items.contains(this.shadowRoot.activeElement)){const cellIndex=Array.from(this._itemsFocusable.parentElement.children).indexOf(this._itemsFocusable);row.children[cellIndex].focus()}})}this._assignModels();requestAnimationFrame(()=>this._update())}_positionItems(){this._adjustScrollPosition();let rePosition;if(isNaN(this._physicalTop)){rePosition=!0;this._physicalTop=0}let y=this._physicalTop;this._iterateItems((pidx,vidx)=>{this._physicalItems[pidx].style.transform=`translateY(${y}px)`;y+=this._physicalSizes[pidx]});if(rePosition){this._scrollToIndex(0)}}_increasePoolIfNeeded(count){if(0===count&&this._scrollingToIndex||!this._canPopulate()||!this._effectiveSize){return}if(!this._initialPoolCreated){this._initialPoolCreated=!0;super._increasePoolIfNeeded(25)}else if(this._optPhysicalSize!==1/0){this._debounceIncreasePool=Polymer.Debouncer.debounce(this._debounceIncreasePool,Polymer.Async.animationFrame,()=>{this._updateMetrics();const remainingPhysicalSize=this._optPhysicalSize-this._physicalSize;let estimatedMissingRowCount=Math.ceil(remainingPhysicalSize/this._physicalAverage);if(this._physicalCount+estimatedMissingRowCount>this._effectiveSize){// Do not increase the physical item count above the this._effectiveSize
estimatedMissingRowCount=Math.max(0,this._effectiveSize-this._physicalCount)}if(this._physicalSize&&0<estimatedMissingRowCount&&this._optPhysicalSize!==1/0){super._increasePoolIfNeeded(estimatedMissingRowCount);// Ensure the rows are in order after increasing pool
this.__reorderChildNodes()}})}}__reorderChildNodes(){const childNodes=Array.from(this.$.items.childNodes),rowsInOrder=!!childNodes.reduce((inOrder,current,currentIndex,array)=>{if(0===currentIndex||array[currentIndex-1].index===current.index-1){return inOrder}},!0);if(!rowsInOrder){childNodes.sort((row1,row2)=>{return row1.index-row2.index}).forEach(row=>this.$.items.appendChild(row))}}_createPool(size){const fragment=document.createDocumentFragment(),physicalItems=this._createScrollerRows(size);physicalItems.forEach(inst=>fragment.appendChild(inst));this._getRowTarget().appendChild(fragment);// Weird hack needed to get Safari to actually distribute slots
const content=this.querySelector("[slot]");if(content){const slot=content.getAttribute("slot");content.setAttribute("slot","foo-bar");content.setAttribute("slot",slot)}this._updateHeaderFooterMetrics();Polymer.RenderStatus.afterNextRender(this,()=>this.notifyResize());return physicalItems}/**
       * Assigns the data models to a given set of items.
       * @param {!Array<number>=} itemSet
       */_assignModels(itemSet){this._iterateItems((pidx,vidx)=>{const el=this._physicalItems[pidx];this._toggleAttribute("hidden",vidx>=this._effectiveSize,el);this._updateScrollerItem(el,vidx+(this._vidxOffset||0))},itemSet)}_scrollHandler(){const delta=this.$.table.scrollTop-this._scrollPosition;this._accessIronListAPI(super._scrollHandler);const oldOffset=this._vidxOffset;if(this._accessIronListAPI(()=>this._maxScrollTop)&&this._virtualCount<this._effectiveSize){this._adjustVirtualIndexOffset(delta)}else{this._vidxOffset=0}if(this._vidxOffset!==oldOffset){this._update()}this._afterScroll()}_adjustVirtualIndexOffset(delta){if(1e4<Math.abs(delta)){if(this._noScale){this._noScale=!1;return}const scale=this.$.table.scrollTop/(this.$.table.scrollHeight-this.$.table.offsetHeight),offset=scale*this._effectiveSize;this._vidxOffset=Math.round(offset-scale*this._virtualCount)}else{// Make sure user can always swipe/wheel scroll to the start and end
const oldOffset=this._vidxOffset||0,threshold=1e3,maxShift=100;// At start
if(0===this._scrollTop){this._vidxOffset=0;if(oldOffset!==this._vidxOffset){super.scrollToIndex(0)}}else if(this.firstVisibleIndex<threshold&&0<this._vidxOffset){this._vidxOffset-=Math.min(this._vidxOffset,maxShift);if(oldOffset!==this._vidxOffset){super.scrollToIndex(this.firstVisibleIndex+(oldOffset-this._vidxOffset))}this._noScale=!0}// At end
const maxOffset=this._effectiveSize-this._virtualCount;if(this._scrollTop>=this._maxScrollTop&&0<this._maxScrollTop){this._vidxOffset=maxOffset;if(oldOffset!==this._vidxOffset){super.scrollToIndex(this._virtualCount)}}else if(this.firstVisibleIndex>this._virtualCount-threshold&&this._vidxOffset<maxOffset){this._vidxOffset+=Math.min(maxOffset-this._vidxOffset,maxShift);if(oldOffset!==this._vidxOffset){super.scrollToIndex(this.firstVisibleIndex-(this._vidxOffset-oldOffset))}this._noScale=!0}}}_accessIronListAPI(cb){this._warnPrivateAPIAccessAsyncEnabled=!1;const returnValue=cb.apply(this);this._debouncerWarnPrivateAPIAccess=Polymer.Debouncer.debounce(this._debouncerWarnPrivateAPIAccess,Polymer.Async.animationFrame,()=>this._warnPrivateAPIAccessAsyncEnabled=!0);return returnValue}/* Allow iron-list to access its APIs from debounced callbacks without warns */_debounceRender(cb,asyncModule){super._debounceRender(()=>this._accessIronListAPI(cb),asyncModule)}/* Warn when iron-list APIs are being accessed directly */_warnPrivateAPIAccess(apiName){if(this._warnPrivateAPIAccessAsyncEnabled){console.warn(`Accessing private API (${apiName})!`)}}_render(){this._accessIronListAPI(super._render)}_createFocusBackfillItem(){/* Ignore */}_multiSelectionChanged(){/* Ignore */}clearSelection(){/* Ignore */}_itemsChanged(){/* Ignore */}_manageFocus(){/* Ignore */}_removeFocusedItem(){/* Ignore */}get _firstVisibleIndex(){return this._accessIronListAPI(()=>super.firstVisibleIndex)}get _lastVisibleIndex(){return this._accessIronListAPI(()=>super.lastVisibleIndex)}_scrollToIndex(index){this._accessIronListAPI(()=>this.scrollToIndex(index))}get firstVisibleIndex(){this._warnPrivateAPIAccess("firstVisibleIndex");return super.firstVisibleIndex}set firstVisibleIndex(value){this._warnPrivateAPIAccess("firstVisibleIndex");super.firstVisibleIndex=value}get lastVisibleIndex(){this._warnPrivateAPIAccess("lastVisibleIndex");return super.lastVisibleIndex}set lastVisibleIndex(value){this._warnPrivateAPIAccess("lastVisibleIndex");super.lastVisibleIndex=value}updateViewportBoundaries(){this._warnPrivateAPIAccess("updateViewportBoundaries");super.updateViewportBoundaries.apply(this,arguments)}_resizeHandler(){super._resizeHandler();Polymer.flush()}}customElements.define(GridScrollerElement.is,GridScrollerElement);/**
     * @namespace Vaadin.Grid
     */window.Vaadin=window.Vaadin||{};window.Vaadin.Grid=window.Vaadin.Grid||{};Vaadin.Grid.ScrollerElement=GridScrollerElement})();</script><script>window.Vaadin=window.Vaadin||{};Vaadin.Grid=Vaadin.Grid||{};/**
   * @polymerMixin
   */Vaadin.Grid.A11yMixin=superClass=>class A11yMixin extends superClass{static get observers(){return["_a11yUpdateGridSize(size, _columnTree, _columnTree.*)"]}_a11yGetHeaderRowCount(_columnTree){return _columnTree.filter(level=>level.some(col=>col._headerTemplate||col.headerRenderer||col.path||col.header)).length}_a11yGetFooterRowCount(_columnTree){return _columnTree.filter(level=>level.some(col=>col._headerTemplate||col.headerRenderer)).length}_a11yUpdateGridSize(size,_columnTree){if(size===void 0||_columnTree===void 0){return}const bodyColumns=_columnTree[_columnTree.length-1];this.$.table.setAttribute("aria-rowcount",size+this._a11yGetHeaderRowCount(_columnTree)+this._a11yGetFooterRowCount(_columnTree));this.$.table.setAttribute("aria-colcount",bodyColumns&&bodyColumns.length||0);this._a11yUpdateHeaderRows();this._a11yUpdateFooterRows()}_a11yUpdateHeaderRows(){Array.from(this.$.header.children).forEach((headerRow,index)=>headerRow.setAttribute("aria-rowindex",index+1))}_a11yUpdateFooterRows(){Array.from(this.$.footer.children).forEach((footerRow,index)=>footerRow.setAttribute("aria-rowindex",this._a11yGetHeaderRowCount(this._columnTree)+this.size+index+1))}_a11yUpdateRowRowindex(row,index){row.setAttribute("aria-rowindex",index+this._a11yGetHeaderRowCount(this._columnTree)+1)}_a11yUpdateRowSelected(row,selected){// Jaws reads selection only for rows, NVDA only for cells
row.setAttribute("aria-selected",!!selected);Array.from(row.children).forEach(cell=>cell.setAttribute("aria-selected",!!selected))}_a11yUpdateRowLevel(row,level){row.setAttribute("aria-level",level+1)}_a11yUpdateRowDetailsOpened(row,detailsOpened){Array.from(row.children).forEach(cell=>{if("boolean"===typeof detailsOpened){cell.setAttribute("aria-expanded",detailsOpened)}else{if(cell.hasAttribute("aria-expanded")){cell.removeAttribute("aria-expanded")}}})}_a11ySetRowDetailsCell(row,detailsCell){Array.from(row.children).forEach(cell=>{if(cell!==detailsCell){cell.setAttribute("aria-controls",detailsCell.id)}})}_a11yUpdateCellColspan(cell,colspan){cell.setAttribute("aria-colspan",+colspan)}_a11yUpdateSorters(){Array.from(this.querySelectorAll("vaadin-grid-sorter")).forEach(sorter=>{let cellContent=sorter.parentNode;while(cellContent&&"vaadin-grid-cell-content"!==cellContent.localName){cellContent=cellContent.parentNode}if(cellContent&&cellContent.assignedSlot){const cell=cellContent.assignedSlot.parentNode;cell.setAttribute("aria-sort",{asc:"ascending",desc:"descending"}[sorter.direction+""]||"none")}})}};</script><script>window.Vaadin=window.Vaadin||{};window.Vaadin.Grid=window.Vaadin.Grid||{};/**
   * @polymerMixin
   */Vaadin.Grid.ActiveItemMixin=superClass=>class ActiveItemMixin extends superClass{static get properties(){return{/**
         * The item user has last interacted with. Turns to `null` after user deactivates
         * the item by re-interacting with the currently active item.
         */activeItem:{type:Object,notify:!0,value:null}}}ready(){super.ready();this.$.scroller.addEventListener("click",this._onClick.bind(this));this.addEventListener("cell-activate",this._activateItem.bind(this))}_activateItem(e){const model=e.detail.model,clickedItem=model?model.item:null;if(clickedItem){this.activeItem=!this._itemsEqual(this.activeItem,clickedItem)?clickedItem:null}}// we need to listen to click instead of tap because on mobile safari, the
// document.activeElement has not been updated (focus has not been shifted)
// yet at the point when tap event is being executed.
_onClick(e){if(e.defaultPrevented){// Something has handled this click already, e. g., <vaadin-grid-sorter>
return}const path=e.composedPath(),cell=path[path.indexOf(this.$.table)-3];if(!cell||-1<cell.getAttribute("part").indexOf("details-cell")){return}const cellContent=cell._content,activeElement=this.getRootNode().activeElement,cellContentHasFocus=cellContent.contains(activeElement)&&(// MSIE bug: flex children receive focus. Make type & attributes check.
!this._ie||this._isFocusable(activeElement));if(!cellContentHasFocus&&!this._isFocusable(e.target)){this.dispatchEvent(new CustomEvent("cell-activate",{detail:{model:this.__getRowModel(cell.parentElement)}}))}}_isFocusable(target){if(!target.parentNode){return!1}const focusables=Array.from(target.parentNode.querySelectorAll("[tabindex], button, input, select, textarea, object, iframe, label, a[href], area[href]")).filter(element=>"cell body-cell"!==element.getAttribute("part")),isFocusableElement=-1!==focusables.indexOf(target);return!target.disabled&&isFocusableElement}};</script><script>window.Vaadin=window.Vaadin||{};window.Vaadin.Grid=window.Vaadin.Grid||{};/**
   * @polymerMixin
   */Vaadin.Grid.ArrayDataProviderMixin=superClass=>class ArrayDataProviderMixin extends superClass{static get properties(){return{/**
         * An array containing the items which will be stamped to the column template
         * instances.
         */items:Array}}static get observers(){return["_itemsChanged(items, items.*, isAttached)"]}_itemsChanged(items,splices,isAttached){if(!isAttached){return}if(!Array.isArray(items)){if(items===void 0||null===items){this.size=0}if(this.dataProvider===this._arrayDataProvider){this.dataProvider=void 0}return}this.size=items.length;this.dataProvider=this.dataProvider||this._arrayDataProvider;this.clearCache();this._ensureFirstPageLoaded()}_arrayDataProvider(opts,cb){let items=(Array.isArray(this.items)?this.items:[]).slice(0);if(this._filters&&this._checkPaths(this._filters,"filtering",items)){items=this._filter(items)}this.size=items.length;if(opts.sortOrders.length&&this._checkPaths(this._sorters,"sorting",items)){items=items.sort(this._multiSort.bind(this))}const start=opts.page*opts.pageSize,end=start+opts.pageSize,slice=items.slice(start,end);cb(slice,items.length)}/**
     * Check array of filters/sorters for paths validity, console.warn invalid items
     * @param {Array}  arrayToCheck The array of filters/sorters to check
     * @param {string} action       The name of action to include in warning (filtering, sorting)
     * @param {Array}  items
     */_checkPaths(arrayToCheck,action,items){if(!items.length){return!1}let result=!0;for(var i in arrayToCheck){const path=arrayToCheck[i].path;// skip simple paths
if(!path||-1===path.indexOf(".")){continue}const parentProperty=path.replace(/\.[^\.]*$/,"");// a.b.c -> a.b
if(Polymer.Base.get(parentProperty,items[0])===void 0){console.warn(`Path "${path}" used for ${action} does not exist in all of the items, ${action} is disabled.`);result=!1}}return result}_multiSort(a,b){return this._sorters.map(sort=>{if("asc"===sort.direction){return this._compare(Polymer.Base.get(sort.path,a),Polymer.Base.get(sort.path,b))}else if("desc"===sort.direction){return this._compare(Polymer.Base.get(sort.path,b),Polymer.Base.get(sort.path,a))}return 0}).reduce((p,n)=>{return p?p:n},0)}_normalizeEmptyValue(value){if(0<=[void 0,null].indexOf(value)){return""}else if(isNaN(value)){return value.toString()}else{return value}}_compare(a,b){a=this._normalizeEmptyValue(a);b=this._normalizeEmptyValue(b);if(a<b){return-1}if(a>b){return 1}return 0}_filter(items){return items.filter((item,index)=>{return 0===this._filters.filter(filter=>{const value=this._normalizeEmptyValue(Polymer.Base.get(filter.path,item)),filterValueLowercase=this._normalizeEmptyValue(filter.value).toString().toLowerCase();return-1===value.toString().toLowerCase().indexOf(filterValueLowercase)}).length})}};</script><script>window.Vaadin=window.Vaadin||{};window.Vaadin.Grid=window.Vaadin.Grid||{};/**
   * @polymerMixin
   */Vaadin.Grid.ColumnResizingMixin=superClass=>class ColumnResizingMixin extends Polymer.GestureEventListeners(superClass){ready(){super.ready();const scroller=this.$.scroller;Polymer.Gestures.addListener(scroller,"track",this._onHeaderTrack.bind(this));// Disallow scrolling while resizing
scroller.addEventListener("touchmove",e=>scroller.hasAttribute("column-resizing")&&e.preventDefault());// Disable contextmenu on any resize separator.
scroller.addEventListener("contextmenu",e=>"resize-handle"==e.target.getAttribute("part")&&e.preventDefault());// Disable native cell focus when resizing
scroller.addEventListener("mousedown",e=>"resize-handle"===e.target.getAttribute("part")&&e.preventDefault())}_onHeaderTrack(e){const handle=e.target;if("resize-handle"===handle.getAttribute("part")){const cell=handle.parentElement;let column=cell._column;this._toggleAttribute("column-resizing",!0,this.$.scroller);// Get the target column to resize
while("vaadin-grid-column-group"===column.localName){column=Array.prototype.slice.call(column._childColumns,0).sort(function(a,b){return a._order-b._order}).filter(function(column){return!column.hidden}).pop()}const columnRowCells=Array.from(this.$.header.querySelectorAll("[part~=\"row\"]:last-child [part~=\"cell\"]"));var targetCell=columnRowCells.filter(cell=>cell._column===column)[0];// Resize the target column
if(targetCell.offsetWidth){var style=window.getComputedStyle(targetCell),minWidth=10+parseInt(style.paddingLeft)+parseInt(style.paddingRight)+parseInt(style.borderLeftWidth)+parseInt(style.borderRightWidth)+parseInt(style.marginLeft)+parseInt(style.marginRight);const maxWidth=targetCell.offsetWidth+(this.__isRTL?targetCell.getBoundingClientRect().left-e.detail.x:e.detail.x-targetCell.getBoundingClientRect().right);column.width=Math.max(minWidth,maxWidth)+"px";column.flexGrow=0}// Fix width and flex-grow for all preceding columns
columnRowCells.sort(function(a,b){return a._column._order-b._column._order}).forEach(function(cell,index,array){if(index<array.indexOf(targetCell)){cell._column.width=cell.offsetWidth+"px";cell._column.flexGrow=0}});if("end"===e.detail.state){this._toggleAttribute("column-resizing",!1,this.$.scroller);this.dispatchEvent(new CustomEvent("column-resize",{detail:{resizedColumn:column}}))}// Notify resize
this._resizeHandler()}}/**
    * Fired when a column in the grid is resized by the user.
    *
    * @event column-resize
    * @param {Object} detail
    * @param {Object} detail.resizedColumn the column that was resized
    */};</script><script>window.Vaadin=window.Vaadin||{};window.Vaadin.Grid=window.Vaadin.Grid||{};Vaadin.Grid.ItemCache=class ItemCache{constructor(grid,parentCache,parentItem){this.grid=grid;this.parentCache=parentCache;this.parentItem=parentItem;this.itemCaches={};this.items={};this.effectiveSize=0;this.size=0;this.pendingRequests={}}isLoading(){return Object.keys(this.pendingRequests).length||Object.keys(this.itemCaches).filter(index=>{return this.itemCaches[index].isLoading()})[0]}getItemForIndex(index){const{cache,scaledIndex}=this.getCacheAndIndex(index);return cache.items[scaledIndex]}updateSize(){this.effectiveSize=!this.parentItem||this.grid._isExpanded(this.parentItem)?this.size+Object.keys(this.itemCaches).reduce((prev,curr)=>{const subCache=this.itemCaches[curr];subCache.updateSize();return prev+subCache.effectiveSize},0):0}ensureSubCacheForScaledIndex(scaledIndex){if(!this.itemCaches[scaledIndex]){const subCache=new Vaadin.Grid.ItemCache(this.grid,this,this.items[scaledIndex]);this.itemCaches[scaledIndex]=subCache;this.grid._loadPage(0,subCache)}}getCacheAndIndex(index){let thisLevelIndex=index;const keys=Object.keys(this.itemCaches);for(var i=0;i<keys.length;i++){const expandedIndex=+keys[i],subCache=this.itemCaches[expandedIndex];if(thisLevelIndex<=expandedIndex){return{cache:this,scaledIndex:thisLevelIndex}}else if(thisLevelIndex<=expandedIndex+subCache.effectiveSize){return subCache.getCacheAndIndex(thisLevelIndex-expandedIndex-1)}thisLevelIndex-=subCache.effectiveSize}return{cache:this,scaledIndex:thisLevelIndex}}};/**
   * @polymerMixin
   */Vaadin.Grid.DataProviderMixin=superClass=>class DataProviderMixin extends superClass{static get properties(){return{/**
         * Number of items fetched at a time from the dataprovider.
         */pageSize:{type:Number,value:50,observer:"_pageSizeChanged"},/**
         * Function that provides items lazily. Receives arguments `params`, `callback`
         *
         * `params.page` Requested page index
         *
         * `params.pageSize` Current page size
         *
         * `params.filters` Currently applied filters
         *
         * `params.sortOrders` Currently applied sorting orders
         *
         * `params.parentItem` When tree is used, and sublevel items
         * are requested, reference to parent item of the requested sublevel.
         * Otherwise `undefined`.
         *
         * `callback(items, size)` Callback function with arguments:
         *   - `items` Current page of items
         *   - `size` Total number of items. When tree sublevel items
         *     are requested, total number of items in the requested sublevel.
         *     Optional when tree is not used, required for tree.
         */dataProvider:{type:Object,notify:!0,observer:"_dataProviderChanged"},/**
         * `true` while data is being requested from the data provider.
         */loading:{type:Boolean,notify:!0,readOnly:!0,reflectToAttribute:!0},_cache:{type:Object,value:function(){const cache=new Vaadin.Grid.ItemCache(this);return cache}},/**
         * Path to an item sub-property that identifies the item.
         */itemIdPath:{type:String,value:null},/**
         * An array that contains the expanded items.
         */expandedItems:{type:Object,notify:!0,value:()=>[]}}}static get observers(){return["_sizeChanged(size)","_itemIdPathChanged(itemIdPath)","_expandedItemsChanged(expandedItems.*)"]}_sizeChanged(size){const delta=size-this._cache.size;this._cache.size+=delta;this._cache.effectiveSize+=delta;this._effectiveSize=this._cache.effectiveSize}_getItem(index,el){if(index>=this._effectiveSize){return}el.index=index;const{cache,scaledIndex}=this._cache.getCacheAndIndex(index),item=cache.items[scaledIndex];if(item){this._toggleAttribute("loading",!1,el);this._updateItem(el,item);if(this._isExpanded(item)){cache.ensureSubCacheForScaledIndex(scaledIndex)}}else{this._toggleAttribute("loading",!0,el);this._loadPage(this._getPageForIndex(scaledIndex),cache)}}_expandedInstanceChangedCallback(inst,value){if(inst.item===void 0){return}if(value){this.expandItem(inst.item)}else{this.collapseItem(inst.item)}}/**
     * Returns a value that identifies the item. Uses `itemIdPath` if available.
     * Can be customized by overriding.
     */getItemId(item){return this.itemIdPath?this.get(this.itemIdPath,item):item}_isExpanded(item){return this.__expandedKeys.has(this.getItemId(item))}_expandedItemsChanged(e){this.__cacheExpandedKeys();this._cache.updateSize();this._effectiveSize=this._cache.effectiveSize;this._assignModels()}_itemIdPathChanged(e){this.__cacheExpandedKeys()}__cacheExpandedKeys(){if(this.expandedItems){this.__expandedKeys=new Set;this.expandedItems.forEach(item=>{this.__expandedKeys.add(this.getItemId(item))})}}/**
     * Expands the given item tree.
     */expandItem(item){if(!this._isExpanded(item)){this.push("expandedItems",item)}}/**
     * Collapses the given item tree.
     */collapseItem(item){if(this._isExpanded(item)){this.splice("expandedItems",this._getItemIndexInArray(item,this.expandedItems),1)}}_getIndexLevel(index){let{cache}=this._cache.getCacheAndIndex(index),level=0;while(cache.parentCache){cache=cache.parentCache;level++}return level}_canPopulate(){return this._hasData&&this._columnTree}_loadPage(page,cache){// make sure same page isn't requested multiple times.
if(!cache.pendingRequests[page]&&this.dataProvider){this._setLoading(!0);cache.pendingRequests[page]=!0;const params={page,pageSize:this.pageSize,sortOrders:this._mapSorters(),filters:this._mapFilters(),parentItem:cache.parentItem};this.dataProvider(params,(items,size)=>{if(size!==void 0){cache.size=size}else{if(params.parentItem){cache.size=items.length}}const currentItems=Array.from(this.$.items.children).map(row=>row._item);// Populate the cache with new items
items.forEach((item,itemsIndex)=>{const itemIndex=page*this.pageSize+itemsIndex;cache.items[itemIndex]=item;if(this._isExpanded(item)&&-1<currentItems.indexOf(item)){// Force synchronous data request for expanded item sub-cache
cache.ensureSubCacheForScaledIndex(itemIndex)}});this._hasData=!0;delete cache.pendingRequests[page];this._setLoading(!1);this._cache.updateSize();this._effectiveSize=this._cache.effectiveSize;Array.from(this.$.items.children).filter(row=>!row.hidden).forEach(row=>{const cachedItem=this._cache.getItemForIndex(row.index);if(cachedItem){this._toggleAttribute("loading",!1,row);this._updateItem(row,cachedItem)}});this._increasePoolIfNeeded(0);this.__itemsReceived()})}}_getPageForIndex(index){return Math.floor(index/this.pageSize)}/**
     * Clears the cached pages and reloads data from dataprovider when needed.
     */clearCache(){this._cache=new Vaadin.Grid.ItemCache(this);Array.from(this.$.items.children).forEach(row=>{Array.from(row.children).forEach(cell=>{// Force data system to pick up subproperty changes
cell._instance&&cell._instance._setPendingProperty("item",{},!1)})});this._cache.size=this.size||0;this._cache.updateSize();this._hasData=!1;this._assignModels();if(!this._effectiveSize){this._loadPage(0,this._cache)}}_pageSizeChanged(pageSize,oldPageSize){if(oldPageSize!==void 0&&pageSize!==oldPageSize){this.clearCache()}}_checkSize(){if(this.size===void 0&&0===this._effectiveSize){console.warn("The <vaadin-grid> needs the total number of items"+" in order to display rows. Set the total number of items"+" to the `size` property, or provide the total number of items"+" in the second argument of the `dataProvider`\u2019s `callback` call.")}}_dataProviderChanged(dataProvider,oldDataProvider){if(oldDataProvider!==void 0){this.clearCache()}if(dataProvider&&this.items&&this.items.length){// Fixes possibly invalid cached lastVisibleIndex value in <iron-list>
this._scrollToIndex(this._firstVisibleIndex)}this._ensureFirstPageLoaded();this._debouncerCheckSize=Polymer.Debouncer.debounce(this._debouncerCheckSize,Polymer.Async.timeOut.after(2e3),this._checkSize.bind(this));this._scrollHandler()}_ensureFirstPageLoaded(){if(!this._hasData){// load data before adding rows to make sure they have content when
// rendered for the first time.
this._loadPage(0,this._cache,()=>{const hadData=this._hasData;this._hasData=!0;if(!hadData){this.notifyResize()}})}}_itemsEqual(item1,item2){return this.getItemId(item1)===this.getItemId(item2)}_getItemIndexInArray(item,array){let result=-1;array.forEach((i,idx)=>{if(this._itemsEqual(i,item)){result=idx}});return result}};</script><script>window.Vaadin=window.Vaadin||{};window.Vaadin.Grid=window.Vaadin.Grid||{};/**
   * @polymerMixin
   */Vaadin.Grid.DynamicColumnsMixin=superClass=>class DynamicColumnsMixin extends superClass{ready(){super.ready();this._addNodeObserver()}_hasColumnGroups(columns){for(let i=0;i<columns.length;i++){if("vaadin-grid-column-group"===columns[i].localName){return!0}}return!1}_getChildColumns(el){return Polymer.FlattenedNodesObserver.getFlattenedNodes(el).filter(this._isColumnElement)}_flattenColumnGroups(columns){return columns.map(col=>{if("vaadin-grid-column-group"===col.localName){return this._getChildColumns(col)}else{return[col]}}).reduce((prev,curr)=>{return prev.concat(curr)},[])}_getColumnTree(){for(var rootColumns=Polymer.FlattenedNodesObserver.getFlattenedNodes(this).filter(this._isColumnElement),_columnTree=[],c=rootColumns;;){_columnTree.push(c);if(!this._hasColumnGroups(c)){break}c=this._flattenColumnGroups(c)}return _columnTree}_updateColumnTree(){var columnTree=this._getColumnTree();if(!this._arrayEquals(columnTree,this._columnTree)){this._columnTree=columnTree}}_addNodeObserver(){this._observer=new Polymer.FlattenedNodesObserver(this,info=>{const rowDetailsTemplate=info.addedNodes.filter(n=>"template"===n.localName&&n.classList.contains("row-details"))[0];if(rowDetailsTemplate&&this._rowDetailsTemplate!==rowDetailsTemplate){this._rowDetailsTemplate=rowDetailsTemplate}if(0<info.addedNodes.filter(this._isColumnElement).length||0<info.removedNodes.filter(this._isColumnElement).length){this._updateColumnTree()}this._debouncerCheckImports=Polymer.Debouncer.debounce(this._debouncerCheckImports,Polymer.Async.timeOut.after(2e3),this._checkImports.bind(this));this._ensureFirstPageLoaded()})}_arrayEquals(arr1,arr2){if(!arr1||!arr2||arr1.length!=arr2.length){return!1}for(var i=0,l=arr1.length;i<l;i++){// Check if we have nested arrays
if(arr1[i]instanceof Array&&arr2[i]instanceof Array){// recurse into the nested arrays
if(!this._arrayEquals(arr1[i],arr2[i])){return!1}}else if(arr1[i]!=arr2[i]){return!1}}return!0}_checkImports(){["vaadin-grid-column-group","vaadin-grid-filter","vaadin-grid-filter-column","vaadin-grid-tree-toggle","vaadin-grid-selection-column","vaadin-grid-sort-column","vaadin-grid-sorter"].forEach(elementName=>{var element=this.querySelector(elementName);if(element&&!(element instanceof Polymer.Element)){console.warn(`Make sure you have imported the required module for <${elementName}> element.`)}})}_updateFirstAndLastColumn(){Array.from(this.shadowRoot.querySelectorAll("tr")).forEach(row=>this._updateFirstAndLastColumnForRow(row))}_updateFirstAndLastColumnForRow(row){Array.from(row.querySelectorAll("[part~=\"cell\"]:not([part~=\"details-cell\"])")).sort((a,b)=>{return a._column._order-b._column._order}).forEach((cell,cellIndex,children)=>{this._toggleAttribute("first-column",0===cellIndex,cell);this._toggleAttribute("last-column",cellIndex===children.length-1,cell)})}_isColumnElement(node){return node.nodeType===Node.ELEMENT_NODE&&/\bcolumn\b/.test(node.localName)}};</script><script>window.Vaadin=window.Vaadin||{};window.Vaadin.Grid=window.Vaadin.Grid||{};/**
   * @polymerMixin
   */Vaadin.Grid.EventContextMixin=superClass=>class EventContextMixin extends superClass{/**
     * Returns an object with context information about the event target:
     * - `item`: the data object corresponding to the targeted row (not specified when targeting header or footer)
     * - `column`: the column element corresponding to the targeted cell (not specified when targeting row details)
     * - `section`: whether the event targeted the body, header, footer or details of the grid
     *
     * These additional properties are included when `item` is specified:
     * - `index`: the index of the item
     * - `selected`: the selected state of the item
     * - `detailsOpened`: whether the row details are open for the item
     * - `expanded`: the expanded state of the tree toggle
     * - `level`: the tree hierarchy level
     *
     * The returned object is populated only when a grid cell, header, footer or row details is found in `event.composedPath()`.
     * This means mostly mouse and keyboard events. If such a grid part is not found in the path, an empty object is returned.
     * This may be the case eg. if the event is fired on the `<vaadin-grid>` element and not any deeper in the DOM, or if
     * the event targets the empty part of the grid body.
     */getEventContext(event){const context={},path=event.composedPath(),cell=path[path.indexOf(this.$.table)-3];if(!cell){return context}context.section=["body","header","footer","details"].filter(section=>-1<cell.getAttribute("part").indexOf(section))[0];if(cell._column){context.column=cell._column}if("body"===context.section||"details"===context.section){Object.assign(context,this.__getRowModel(cell.parentElement))}return context}};</script><script>window.Vaadin=window.Vaadin||{};window.Vaadin.Grid=window.Vaadin.Grid||{};/**
   * @polymerMixin
   */Vaadin.Grid.FilterMixin=superClass=>class FilterMixin extends superClass{static get properties(){return{_filters:{type:Array,value:function(){return[]}}}}ready(){super.ready();this.addEventListener("filter-changed",this._filterChanged.bind(this))}_filterChanged(e){if(-1===this._filters.indexOf(e.target)){this._filters.push(e.target)}e.stopPropagation();if(this.dataProvider){this.clearCache()}}_mapFilters(){return this._filters.map(filter=>{return{path:filter.path,value:filter.value}})}};</script><script>(function(){/**
     * `vaadin-grid-templatizer` is a helper element for the `vaadin-grid` that is preparing and
     * stamping instances of cells and columns templates
     *
     * @memberof Vaadin
     * @private
     */class GridTemplatizer extends class extends Polymer.Element{}{static get is(){return"vaadin-grid-templatizer"}static get properties(){return{dataHost:Object,template:Object,_templateInstances:{type:Array,value:function(){return[]}},_parentPathValues:{value:function(){return{}}},_grid:Object}}static get observers(){return["_templateInstancesChanged(_templateInstances.*, _parentPathValues.*)"]}constructor(){super();this._instanceProps={detailsOpened:!0,index:!0,item:!0,selected:!0,expanded:!0,level:!0}}createInstance(){this._ensureTemplatized();const instance=new this._TemplateClass({});this.addInstance(instance);return instance}addInstance(instance){if(-1===this._templateInstances.indexOf(instance)){this._templateInstances.push(instance);requestAnimationFrame(()=>this.notifyPath("_templateInstances.*",this._templateInstances))}}removeInstance(instance){const index=this._templateInstances.indexOf(instance);this.splice("_templateInstances",index,1)}_ensureTemplatized(){if(!this._TemplateClass){this._TemplateClass=Polymer.Templatize.templatize(this.template,this,{instanceProps:this._instanceProps,parentModel:!0,forwardHostProp:function(prop,value){this._forwardParentProp(prop,value);if(this._templateInstances){this._templateInstances.forEach(inst=>inst.notifyPath(prop,value))}},notifyInstanceProp:function(inst,prop,value){if("index"===prop||"item"===prop){// We don’t need a change notification for these.
return}const originalProp=`__${prop}__`;// Notify for only user-action changes, not for scrolling updates. E. g.,
// if `detailsOpened` is different from `__detailsOpened__`, which was set during render.
if(inst[originalProp]===value){return}inst[originalProp]=value;const row=Array.from(this._grid.$.items.children).filter(row=>this._grid._itemsEqual(row._item,inst.item))[0];if(row){Array.from(row.children).forEach(cell=>{if(cell._instance){cell._instance[originalProp]=value;cell._instance.notifyPath(prop,value)}})}const itemPrefix="item.";if(Array.isArray(this._grid.items)&&0===prop.indexOf(itemPrefix)){const itemsIndex=this._grid.items.indexOf(inst.item),path=prop.slice(itemPrefix.length);this._grid.notifyPath(`items.${itemsIndex}.${path}`,value)}const gridCallback=`_${prop}InstanceChangedCallback`;if(this._grid&&this._grid[gridCallback]){this._grid[gridCallback](inst,value)}}})}}_forwardParentProp(prop,value){this._parentPathValues[prop]=value;this._templateInstances.forEach(inst=>inst.notifyPath(prop,value))}_templateInstancesChanged(t,p){let index,count;if("_templateInstances"===t.path){// Iterate all instances
index=0;count=this._templateInstances.length}else if("_templateInstances.splices"===t.path){// Iterate only new instances
index=t.value.index;count=t.value.addedCount}else{return}Object.keys(this._parentPathValues||{}).forEach(keyName=>{for(var i=index;i<index+count;i++){this._templateInstances[i].set(keyName,this._parentPathValues[keyName])}})}}customElements.define(GridTemplatizer.is,GridTemplatizer);/**
     * @namespace Vaadin.Grid
     */window.Vaadin=window.Vaadin||{};window.Vaadin.Grid=window.Vaadin.Grid||{};Vaadin.Grid.Templatizer=GridTemplatizer})();</script><script>window.Vaadin=window.Vaadin||{};Vaadin.Grid=Vaadin.Grid||{};/**
   * @polymerMixin
   */Vaadin.Grid.RowDetailsMixin=superClass=>class RowDetailsMixin extends superClass{static get properties(){return{/**
         * An array containing references to items with open row details.
         */detailsOpenedItems:{type:Array,value:function(){return[]}},_rowDetailsTemplate:Object,/**
         * Custom function for rendering the content of the row details.
         * Receives three arguments:
         *
         * - `root` The row details content DOM element. Append your content to it.
         * - `grid` The `<vaadin-grid>` element.
         * - `rowData` The object with the properties related with
         *   the rendered item, contains:
         *   - `rowData.index` The index of the item.
         *   - `rowData.item` The item.
         */rowDetailsRenderer:Function,_detailsCells:{type:Array}}}static get observers(){return["_detailsOpenedItemsChanged(detailsOpenedItems.*, _rowDetailsTemplate, rowDetailsRenderer)","_rowDetailsTemplateOrRendererChanged(_rowDetailsTemplate, rowDetailsRenderer)"]}_rowDetailsTemplateOrRendererChanged(rowDetailsTemplate,rowDetailsRenderer){if(rowDetailsTemplate&&rowDetailsRenderer){throw new Error("You should only use either a renderer or a template for row details")}if(rowDetailsTemplate||rowDetailsRenderer){if(rowDetailsTemplate&&!rowDetailsTemplate.templatizer){var templatizer=new Vaadin.Grid.Templatizer;templatizer._grid=this;templatizer.dataHost=this.dataHost;templatizer.template=rowDetailsTemplate;rowDetailsTemplate.templatizer=templatizer}if(this._columnTree){// Only update the rows if the column tree has already been initialized
Array.from(this.$.items.children).forEach(row=>{if(!row.querySelector("[part~=details-cell]")){this._updateRow(row,this._columnTree[this._columnTree.length-1]);this._a11yUpdateRowDetailsOpened(row,!1)}// Clear any old template instances
delete row.querySelector("[part~=details-cell]")._instance})}if(this.detailsOpenedItems.length){Array.from(this.$.items.children).forEach(this._toggleDetailsCell,this);this._update()}}}_detailsOpenedItemsChanged(changeRecord,rowDetailsTemplate,rowDetailsRenderer){if("detailsOpenedItems.length"===changeRecord.path||!changeRecord.value){// Let’s avoid duplicate work of both “.splices” and “.length” updates.
return}Array.from(this.$.items.children).forEach(row=>{this._toggleDetailsCell(row,row._item);this._a11yUpdateRowDetailsOpened(row,this._isDetailsOpened(row._item));this._toggleAttribute("details-opened",this._isDetailsOpened(row._item),row)})}_configureDetailsCell(cell){cell.setAttribute("part","cell details-cell");// Freeze the details cell, so that it does not scroll horizontally
// with the normal cells. This way it looks less weird.
this._toggleAttribute("frozen",!0,cell)}_toggleDetailsCell(row,item){const cell=row.querySelector("[part~=\"details-cell\"]");if(!cell){return}const detailsHidden=!this._isDetailsOpened(item),hiddenChanged=!!cell.hidden!==detailsHidden;if(!cell._instance&&!cell._renderer||cell.hidden!==detailsHidden){cell.hidden=detailsHidden;if(detailsHidden){row.style.removeProperty("padding-bottom")}else{if(this.rowDetailsRenderer){cell._renderer=this.rowDetailsRenderer;cell._renderer.call(this,cell._content,this,{index:row.index,item:item})}else if(this._rowDetailsTemplate&&!cell._instance){// Stamp the template
cell._instance=this._rowDetailsTemplate.templatizer.createInstance();cell._content.innerHTML="";cell._content.appendChild(cell._instance.root);this._updateItem(row,item)}Polymer.flush();row.style.setProperty("padding-bottom",`${cell.offsetHeight}px`);requestAnimationFrame(()=>this.notifyResize())}}if(hiddenChanged){this._updateMetrics();this._positionItems()}}_updateDetailsCellHeights(){Array.from(this.$.items.querySelectorAll("[part~=\"details-cell\"]:not([hidden])")).forEach(cell=>{cell.parentElement.style.setProperty("padding-bottom",`${cell.offsetHeight}px`)})}_isDetailsOpened(item){return this.detailsOpenedItems&&-1!==this._getItemIndexInArray(item,this.detailsOpenedItems)}/**
     * Open the details row of a given item.
     */openItemDetails(item){if(!this._isDetailsOpened(item)){this.push("detailsOpenedItems",item)}}/**
     * Close the details row of a given item.
     */closeItemDetails(item){if(this._isDetailsOpened(item)){this.splice("detailsOpenedItems",this._getItemIndexInArray(item,this.detailsOpenedItems),1)}}_detailsOpenedInstanceChangedCallback(instance,value){if(super._detailsOpenedInstanceChangedCallback){super._detailsOpenedInstanceChangedCallback(instance,value)}if(value){this.openItemDetails(instance.item)}else{this.closeItemDetails(instance.item)}}};</script><script>window.Vaadin=window.Vaadin||{};Vaadin.Grid=Vaadin.Grid||{};/**
   * @polymerMixin
   */Vaadin.Grid.ScrollMixin=superClass=>class ScrollMixin extends superClass{get _timeouts(){return{SCROLL_PERIOD:1e3,WHEEL_SCROLLING:200,SCROLLING:100,IGNORE_WHEEL:500}}static get properties(){return{// Cached array of frozen cells
_frozenCells:{type:Array,value:function(){return[]}},_scrollbarWidth:{type:Number,value:function(){// Create the measurement node
var scrollDiv=document.createElement("div");scrollDiv.style.width="100px";scrollDiv.style.height="100px";scrollDiv.style.overflow="scroll";scrollDiv.style.position="absolute";scrollDiv.style.top="-9999px";document.body.appendChild(scrollDiv);// Get the scrollbar width
var scrollbarWidth=scrollDiv.offsetWidth-scrollDiv.clientWidth;// Delete the DIV
document.body.removeChild(scrollDiv);return scrollbarWidth}},_rowWithFocusedElement:Element,_deltaYAcc:{type:Number,value:0}}}static get observers(){return["_scrollHeightUpdated(_estScrollHeight)","_scrollViewportHeightUpdated(_viewportHeight)"]}// Override (from iron-scroll-target-behavior) to avoid document scroll
set _scrollTop(top){this.$.table.scrollTop=top}get _scrollTop(){return this.$.table.scrollTop}constructor(){super();this._scrollLineHeight=this._getScrollLineHeight()}/**
     * @returns {Number|undefined} - The browser's default font-size in pixels
     */_getScrollLineHeight(){const el=document.createElement("div");el.style.fontSize="initial";el.style.display="none";document.body.appendChild(el);const fontSize=window.getComputedStyle(el).fontSize;document.body.removeChild(el);return fontSize?window.parseInt(fontSize):void 0}_scrollViewportHeightUpdated(_viewportHeight){this._scrollPageHeight=_viewportHeight-this.$.header.clientHeight-this.$.footer.clientHeight-this._scrollLineHeight}ready(){super.ready();this.scrollTarget=this.$.table;this.addEventListener("wheel",e=>{this._wheelScrolling=!0;this._debouncerWheelScrolling=Polymer.Debouncer.debounce(this._debouncerWheelScrolling,Polymer.Async.timeOut.after(this._timeouts.WHEEL_SCROLLING),()=>this._wheelScrolling=!1);this._onWheel(e)});this.$.table.addEventListener("scroll",e=>{if(this.$.outerscroller.outerScrolling){e.stopImmediatePropagation()}},!0);this.$.items.addEventListener("focusin",e=>{const itemsIndex=e.composedPath().indexOf(this.$.items);this._rowWithFocusedElement=e.composedPath()[itemsIndex-1]});this.$.items.addEventListener("focusout",()=>this._rowWithFocusedElement=void 0)}/**
     * Scroll to a specific row index in the virtual list. Note that the row index is
     * not always the same for any particular item. For example, sorting/filtering/expanding
     * or collapsing hierarchical items can affect the row index related to an item.
     *
     * @param {number} index Row index to scroll to
     */scrollToIndex(index){this._accessIronListAPI(()=>super.scrollToIndex(index))}_onWheel(e){if(e.ctrlKey||this._hasScrolledAncestor(e.target,e.deltaX,e.deltaY)){return}const table=this.$.table;let deltaY=e.deltaY;if(e.deltaMode===WheelEvent.DOM_DELTA_LINE){// Scrolling by "lines of text" instead of pixels
deltaY*=this._scrollLineHeight}else if(e.deltaMode===WheelEvent.DOM_DELTA_PAGE){// Scrolling by "pages" instead of pixels
deltaY*=this._scrollPageHeight}if(this._wheelAnimationFrame){// Skip new wheel events while one is being processed
this._deltaYAcc+=deltaY;e.preventDefault();return}deltaY+=this._deltaYAcc;this._deltaYAcc=0;this._wheelAnimationFrame=!0;this._debouncerWheelAnimationFrame=Polymer.Debouncer.debounce(this._debouncerWheelAnimationFrame,Polymer.Async.animationFrame,()=>this._wheelAnimationFrame=!1);var momentum=Math.abs(e.deltaX)+Math.abs(deltaY);if(this._canScroll(table,e.deltaX,deltaY)){e.preventDefault();table.scrollTop+=deltaY;table.scrollLeft+=e.deltaX;this._scrollHandler();this._hasResidualMomentum=!0;this._ignoreNewWheel=!0;this._debouncerIgnoreNewWheel=Polymer.Debouncer.debounce(this._debouncerIgnoreNewWheel,Polymer.Async.timeOut.after(this._timeouts.IGNORE_WHEEL),()=>this._ignoreNewWheel=!1)}else if(this._hasResidualMomentum&&momentum<=this._previousMomentum||this._ignoreNewWheel){e.preventDefault()}else if(momentum>this._previousMomentum){this._hasResidualMomentum=!1}this._previousMomentum=momentum}/**
     * Determines if the element has an ancestor prior to this
     * cell content that handles the scroll delta
     */_hasScrolledAncestor(el,deltaX,deltaY){if("vaadin-grid-cell-content"===el.localName){return!1}else if(this._canScroll(el,deltaX,deltaY)&&-1!==["auto","scroll"].indexOf(getComputedStyle(el).overflow)){return!0}else if(el!==this&&el.parentElement){return this._hasScrolledAncestor(el.parentElement,deltaX,deltaY)}}/**
     * Determines if the the given scroll deltas can be applied to the element
     * (fully or partially)
     */_canScroll(el,deltaX,deltaY){return 0<deltaY&&el.scrollTop<el.scrollHeight-el.offsetHeight||0>deltaY&&0<el.scrollTop||0<deltaX&&el.scrollLeft<el.scrollWidth-el.offsetWidth||0>deltaX&&0<el.scrollLeft}_scheduleScrolling(){if(!this._scrollingFrame){// Defer setting state attributes to avoid Edge hiccups
this._scrollingFrame=requestAnimationFrame(()=>this._toggleAttribute("scrolling",!0,this.$.scroller))}this._debounceScrolling=Polymer.Debouncer.debounce(this._debounceScrolling,Polymer.Async.timeOut.after(this._timeouts.SCROLLING),()=>{cancelAnimationFrame(this._scrollingFrame);delete this._scrollingFrame;this._toggleAttribute("scrolling",!1,this.$.scroller);if(!this.$.outerscroller.outerScrolling){this._reorderRows()}});if(!this._scrollPeriodFrame){this._scrollPeriodFrame=requestAnimationFrame(()=>this._toggleAttribute("scroll-period",!0,this.$.scroller))}this._debounceScrollPeriod=Polymer.Debouncer.debounce(this._debounceScrollPeriod,Polymer.Async.timeOut.after(this._timeouts.SCROLL_PERIOD),()=>{cancelAnimationFrame(this._scrollPeriodFrame);delete this._scrollPeriodFrame;this._toggleAttribute("scroll-period",!1,this.$.scroller)})}_afterScroll(){this._translateStationaryElements();if(!this.hasAttribute("reordering")){this._scheduleScrolling()}const os=this.$.outerscroller;if(!this._ios&&(this._wheelScrolling||os.passthrough)){os.syncOuterScroller()}if(this._ios){// Enable vertical rubberband feedback
const overScroll=Math.max(-os.scrollTop,0)||Math.min(0,os.scrollHeight-os.scrollTop-os.offsetHeight);this.$.items.style.transform=`translateY(${overScroll}px)`}this._updateOverflow()}_updateOverflow(){// Set overflow styling attributes
let overflow="";const table=this.$.table;if(table.scrollTop<table.scrollHeight-table.clientHeight){overflow+=" bottom"}if(0<table.scrollTop){overflow+=" top"}if(table.scrollLeft<table.scrollWidth-table.clientWidth){overflow+=" right"}if(0<table.scrollLeft){overflow+=" left"}this._debounceOverflow=Polymer.Debouncer.debounce(this._debounceOverflow,Polymer.Async.animationFrame,()=>{const value=overflow.trim();if(0<value.length&&this.getAttribute("overflow")!==value){this.setAttribute("overflow",value)}else if(0==value.length&&this.hasAttribute("overflow")){this.removeAttribute("overflow")}})}// correct order needed for preserving correct tab order between cell contents.
_reorderRows(){const body=this.$.items,items=body.querySelectorAll("tr");if(!items.length){return}const adjustedVirtualStart=this._virtualStart+this._vidxOffset,targetRow=this._rowWithFocusedElement||Array.from(items).filter(row=>!row.hidden)[0];// Which row to use as a target?
if(!targetRow){// All rows are hidden, don't reorder
return}// Where the target row should be?
const targetPhysicalIndex=targetRow.index-adjustedVirtualStart,delta=Array.from(items).indexOf(targetRow)-targetPhysicalIndex;// Reodrer the DOM elements to keep the target row at the target physical index
if(0<delta){for(let i=0;i<delta;i++){body.appendChild(items[i])}}else if(0>delta){for(let i=items.length+delta;i<items.length;i++){body.insertBefore(items[i],items[0])}}}_frozenCellsChanged(){this._debouncerCacheElements=Polymer.Debouncer.debounce(this._debouncerCacheElements,Polymer.Async.microTask,()=>{Array.from(this.root.querySelectorAll("[part~=\"cell\"]")).forEach(function(cell){cell.style.transform=""});this._frozenCells=Array.prototype.slice.call(this.$.table.querySelectorAll("[frozen]"));this._updateScrollerMeasurements();this._translateStationaryElements()});this._updateLastFrozen()}_updateScrollerMeasurements(){if(0<this._frozenCells.length&&this.__isRTL){this.__scrollerMetrics={scrollWidth:this.$.outerscroller.scrollWidth,clientWidth:this.$.outerscroller.clientWidth}}}_updateLastFrozen(){if(!this._columnTree){return}const columnsRow=this._columnTree[this._columnTree.length-1].slice(0);columnsRow.sort((a,b)=>{return a._order-b._order});const lastFrozen=columnsRow.reduce((prev,col,index)=>{col._lastFrozen=!1;return col.frozen&&!col.hidden?index:prev},void 0);if(lastFrozen!==void 0){columnsRow[lastFrozen]._lastFrozen=!0}}_translateStationaryElements(){if(this._edge&&!this._scrollbarWidth){// Fixed mode (Tablet Edge)
this.$.items.style.transform=this._getTranslate(-this._scrollLeft||0,-this._scrollTop||0);this.$.footer.style.transform=this.$.header.style.transform=this._getTranslate(-this._scrollLeft||0,0)}else{this.$.footer.style.transform=this.$.header.style.transform=this._getTranslate(0,this._scrollTop)}if(0<this._frozenCells.length){const x=this.__isRTL?this.__getNormalizedScrollLeft(this.$.table)+this.__scrollerMetrics.clientWidth-this.__scrollerMetrics.scrollWidth:this._scrollLeft;for(var frozenCellTransform=this._getTranslate(x,0),i=0;i<this._frozenCells.length;i++){this._frozenCells[i].style.transform=frozenCellTransform}}}_getTranslate(x,y){return"translate("+x+"px,"+y+"px)"}_scrollHeightUpdated(_estScrollHeight){this.$.outersizer.style.top=this.$.fixedsizer.style.top=_estScrollHeight+"px"}};</script><script>window.Vaadin=window.Vaadin||{};Vaadin.Grid=Vaadin.Grid||{};/**
   * @polymerMixin
   */Vaadin.Grid.SelectionMixin=superClass=>class SelectionMixin extends superClass{static get properties(){return{/**
         * An array that contains the selected items.
         */selectedItems:{type:Object,notify:!0,value:()=>[]}}}static get observers(){return["_selectedItemsChanged(selectedItems.*)"]}_isSelected(item){return this.selectedItems&&-1<this._getItemIndexInArray(item,this.selectedItems)}/**
     * Selects the given item.
     *
     * @method selectItem
     * @param {Object} item The item object
     */selectItem(item){if(!this._isSelected(item)){this.push("selectedItems",item)}}/**
     * Deselects the given item if it is already selected.
     *
     * @method deselect
     * @param {Object} item The item object
     */deselectItem(item){const index=this._getItemIndexInArray(item,this.selectedItems);if(-1<index){this.splice("selectedItems",index,1)}}/**
     * Toggles the selected state of the given item.
     *
     * @method toggle
     * @param {Object} item The item object
     */_toggleItem(item){const index=this._getItemIndexInArray(item,this.selectedItems);if(-1===index){this.selectItem(item)}else{this.deselectItem(item)}}_selectedItemsChanged(e){if(this.$.items.children.length&&("selectedItems"===e.path||"selectedItems.splices"===e.path)){Array.from(this.$.items.children).forEach(row=>{this._updateItem(row,row._item)})}}_selectedInstanceChangedCallback(instance,value){if(super._selectedInstanceChangedCallback){super._selectedInstanceChangedCallback(instance,value)}if(value){this.selectItem(instance.item)}else{this.deselectItem(instance.item)}}};</script><script>window.Vaadin=window.Vaadin||{};Vaadin.Grid=Vaadin.Grid||{};/**
   * @polymerMixin
   */Vaadin.Grid.SortMixin=superClass=>class SortMixin extends superClass{static get properties(){return{/**
         * When `true`, all `<vaadin-grid-sorter>` are applied for sorting.
         */multiSort:{type:Boolean,value:!1},_sorters:{type:Array,value:function(){return[]}},_previousSorters:{type:Array,value:function(){return[]}}}}ready(){super.ready();this.addEventListener("sorter-changed",this._onSorterChanged);// With Polymer 2 & shady the 'sorter-changed' listener isn't guaranteed to be registered
// before child <vaadin-grid-sorter>'s upgrade and fire the events. The following
// makes sure that 'sorter-changed' is fired for all <vaadin-grid-sorter> elements
// after this (<vaadin-grid>) is ready (and the listeners are active).
if(window.ShadyDOM){Polymer.Async.microTask.run(()=>{const sorters=this.querySelectorAll("vaadin-grid-sorter");Array.from(sorters).forEach(sorter=>{// Don't try to fire if the sorter hasn't been upgraded yet
if(sorter instanceof Polymer.Element){sorter.dispatchEvent(new CustomEvent("sorter-changed",{bubbles:!0,composed:!0}))}})})}}_onSorterChanged(e){const sorter=e.target;this._removeArrayItem(this._sorters,sorter);sorter._order=null;if(this.multiSort){if(sorter.direction){this._sorters.unshift(sorter)}this._sorters.forEach((sorter,index)=>sorter._order=1<this._sorters.length?index:null,this)}else{if(sorter.direction){this._sorters.forEach(sorter=>{sorter._order=null;sorter.direction=null});this._sorters=[sorter]}}e.stopPropagation();if(this.dataProvider&&// No need to clear cache if sorters didn't change
JSON.stringify(this._previousSorters)!==JSON.stringify(this._mapSorters())){this.clearCache()}this._a11yUpdateSorters();this._previousSorters=this._mapSorters()}_mapSorters(){return this._sorters.map(sorter=>{return{path:sorter.path,direction:sorter.direction}})}_removeArrayItem(array,item){const index=array.indexOf(item);if(-1<index){array.splice(index,1)}}};</script><script>window.Vaadin=window.Vaadin||{};window.Vaadin.Grid=window.Vaadin.Grid||{};/**
   * @polymerMixin
   */Vaadin.Grid.StylingMixin=superClass=>class StylingMixin extends superClass{static get properties(){return{/**
         * A function that allows generating CSS class names for grid cells
         * based on their row and column. The return value should be the generated
         * class name as a string, or multiple class names separated by whitespace
         * characters.
         *
         * Receives two arguments:
         * - `column` The `<vaadin-grid-column>` element (`undefined` for details-cell).
         * - `rowData` The object with the properties related with
         *   the rendered item, contains:
         *   - `rowData.index` The index of the item.
         *   - `rowData.item` The item.
         *   - `rowData.expanded` Sublevel toggle state.
         *   - `rowData.level` Level of the tree represented with a horizontal offset of the toggle button.
         *   - `rowData.selected` Selected state.
         */cellClassNameGenerator:Function}}static get observers(){return["__cellClassNameGeneratorChanged(cellClassNameGenerator)"]}__cellClassNameGeneratorChanged(cellClassGenerator){this.generateCellClassNames()}/**
     * Runs the `cellClassNameGenerator` for the visible cells.
     * If the generator depends on varying conditions, you need to
     * call this function manually in order to update the styles when
     * the conditions change.
     */generateCellClassNames(){Array.from(this.$.items.children).filter(row=>!row.hidden).forEach(row=>this._generateCellClassNames(row,this.__getRowModel(row)))}_generateCellClassNames(row,rowData){Array.from(row.children).forEach(cell=>{if(cell.__generatedClasses){cell.__generatedClasses.forEach(className=>cell.classList.remove(className))}if(this.cellClassNameGenerator){const result=this.cellClassNameGenerator(cell._column,rowData);cell.__generatedClasses=result&&result.split(" ").filter(className=>0<className.length);if(cell.__generatedClasses){cell.__generatedClasses.forEach(className=>cell.classList.add(className))}}})}};</script><script>window.Vaadin=window.Vaadin||{};window.Vaadin.Grid=window.Vaadin.Grid||{};(function(){const DropMode={BETWEEN:"between",ON_TOP:"on-top",ON_TOP_OR_BETWEEN:"on-top-or-between",ON_GRID:"on-grid"},DropLocation={ON_TOP:"on-top",ABOVE:"above",BELOW:"below",EMPTY:"empty"};/**
     * @polymerMixin
     */Vaadin.Grid.DragAndDropMixin=superClass=>class DragAndDropMixin extends superClass{static get properties(){return{/**
           * Defines the locations within the Grid row where an element can be dropped.
           *
           * Possible values are:
           * - `between`: The drop event can happen between Grid rows.
           * - `on-top`: The drop event can happen on top of Grid rows.
           * - `on-top-or-between`: The drop event can happen either on top of or between Grid rows.
           * - `on-grid`: The drop event will not happen on any specific row, it will show the drop target outline around the whole grid.
           */dropMode:String,/**
           * Marks the grid's rows to be available for dragging.
           */rowsDraggable:Boolean,/**
           * A function that filters dragging of specific grid rows. The return value should be false
           * if dragging of the row should be disabled.
           *
           * Receives one argument:
           * - `rowData` The object with the properties related with
           *   the rendered item, contains:
           *   - `rowData.index` The index of the item.
           *   - `rowData.item` The item.
           *   - `rowData.expanded` Sublevel toggle state.
           *   - `rowData.level` Level of the tree represented with a horizontal offset of the toggle button.
           *   - `rowData.selected` Selected state.
           */dragFilter:Function,/**
           * A function that filters dropping on specific grid rows. The return value should be false
           * if dropping on the row should be disabled.
           *
           * Receives one argument:
           * - `rowData` The object with the properties related with
           *   the rendered item, contains:
           *   - `rowData.index` The index of the item.
           *   - `rowData.item` The item.
           *   - `rowData.expanded` Sublevel toggle state.
           *   - `rowData.level` Level of the tree represented with a horizontal offset of the toggle button.
           *   - `rowData.selected` Selected state.
           */dropFilter:Function,__dndAutoScrollThreshold:{value:50}}}static get observers(){return["_dragDropAccessChanged(rowsDraggable, dropMode, dragFilter, dropFilter)"]}ready(){super.ready();this.$.table.addEventListener("dragstart",this._onDragStart.bind(this));this.$.table.addEventListener("dragend",this._onDragEnd.bind(this));this.$.table.addEventListener("dragover",this._onDragOver.bind(this));this.$.table.addEventListener("dragleave",this._onDragLeave.bind(this));this.$.table.addEventListener("drop",this._onDrop.bind(this));this.$.table.addEventListener("dragenter",e=>{if(this.dropMode){e.preventDefault();e.stopPropagation()}})}_onDragStart(e){if(this.rowsDraggable){let row=e.target;if("vaadin-grid-cell-content"===row.localName){// The draggable node is the cell content element on browsers that support native shadow
row=row.assignedSlot.parentNode.parentNode}if(row.parentNode!==this.$.items){return}e.stopPropagation();this._toggleAttribute("dragging-rows",!0,this);if(this._safari){// Safari doesn't get proper drag images from transformed
// elements so we need to switch to top temporarily
const transform=row.style.transform;row.style.top=/translateY\((.*)\)/.exec(transform)[1];row.style.transform="none";requestAnimationFrame(()=>{row.style.top="";row.style.transform=transform})}const rowRect=row.getBoundingClientRect();if(!window.ShadyDOM){if(this._ios){e.dataTransfer.setDragImage(row)}else{e.dataTransfer.setDragImage(row,e.clientX-rowRect.left,e.clientY-rowRect.top)}}let rows=[row];if(this._isSelected(row._item)){rows=this.__getViewportRows().filter(row=>this._isSelected(row._item)).filter(row=>!this.dragFilter||this.dragFilter(this.__getRowModel(row)))}// Set the default transfer data
e.dataTransfer.setData("text",this.__formatDefaultTransferData(rows));row.setAttribute("dragstart",1<rows.length?rows.length:"");this.updateStyles({"--_grid-drag-start-x":`${e.clientX-rowRect.left+20}px`,"--_grid-drag-start-y":`${e.clientY-rowRect.top+10}px`});requestAnimationFrame(()=>{row.removeAttribute("dragstart");this.updateStyles({"--_grid-drag-start-x":"","--_grid-drag-start-y":""})});const event=new CustomEvent("grid-dragstart",{detail:{draggedItems:rows.map(row=>row._item),setDragData:(type,data)=>e.dataTransfer.setData(type,data),setDraggedItemsCount:count=>row.setAttribute("dragstart",count)}});event.originalEvent=e;this.dispatchEvent(event)}}_onDragEnd(e){this._toggleAttribute("dragging-rows",!1,this);e.stopPropagation();const event=new CustomEvent("grid-dragend");event.originalEvent=e;this.dispatchEvent(event)}_onDragLeave(e){e.stopPropagation();this._clearDragStyles()}_onDragOver(e){if(this.dropMode){this._dropLocation=void 0;this._dragOverItem=void 0;if(this.__dndAutoScroll(e.clientY)){this._clearDragStyles();return}let row=e.composedPath().filter(node=>"tr"===node.localName)[0];if(!this._effectiveSize||this.dropMode===DropMode.ON_GRID){// The grid is empty or "on-grid" drop mode was used, always default to "empty"
this._dropLocation=DropLocation.EMPTY}else if(!row||row.parentNode!==this.$.items){// The dragover didn't occur on a body row but the grid has items
if(row){// The dragover occurred over a header/footer row
return}else if(this.dropMode===DropMode.BETWEEN||this.dropMode===DropMode.ON_TOP_OR_BETWEEN){// The drop mode allows setting the last row as the drag over item
row=Array.from(this.$.items.children).filter(row=>!row.hidden).pop();this._dropLocation=DropLocation.BELOW}else{// Drop mode on-top used but the dragover didn't occur over one of the existing rows
return}}else{// The dragover occurred on a body row, determine the drop location from coordinates
const rowRect=row.getBoundingClientRect();this._dropLocation=DropLocation.ON_TOP;if(this.dropMode===DropMode.BETWEEN){const dropAbove=e.clientY-rowRect.top<rowRect.bottom-e.clientY;this._dropLocation=dropAbove?DropLocation.ABOVE:DropLocation.BELOW}else if(this.dropMode===DropMode.ON_TOP_OR_BETWEEN){if(e.clientY-rowRect.top<rowRect.height/3){this._dropLocation=DropLocation.ABOVE}else if(e.clientY-rowRect.top>2*(rowRect.height/3)){this._dropLocation=DropLocation.BELOW}}}if(row&&row.hasAttribute("drop-disabled")){this._dropLocation=void 0;return}e.stopPropagation();e.preventDefault();if(this._dropLocation===DropLocation.EMPTY){this._toggleAttribute("dragover",!0,this)}else if(row){this._dragOverItem=row._item;if(row.getAttribute("dragover")!==this._dropLocation){row.setAttribute("dragover",this._dropLocation)}}else{this._clearDragStyles()}}}__dndAutoScroll(clientY){if(this.__dndAutoScrolling){return!0}const headerBottom=this.$.header.getBoundingClientRect().bottom,footerTop=this.$.footer.getBoundingClientRect().top,topDiff=headerBottom-clientY+this.__dndAutoScrollThreshold,bottomDiff=clientY-footerTop+this.__dndAutoScrollThreshold;let scrollTopDelta=0;if(0<bottomDiff){scrollTopDelta=2*bottomDiff}else if(0<topDiff){scrollTopDelta=2*-topDiff}if(scrollTopDelta){const scrollTop=this.$.table.scrollTop;this.$.table.scrollTop+=scrollTopDelta;const scrollTopChanged=scrollTop!==this.$.table.scrollTop;if(scrollTopChanged){this.__dndAutoScrolling=!0;// Disallow more auto-scrolls within 20ms
setTimeout(()=>this.__dndAutoScrolling=!1,20);this._scrollHandler();return!0}}}__getViewportRows(){const headerBottom=this.$.header.getBoundingClientRect().bottom,footerTop=this.$.footer.getBoundingClientRect().top;return Array.from(this.$.items.children).filter(row=>{const rowRect=row.getBoundingClientRect();return rowRect.bottom>headerBottom&&rowRect.top<footerTop})}_clearDragStyles(){this.removeAttribute("dragover");Array.from(this.$.items.children).forEach(row=>row.removeAttribute("dragover"))}_onDrop(e){if(this.dropMode){e.stopPropagation();e.preventDefault();const dragData=e.dataTransfer.types&&Array.from(e.dataTransfer.types).map(type=>{return{type,data:e.dataTransfer.getData(type)}});this._clearDragStyles();const event=new CustomEvent("grid-drop",{bubbles:e.bubbles,cancelable:e.cancelable,detail:{dropTargetItem:this._dragOverItem,dropLocation:this._dropLocation,dragData}});event.originalEvent=e;this.dispatchEvent(event)}}__formatDefaultTransferData(rows){return rows.map(row=>{return Array.from(row.children).filter(cell=>!cell.hidden&&-1===cell.getAttribute("part").indexOf("details-cell")).sort((a,b)=>{return a._column._order>b._column._order?1:-1}).map(cell=>cell._content.textContent.trim()).filter(content=>content).join("\t")}).join("\n")}_dragDropAccessChanged(rowsDraggable,dropMode,dragFilter,dropFilter){this.filterDragAndDrop()}/**
       * Runs the `dragFilter` and `dropFilter` hooks for the visible cells.
       * If the filter depends on varying conditions, you may need to
       * call this function manually in order to update the draggability when
       * the conditions change.
       */filterDragAndDrop(){Array.from(this.$.items.children).filter(row=>!row.hidden).forEach(row=>{this._filterDragAndDrop(row,this.__getRowModel(row))})}_filterDragAndDrop(row,rowData){const dragDisabled=!this.rowsDraggable||this.dragFilter&&!this.dragFilter(rowData),dropDisabled=!this.dropMode||this.dropFilter&&!this.dropFilter(rowData),draggableElements=window.ShadyDOM?[row]:Array.from(row.children).map(cell=>cell._content);draggableElements.forEach(e=>{if(dragDisabled){e.removeAttribute("draggable")}else{e.setAttribute("draggable",!0)}});this._toggleAttribute("drag-disabled",dragDisabled,row);this._toggleAttribute("drop-disabled",dropDisabled,row)}/**
       * Fired when starting to drag grid rows.
       *
       * @event grid-dragstart
       * @param {Object} originalEvent The native dragstart event
       * @param {Object} detail
       * @param {Object} detail.draggedItems the items in the visible viewport that are dragged
       * @param {Function} detail.setDraggedItemsCount Overrides the default number shown in the drag image on multi row drag.
       * Parameter is of type number.
       * @param {Function} detail.setDragData Sets dataTransfer data for the drag operation.
       * Note that "text" is the only data type supported by all the browsers the grid currently supports (including IE11).
       * The function takes two parameters:
       * - type:string The type of the data
       * - data:string The data
       */ /**
       * Fired when the dragging of the rows ends.
       *
       * @event grid-dragend
       * @param {Object} originalEvent The native dragend event
       */ /**
       * Fired when a drop occurs on top of the grid.
       *
       * @event grid-drop
       * @param {Object} originalEvent The native drop event
       * @param {Object} detail
       * @param {Object} detail.dropTargetItem The item of the grid row on which the drop occurred.
       * @param {string} detail.dropLocation The position at which the drop event took place relative to a row.
       * Depending on the dropMode value, the drop location can be one of the following
       * - `on-top`: when the drop occurred on top of the row
       * - `above`: when the drop occurred above the row
       * - `below`: when the drop occurred below the row
       * - `empty`: when the drop occurred over the grid, not relative to any specific row
       * @param {string} detail.dragData An array of items with the payload as a string representation as the
       * `data` property and the type of the data as `type` property.
       */}})();</script><script>window.Vaadin=window.Vaadin||{};Vaadin.Grid=Vaadin.Grid||{};/**
   * @polymerMixin
   */Vaadin.Grid.KeyboardNavigationMixin=superClass=>class KeyboardNavigationMixin extends superClass{static get properties(){return{_headerFocusable:{type:Object,observer:"_focusableChanged"},_itemsFocusable:{type:Object,observer:"_focusableChanged"},_footerFocusable:{type:Object,observer:"_focusableChanged"},_navigatingIsHidden:Boolean,_focusedItemIndex:{type:Number,value:0},_focusedColumnOrder:Number}}ready(){super.ready();if(this._ios||this._android){// Disable keyboard navigation on mobile devices
return}this.addEventListener("keydown",this._onKeyDown);this.addEventListener("keyup",this._onKeyUp);this.addEventListener("focusin",this._onFocusIn);this.addEventListener("focusout",this._onFocusOut);// When focus goes from cell to another cell, focusin/focusout events do
// not escape the grid’s shadowRoot, thus listening inside the shadowRoot.
this.$.table.addEventListener("focusin",this._onCellFocusIn.bind(this));this.$.table.addEventListener("focusout",this._onCellFocusOut.bind(this));this.addEventListener("mousedown",()=>{this._toggleAttribute("navigating",!1,this);this._isMousedown=!0});this.addEventListener("mouseup",()=>this._isMousedown=!1)}_focusableChanged(focusable,oldFocusable){if(oldFocusable){oldFocusable.setAttribute("tabindex","-1")}if(focusable){focusable.setAttribute("tabindex","0")}}_onKeyDown(e){// Ensure standard key value, unified across browsers
let key=e.key;if("Up"===key||"Down"===key||"Left"===key||"Right"===key){// MSIE & Edge
key="Arrow"+key}if("Esc"===key){// MSIE & Edge
key="Escape"}if("Spacebar"===key){// MSIE
key=" "}let keyGroup;switch(key){case"ArrowUp":case"ArrowDown":case"ArrowLeft":case"ArrowRight":case"PageUp":case"PageDown":case"Home":case"End":keyGroup="Navigation";break;case"Enter":case"Escape":case"F2":keyGroup="Interaction";break;case"Tab":keyGroup="Tab";break;case" ":keyGroup="Space";break;}this._detectInteracting(e);if(this.hasAttribute("interacting")&&"Interaction"!==keyGroup){// When in the interacting mode, only the “Interaction” keys are handled.
keyGroup=void 0}if(keyGroup){this[`_on${keyGroup}KeyDown`](e,key)}}_ensureScrolledToIndex(index){const targetRowInDom=Array.from(this.$.items.children).filter(child=>child.index===index)[0];if(!targetRowInDom){this._scrollToIndex(index)}}_onNavigationKeyDown(e,key){e.preventDefault();function indexOfChildElement(el){return Array.prototype.indexOf.call(el.parentNode.children,el)}const visibleItemsCount=this._lastVisibleIndex-this._firstVisibleIndex-1;let dx=0,dy=0;switch(key){case"ArrowRight":dx=this.__isRTL?-1:1;break;case"ArrowLeft":dx=this.__isRTL?1:-1;break;case"Home":dx=-Infinity;e.ctrlKey&&(dy=-Infinity);break;case"End":dx=1/0;e.ctrlKey&&(dy=1/0);break;case"ArrowDown":dy=1;break;case"ArrowUp":dy=-1;break;case"PageDown":dy=visibleItemsCount;break;case"PageUp":dy=-visibleItemsCount;break;}const activeCell=e.composedPath()[0],columnIndex=indexOfChildElement(activeCell),isRowDetails=this._elementMatches(activeCell,"[part~=\"details-cell\"]"),activeRow=activeCell.parentNode,activeRowGroup=activeRow.parentNode,maxRowIndex=(activeRowGroup===this.$.items?this._effectiveSize:activeRowGroup.children.length)-1,rowIndex=activeRowGroup===this.$.items?this._focusedItemIndex!==void 0?this._focusedItemIndex:activeRow.index:indexOfChildElement(activeRow);// Index of the destination row
let dstRowIndex=Math.max(0,Math.min(rowIndex+dy,maxRowIndex)),dstIsRowDetails=!1;// Row details navigation logic
if(activeRowGroup===this.$.items){const item=activeRow._item,dstItem=this._cache.getItemForIndex(dstRowIndex);// Should we navigate to row details?
if(isRowDetails){dstIsRowDetails=0===dy}else{dstIsRowDetails=1===dy&&this._isDetailsOpened(item)||-1===dy&&dstRowIndex!==rowIndex&&this._isDetailsOpened(dstItem)}// Should we navigate between details and regular cells of the same row?
if(dstIsRowDetails!==isRowDetails&&(1===dy&&dstIsRowDetails||-1===dy&&!dstIsRowDetails)){dstRowIndex=rowIndex}}// Header and footer could have hidden rows, e. g., if none of the columns
// or groups on the given column tree level define template. Skip them
// in vertical keyboard navigation.
if(activeRowGroup!==this.$.items){if(dstRowIndex>rowIndex){while(dstRowIndex<maxRowIndex&&activeRowGroup.children[dstRowIndex].hidden){dstRowIndex++}}else if(dstRowIndex<rowIndex){while(0<dstRowIndex&&activeRowGroup.children[dstRowIndex].hidden){dstRowIndex--}}}// _focusedColumnOrder is memoized — this is to ensure predictable
// navigation when entering and leaving detail and column group cells.
if(this._focusedColumnOrder===void 0){if(isRowDetails){this._focusedColumnOrder=0}else{this._focusedColumnOrder=this._getColumns(activeRowGroup,rowIndex).filter(c=>!c.hidden)[columnIndex]._order}}// Find orderedColumnIndex — the index of order closest matching the
// original _focusedColumnOrder in the sorted array of orders
// of the visible columns on the destination row.
const dstColumns=this._getColumns(activeRowGroup,dstRowIndex).filter(c=>!c.hidden),dstSortedColumnOrders=dstColumns.map(c=>c._order).sort((b,a)=>b-a),maxOrderedColumnIndex=dstSortedColumnOrders.length-1,orderedColumnIndex=dstSortedColumnOrders.indexOf(dstSortedColumnOrders.slice(0).sort((b,a)=>Math.abs(b-this._focusedColumnOrder)-Math.abs(a-this._focusedColumnOrder))[0]),dstOrderedColumnIndex=0===dy&&isRowDetails?orderedColumnIndex:Math.max(0,Math.min(orderedColumnIndex+dx,maxOrderedColumnIndex));if(dstOrderedColumnIndex!==orderedColumnIndex){// Horizontal movement invalidates stored _focusedColumnOrder
this._focusedColumnOrder=void 0}// Ensure correct vertical scroll position, destination row is visible
if(activeRowGroup===this.$.items){this._ensureScrolledToIndex(dstRowIndex)}// This has to be set after scrolling, otherwise it can be removed by
// `_preventScrollerRotatingCellFocus(item, index)` during scrolling.
this._toggleAttribute("navigating",!0,this);const columnIndexByOrder=dstColumns.reduce((acc,col,i)=>(acc[col._order]=i,acc),{}),dstColumnIndex=columnIndexByOrder[dstSortedColumnOrders[dstOrderedColumnIndex]],dstRow=activeRowGroup===this.$.items?Array.from(activeRowGroup.children).filter(el=>el.index===dstRowIndex)[0]:activeRowGroup.children[dstRowIndex];if(!dstRow){return}// Here we go!
const dstCell=dstIsRowDetails?Array.from(dstRow.children).filter(el=>this._elementMatches(el,"[part~=\"details-cell\"]"))[0]:dstRow.children[dstColumnIndex];this._scrollHorizontallyToCell(dstCell);if(activeRowGroup===this.$.items){// When scrolling with repeated keydown, sometimes FocusEvent listeners
// are too late to update _focusedItemIndex. Ensure next keydown
// listener invocation gets updated _focusedItemIndex value.
this._focusedItemIndex=dstRowIndex}if(activeRowGroup===this.$.items){const dstRect=dstCell.getBoundingClientRect(),footerTop=this.$.footer.getBoundingClientRect().top,headerBottom=this.$.header.getBoundingClientRect().bottom;if(dstRect.bottom>footerTop){this.$.table.scrollTop+=dstRect.bottom-footerTop;this._scrollHandler()}else if(dstRect.top<headerBottom){this.$.table.scrollTop-=headerBottom-dstRect.top;this._scrollHandler()}}dstCell.focus()}_parseEventPath(path){const tableIndex=path.indexOf(this.$.table);return{rowGroup:path[tableIndex-1],row:path[tableIndex-2],cell:path[tableIndex-3]}}_onInteractionKeyDown(e,key){const localTarget=e.composedPath()[0],localTargetIsTextInput="input"===localTarget.localName&&!/^(button|checkbox|color|file|image|radio|range|reset|submit)$/i.test(localTarget.type);let wantInteracting;switch(key){case"Enter":wantInteracting=this.hasAttribute("interacting")?!localTargetIsTextInput:!0;break;case"Escape":wantInteracting=!1;break;case"F2":wantInteracting=!this.hasAttribute("interacting");break;}const{cell}=this._parseEventPath(e.composedPath());if(this.hasAttribute("interacting")!==wantInteracting){if(wantInteracting){const focusTarget=cell._content.querySelector("[focus-target]")||cell._content.firstElementChild;if(focusTarget){e.preventDefault();focusTarget.focus();this._toggleAttribute("interacting",!0,this);this._toggleAttribute("navigating",!1,this)}}else{e.preventDefault();this._focusedColumnOrder=void 0;cell.focus();this._toggleAttribute("interacting",!1,this);this._toggleAttribute("navigating",!0,this)}}}_predictFocusStepTarget(srcElement,step){const tabOrder=[this.$.table,this._headerFocusable,this._itemsFocusable,this._footerFocusable,this.$.focusexit];let index=tabOrder.indexOf(srcElement);index+=step;while(0<=index&&index<=tabOrder.length-1&&(!tabOrder[index]||tabOrder[index].parentNode.hidden)){index+=step}return tabOrder[index]}_onTabKeyDown(e){const focusTarget=this._predictFocusStepTarget(e.composedPath()[0],e.shiftKey?-1:1);if(focusTarget===this.$.table){// The focus is about to exit the grid to the top.
this.$.table.focus()}else if(focusTarget===this.$.focusexit){// The focus is about to exit the grid to the bottom.
this.$.focusexit.focus()}else if(focusTarget===this._itemsFocusable){let itemsFocusTarget=focusTarget;const targetRow=this._itemsFocusable.parentNode;this._ensureScrolledToIndex(this._focusedItemIndex);if(targetRow.index!==this._focusedItemIndex){// The target row, which is about to be focused next, has been
// assigned with a new index since last focus, probably because of
// scrolling. Focus the row for the stored focused item index instead.
const columnIndex=Array.from(targetRow.children).indexOf(this._itemsFocusable),focusedItemRow=Array.from(this.$.items.children).filter(row=>row.index===this._focusedItemIndex)[0];if(focusedItemRow){itemsFocusTarget=focusedItemRow.children[columnIndex]}}e.preventDefault();itemsFocusTarget.focus()}else{e.preventDefault();focusTarget.focus()}this._toggleAttribute("navigating",!0,this)}_onSpaceKeyDown(e){e.preventDefault();const cell=e.composedPath()[0];if(!cell._content||!cell._content.firstElementChild){this.dispatchEvent(new CustomEvent("cell-activate",{detail:{model:this.__getRowModel(cell.parentElement)}}))}}/** @private */_onKeyUp(e){if(!/^( |SpaceBar)$/.test(e.key)){return}e.preventDefault();const cell=e.composedPath()[0];if(cell._content&&cell._content.firstElementChild){const wasNavigating=this.hasAttribute("navigating");cell._content.firstElementChild.click();this._toggleAttribute("navigating",wasNavigating,this)}}_onFocusIn(e){if(!this._isMousedown){this._toggleAttribute("navigating",!0,this)}const rootTarget=e.composedPath()[0];if(rootTarget===this.$.table||rootTarget===this.$.focusexit){// The focus enters the top (bottom) of the grid, meaning that user has
// tabbed (shift-tabbed) into the grid. Move the focus to
// the first (the last) focusable.
this._predictFocusStepTarget(rootTarget,rootTarget===this.$.table?1:-1).focus();this._toggleAttribute("interacting",!1,this)}else{this._detectInteracting(e)}}_onFocusOut(e){this._toggleAttribute("navigating",!1,this);this._detectInteracting(e)}_onCellFocusIn(e){this._detectInteracting(e);if(3===e.composedPath().indexOf(this.$.table)){const cell=e.composedPath()[0];this._activeRowGroup=cell.parentNode.parentNode;if(this._activeRowGroup===this.$.header){this._headerFocusable=cell}else if(this._activeRowGroup===this.$.items){this._itemsFocusable=cell}else if(this._activeRowGroup===this.$.footer){this._footerFocusable=cell}// Inform cell content of the focus (used in <vaadin-grid-sorter>)
cell._content.dispatchEvent(new CustomEvent("cell-focusin",{bubbles:!1}))}this._detectFocusedItemIndex(e)}_onCellFocusOut(e){if(3===e.composedPath().indexOf(this.$.table)){const cell=e.composedPath()[0];// Inform cell content of the focus (used in <vaadin-grid-sorter>)
cell._content.dispatchEvent(new CustomEvent("cell-focusout",{bubbles:!1}))}}_detectInteracting(e){this._toggleAttribute("interacting",e.composedPath().some(el=>"vaadin-grid-cell-content"===el.localName),this)}_detectFocusedItemIndex(e){const{rowGroup,row}=this._parseEventPath(e.composedPath());if(rowGroup===this.$.items){this._focusedItemIndex=row.index}}_preventScrollerRotatingCellFocus(item,index){if(item.index===this._focusedItemIndex&&this.hasAttribute("navigating")&&this._activeRowGroup===this.$.items){// Focused item has went, hide navigation mode
this._navigatingIsHidden=!0;this._toggleAttribute("navigating",!1,this)}if(index===this._focusedItemIndex&&this._navigatingIsHidden){// Focused item is back, restore navigation mode
this._navigatingIsHidden=!1;this._toggleAttribute("navigating",!0,this)}}_getColumns(rowGroup,rowIndex){let columnTreeLevel=this._columnTree.length-1;if(rowGroup===this.$.header){columnTreeLevel=rowIndex}else if(rowGroup===this.$.footer){columnTreeLevel=this._columnTree.length-1-rowIndex}return this._columnTree[columnTreeLevel]}_resetKeyboardNavigation(){if(this.$.header.firstElementChild){this._headerFocusable=Array.from(this.$.header.firstElementChild.children).filter(el=>!el.hidden)[0]}if(this.$.items.firstElementChild){const firstVisibleIndexRow=this._iterateItems((pidx,vidx)=>{if(this._firstVisibleIndex===vidx){return this.$.items.children[pidx]}});if(firstVisibleIndexRow){this._itemsFocusable=Array.from(firstVisibleIndexRow.children).filter(el=>!el.hidden)[0]}}if(this.$.footer.firstElementChild){this._footerFocusable=Array.from(this.$.footer.firstElementChild.children).filter(el=>!el.hidden)[0]}}_scrollHorizontallyToCell(dstCell){if(dstCell.hasAttribute("frozen")||this._elementMatches(dstCell,"[part~=\"details-cell\"]")){// These cells are, by design, always visible, no need to scroll.
return}const dstCellRect=dstCell.getBoundingClientRect(),dstRow=dstCell.parentNode,dstCellIndex=Array.from(dstRow.children).indexOf(dstCell),tableRect=this.$.table.getBoundingClientRect();let leftBoundary=tableRect.left,rightBoundary=tableRect.right;for(let i=dstCellIndex-1;0<=i;i--){const cell=dstRow.children[i];if(cell.hasAttribute("hidden")||this._elementMatches(cell,"[part~=\"details-cell\"]")){continue}if(cell.hasAttribute("frozen")){leftBoundary=cell.getBoundingClientRect().right;break}}for(let i=dstCellIndex+1;i<dstRow.children.length;i++){const cell=dstRow.children[i];if(cell.hasAttribute("hidden")||this._elementMatches(cell,"[part~=\"details-cell\"]")){continue}if(cell.hasAttribute("frozen")){rightBoundary=cell.getBoundingClientRect().left;break}}if(dstCellRect.left<leftBoundary){this.$.table.scrollLeft+=Math.round(dstCellRect.left-leftBoundary)}if(dstCellRect.right>rightBoundary){this.$.table.scrollLeft+=Math.round(dstCellRect.right-rightBoundary)}}_elementMatches(el,query){return el.matches?el.matches(query):-1!==Array.from(el.parentNode.querySelectorAll(query)).indexOf(el)}};</script><script>window.Vaadin=window.Vaadin||{};window.Vaadin.Grid=window.Vaadin.Grid||{};/**
   * @polymerMixin
   */Vaadin.Grid.ColumnReorderingMixin=superClass=>class ColumnReorderingMixin extends Polymer.GestureEventListeners(superClass){static get properties(){return{/**
         * Set to true to allow column reordering.
         */columnReorderingAllowed:{type:Boolean,value:!1},_orderBaseScope:{type:Number,value:1e7}}}static get observers(){return["_updateOrders(_columnTree, _columnTree.*)"]}ready(){super.ready();Polymer.Gestures.addListener(this,"track",this._onTrackEvent);this._reorderGhost=this.shadowRoot.querySelector("[part=\"reorder-ghost\"]");this.addEventListener("touchstart",this._onTouchStart.bind(this));this.addEventListener("touchmove",this._onTouchMove.bind(this));this.addEventListener("touchend",this._onTouchEnd.bind(this));this.addEventListener("contextmenu",this._onContextMenu.bind(this))}_onContextMenu(e){if(this.hasAttribute("reordering")){e.preventDefault()}}_onTouchStart(e){// Touch event, delay activation by 100ms
this._startTouchReorderTimeout=setTimeout(()=>{this._onTrackStart({detail:{x:e.touches[0].clientX,y:e.touches[0].clientY}})},100)}_onTouchMove(e){if(this._draggedColumn){e.preventDefault()}clearTimeout(this._startTouchReorderTimeout)}_onTouchEnd(){clearTimeout(this._startTouchReorderTimeout);this._onTrackEnd()}_onTrackEvent(e){if("start"===e.detail.state){const path=e.composedPath(),headerCell=path[path.indexOf(this.$.header)-2];if(!headerCell||!headerCell._content){// Not a header column
return}const activeElement=this.getRootNode().activeElement;if(headerCell._content.contains(this.getRootNode().activeElement)&&(!this._ie||!this._isFocusable(activeElement))){// Something was focused inside the cell
return}if(this.$.scroller.hasAttribute("column-resizing")){// Resizing is in progress
return}if(!this._touchDevice){// Not a touch device
this._onTrackStart(e)}}else if("track"===e.detail.state){this._onTrack(e)}else if("end"===e.detail.state){this._onTrackEnd(e)}}_onTrackStart(e){if(!this.columnReorderingAllowed){return}// Cancel reordering if there are draggable nodes on the event path
const path=e.path||Polymer.dom(e).path;if(path&&path.filter(node=>node.hasAttribute&&node.hasAttribute("draggable"))[0]){return}const headerCell=this._cellFromPoint(e.detail.x,e.detail.y);if(!headerCell||-1===headerCell.getAttribute("part").indexOf("header-cell")){return}this._toggleAttribute("reordering",!0,this);this._draggedColumn=headerCell._column;while(1===this._draggedColumn.parentElement.childElementCount){// This is the only column in the group, drag the whole group instead
this._draggedColumn=this._draggedColumn.parentElement}this._setSiblingsReorderStatus(this._draggedColumn,"allowed");this._draggedColumn._reorderStatus="dragging";this._updateGhost(headerCell);this._reorderGhost.style.visibility="visible";this._updateGhostPosition(e.detail.x,this._touchDevice?e.detail.y-50:e.detail.y);this._autoScroller()}_onTrack(e){if(!this._draggedColumn){// Reordering didn’t start. Skip this event.
return}const targetCell=this._cellFromPoint(e.detail.x,e.detail.y);if(!targetCell){return}const targetColumn=this._getTargetColumn(targetCell,this._draggedColumn);if(this._isSwapAllowed(this._draggedColumn,targetColumn)&&this._isSwappableByPosition(targetColumn,e.detail.x)){this._swapColumnOrders(this._draggedColumn,targetColumn)}this._updateGhostPosition(e.detail.x,this._touchDevice?e.detail.y-50:e.detail.y);this._lastDragClientX=e.detail.x}_onTrackEnd(){if(!this._draggedColumn){// Reordering didn’t start. Skip this event.
return}this._toggleAttribute("reordering",!1,this);this._draggedColumn._reorderStatus="";this._setSiblingsReorderStatus(this._draggedColumn,"");this._draggedColumn=null;this._lastDragClientX=null;this._reorderGhost.style.visibility="hidden";this.dispatchEvent(new CustomEvent("column-reorder",{detail:{columns:this._getColumnsInOrder()}}))}_getColumnsInOrder(){return this._columnTree.slice(0).pop().filter(c=>!c.hidden).sort((b,a)=>b._order-a._order)}_cellFromPoint(x,y){x=x||0;y=y||0;if(!this._draggedColumn){this._toggleAttribute("no-content-pointer-events",!0,this.$.scroller)}let cell;if(Polymer.Settings.useShadow){cell=this.shadowRoot.elementFromPoint(x,y)}else{cell=document.elementFromPoint(x,y);// Workaround a FF58 bug
if("vaadin-grid-cell-content"===cell.localName){cell=cell.assignedSlot.parentNode}}this._toggleAttribute("no-content-pointer-events",!1,this.$.scroller);// Make sure the element is actually a cell
if(cell&&cell._column){return cell}}_updateGhostPosition(eventClientX,eventClientY){const ghostRect=this._reorderGhost.getBoundingClientRect(),targetLeft=eventClientX-ghostRect.width/2,targetTop=eventClientY-ghostRect.height/2,_left=parseInt(this._reorderGhost._left||0),_top=parseInt(this._reorderGhost._top||0);// // This is where we want to position the ghost
// Reposition the ghost
this._reorderGhost._left=_left-(ghostRect.left-targetLeft);this._reorderGhost._top=_top-(ghostRect.top-targetTop);this._reorderGhost.style.transform=`translate(${this._reorderGhost._left}px, ${this._reorderGhost._top}px)`}_getInnerText(e){if(e.localName){// Custom implementation needed since IE11 doesn't respect the spec in case of hidden elements
if("none"===getComputedStyle(e).display){return""}else{return Array.from(e.childNodes).map(n=>this._getInnerText(n)).join("")}}else{return e.textContent}}_updateGhost(cell){const ghost=this._reorderGhost;ghost.textContent=this._getInnerText(cell._content);const style=window.getComputedStyle(cell);["boxSizing","display","width","height","background","alignItems","padding","border","flex-direction","overflow"].forEach(propertyName=>ghost.style[propertyName]=style[propertyName]);return ghost}_updateOrders(columnTree,splices){if(columnTree===void 0||splices===void 0){return}// Reset all column orders
columnTree[0].forEach((column,index)=>column._order=0);// Set order numbers to top-level columns
columnTree[0].forEach((column,index)=>column._order=(index+1)*this._orderBaseScope)}_setSiblingsReorderStatus(column,status){Array.from(column.parentNode.children).filter(child=>/column/.test(child.localName)&&this._isSwapAllowed(child,column)).forEach(sibling=>sibling._reorderStatus=status)}_autoScroller(){if(this._lastDragClientX){const rightDiff=this._lastDragClientX-this.getBoundingClientRect().right+50,leftDiff=this.getBoundingClientRect().left-this._lastDragClientX+50;if(0<rightDiff){this.$.table.scrollLeft+=rightDiff/10}else if(0<leftDiff){this.$.table.scrollLeft-=leftDiff/10}this._scrollHandler()}if(this._draggedColumn){this.async(this._autoScroller,10)}}_isSwapAllowed(column1,column2){if(column1&&column2){const differentColumns=column1!==column2,sameParent=column1.parentElement===column2.parentElement,sameFrozen=column1.frozen===column2.frozen;return differentColumns&&sameParent&&sameFrozen}}_isSwappableByPosition(targetColumn,clientX){const targetCell=Array.from(this.$.header.querySelectorAll("tr:not([hidden]) [part~=\"cell\"]")).filter(cell=>targetColumn.contains(cell._column))[0],sourceCellRect=this.$.header.querySelector("tr:not([hidden]) [reorder-status=dragging]").getBoundingClientRect(),targetRect=targetCell.getBoundingClientRect();if(targetRect.left>sourceCellRect.left){return clientX>targetRect.right-sourceCellRect.width}else{return clientX<targetRect.left+sourceCellRect.width}}_swapColumnOrders(column1,column2){const _order=column1._order;column1._order=column2._order;column2._order=_order;this._updateLastFrozen();this._updateFirstAndLastColumn()}_getTargetColumn(targetCell,draggedColumn){if(targetCell&&draggedColumn){let candidate=targetCell._column;while(candidate.parentElement!==draggedColumn.parentElement&&candidate!==this){candidate=candidate.parentElement}if(candidate.parentElement===draggedColumn.parentElement){return candidate}else{return targetCell._column}}}/**
     * Fired when the columns in the grid are reordered.
     *
     * @event column-reorder
     * @param {Object} detail
     * @param {Object} detail.columns the columns in the new order
     */};</script><script>window.Vaadin=window.Vaadin||{};window.Vaadin.Grid=window.Vaadin.Grid||{};/**
   * @polymerMixin
   * @memberof Vaadin.Grid
   */Vaadin.Grid.ColumnBaseMixin=superClass=>class ColumnBaseMixin extends superClass{static get properties(){return{/**
         * When set to true, the column is user-resizable.
         * @default false
         */resizable:{type:Boolean,value:function(){if("vaadin-grid-column-group"===this.localName){return}const parent=this.parentNode;if(parent&&"vaadin-grid-column-group"===parent.localName){return parent.resizable||!1}else{return!1}}},_headerTemplate:{type:Object},_footerTemplate:{type:Object},/**
         * When true, the column is frozen. When a column inside of a column group is frozen,
         * all of the sibling columns inside the group will get frozen also.
         */frozen:{type:Boolean,value:!1},/**
         * When set to true, the cells for this column are hidden.
         */hidden:{type:Boolean},/**
         * Text content to display in the header cell of the column.
         */header:{type:String},/**
         * Aligns the columns cell content horizontally.
         * Supported values: "start", "center" and "end".
         */textAlign:{type:String},_lastFrozen:{type:Boolean,value:!1},_order:Number,_reorderStatus:Boolean,_emptyCells:Array,_headerCell:Object,_footerCell:Object,_grid:Object,/**
         * Custom function for rendering the header content.
         * Receives two arguments:
         *
         * - `root` The header cell content DOM element. Append your content to it.
         * - `column` The `<vaadin-grid-column>` element.
         */headerRenderer:Function,/**
         * Custom function for rendering the footer content.
         * Receives two arguments:
         *
         * - `root` The footer cell content DOM element. Append your content to it.
         * - `column` The `<vaadin-grid-column>` element.
         */footerRenderer:Function}}static get observers(){return["_widthChanged(width, _headerCell, _footerCell, _cells.*)","_frozenChanged(frozen, _headerCell, _footerCell, _cells.*)","_flexGrowChanged(flexGrow, _headerCell, _footerCell, _cells.*)","_pathOrHeaderChanged(path, header, _headerCell, _footerCell, _cells.*, renderer, headerRenderer, _bodyTemplate, _headerTemplate)","_textAlignChanged(textAlign, _cells.*, _headerCell, _footerCell)","_orderChanged(_order, _headerCell, _footerCell, _cells.*)","_lastFrozenChanged(_lastFrozen)","_setBodyTemplateOrRenderer(_bodyTemplate, renderer, _cells, _cells.*)","_setHeaderTemplateOrRenderer(_headerTemplate, headerRenderer, _headerCell)","_setFooterTemplateOrRenderer(_footerTemplate, footerRenderer, _footerCell)","_resizableChanged(resizable, _headerCell)","_reorderStatusChanged(_reorderStatus, _headerCell, _footerCell, _cells.*)","_hiddenChanged(hidden, _headerCell, _footerCell, _cells.*)"]}/** @protected */connectedCallback(){super.connectedCallback();this._bodyTemplate&&(this._bodyTemplate.templatizer._grid=this._grid);this._headerTemplate&&(this._headerTemplate.templatizer._grid=this._grid);this._footerTemplate&&(this._footerTemplate.templatizer._grid=this._grid);this._templateObserver.flush();if(!this._bodyTemplate){// The observer might not have triggered if the tag is empty. Run manually.
this._templateObserver.callback()}requestAnimationFrame(()=>{this._allCells.forEach(cell=>{if(!cell._content.parentNode){this._grid&&this._grid.appendChild(cell._content)}})})}/** @protected */disconnectedCallback(){super.disconnectedCallback();requestAnimationFrame(()=>{if(!this._findHostGrid()){this._allCells.forEach(cell=>{if(cell._content.parentNode){cell._content.parentNode.removeChild(cell._content)}})}});this._gridValue=void 0}_findHostGrid(){let el=this;// Custom elements extending grid must have a specific localName
while(el&&!/^vaadin.*grid(-pro)?$/.test(el.localName)){el=el.assignedSlot?el.assignedSlot.parentNode:el.parentNode}return el||void 0}get _grid(){if(!this._gridValue){this._gridValue=this._findHostGrid()}return this._gridValue}get _allCells(){return[].concat(this._cells||[]).concat(this._emptyCells||[]).concat(this._headerCell).concat(this._footerCell).filter(cell=>cell)}constructor(){super();this._templateObserver=new Polymer.FlattenedNodesObserver(this,info=>{this._headerTemplate=this._prepareHeaderTemplate();this._footerTemplate=this._prepareFooterTemplate();this._bodyTemplate=this._prepareBodyTemplate()})}_prepareHeaderTemplate(){return this._prepareTemplatizer(this._findTemplate(!0)||null,{})}_prepareFooterTemplate(){return this._prepareTemplatizer(this._findTemplate(!1,!0)||null,{})}_prepareBodyTemplate(){return this._prepareTemplatizer(this._findTemplate()||null)}_prepareTemplatizer(template,instanceProps){if(template&&!template.templatizer){const templatizer=new Vaadin.Grid.Templatizer;templatizer._grid=this._grid;templatizer.dataHost=this.dataHost;templatizer._instanceProps=instanceProps||templatizer._instanceProps;templatizer.template=template;template.templatizer=templatizer}return template}_renderHeaderAndFooter(){if(this.headerRenderer&&this._headerCell){this.__runRenderer(this.headerRenderer,this._headerCell)}if(this.footerRenderer&&this._footerCell){this.__runRenderer(this.footerRenderer,this._footerCell)}}__runRenderer(renderer,cell,rowData){const args=[cell._content,this];if(rowData&&rowData.item){args.push(rowData)}renderer.apply(this,args)}__setColumnTemplateOrRenderer(template,renderer,cells){if(template&&renderer){throw new Error("You should only use either a renderer or a template")}cells.forEach(cell=>{const model=this._grid.__getRowModel(cell.parentElement);if(renderer){cell._renderer=renderer;if(model.item||renderer===this.headerRenderer||renderer===this.footerRenderer){this.__runRenderer(renderer,cell,model)}}else if(cell._template!==template){cell._template=template;cell._content.innerHTML="";template.templatizer._grid=template.templatizer._grid||this._grid;const inst=template.templatizer.createInstance();cell._content.appendChild(inst.root);cell._instance=inst;if(model.item){cell._instance.setProperties(model)}}})}_setBodyTemplateOrRenderer(template,renderer,cells,splices){if((template||renderer)&&cells){this.__setColumnTemplateOrRenderer(template,renderer,cells)}}_setHeaderTemplateOrRenderer(headerTemplate,headerRenderer,headerCell){if((headerTemplate||headerRenderer)&&headerCell){this.__setColumnTemplateOrRenderer(headerTemplate,headerRenderer,[headerCell])}}_setFooterTemplateOrRenderer(footerTemplate,footerRenderer,footerCell){if((footerTemplate||footerRenderer)&&footerCell){this.__setColumnTemplateOrRenderer(footerTemplate,footerRenderer,[footerCell]);this._grid.__updateHeaderFooterRowVisibility(footerCell.parentElement)}}_selectFirstTemplate(header=!1,footer=!1){return Polymer.FlattenedNodesObserver.getFlattenedNodes(this).filter(node=>"template"===node.localName&&node.classList.contains("header")===header&&node.classList.contains("footer")===footer)[0]}_findTemplate(header,footer){const template=this._selectFirstTemplate(header,footer);if(template){if(this.dataHost){// set dataHost to the context where template has been defined
template._rootDataHost=this.dataHost._rootDataHost||this.dataHost}}return template}_flexGrowChanged(flexGrow,headerCell,footerCell,cells){if(this.parentElement&&this.parentElement._columnPropChanged){this.parentElement._columnPropChanged("flexGrow")}this._allCells.forEach(cell=>cell.style.flexGrow=flexGrow)}_orderChanged(order,headerCell,footerCell,cells){this._allCells.forEach(cell=>cell.style.order=order)}_widthChanged(width,headerCell,footerCell,cells){if(this.parentElement&&this.parentElement._columnPropChanged){this.parentElement._columnPropChanged("width")}this._allCells.forEach(cell=>cell.style.width=width);// Force a reflow to workaround browser issues causing double scrollbars to grid
// https://github.com/vaadin/vaadin-grid/issues/1586
if(this._grid&&this._grid.__forceReflow){this._grid.__forceReflow()}}_frozenChanged(frozen,headerCell,footerCell,cells){if(this.parentElement&&this.parentElement._columnPropChanged){this.parentElement._columnPropChanged("frozen",frozen)}this._allCells.forEach(cell=>this._toggleAttribute("frozen",frozen,cell));this._grid&&this._grid._frozenCellsChanged&&this._grid._frozenCellsChanged()}_lastFrozenChanged(lastFrozen){this._allCells.forEach(cell=>this._toggleAttribute("last-frozen",lastFrozen,cell));if(this.parentElement&&this.parentElement._columnPropChanged){this.parentElement._lastFrozen=lastFrozen}}_pathOrHeaderChanged(path,header,headerCell,footerCell,cells,renderer,headerRenderer,bodyTemplate,headerTemplate){const hasHeaderText=header!==void 0;if(!headerRenderer&&!headerTemplate&&hasHeaderText&&headerCell){this.__setTextContent(headerCell._content,header)}if(path&&cells.value){if(!renderer&&!bodyTemplate){const pathRenderer=(root,owner,{item})=>this.__setTextContent(root,this.get(path,item));this.__setColumnTemplateOrRenderer(void 0,pathRenderer,cells.value)}if(!headerRenderer&&!headerTemplate&&!hasHeaderText&&headerCell&&null!==header){this.__setTextContent(headerCell._content,this._generateHeader(path))}}if(headerCell){this._grid.__updateHeaderFooterRowVisibility(headerCell.parentElement)}}__setTextContent(node,textContent){node.textContent!==textContent&&(node.textContent=textContent)}_generateHeader(path){return path.substr(path.lastIndexOf(".")+1).replace(/([A-Z])/g,"-$1").toLowerCase().replace(/-/g," ").replace(/^./,match=>match.toUpperCase())}_toggleAttribute(name,bool,node){if(node.hasAttribute(name)===!bool){if(bool){node.setAttribute(name,"")}else{node.removeAttribute(name)}}}_reorderStatusChanged(reorderStatus,headerCell,footerCell,cells){this._allCells.forEach(cell=>cell.setAttribute("reorder-status",reorderStatus))}_resizableChanged(resizable,headerCell){if(resizable===void 0||headerCell===void 0){return}if(headerCell){[headerCell].concat(this._emptyCells).forEach(cell=>{if(cell){const existingHandle=cell.querySelector("[part~=\"resize-handle\"]");if(existingHandle){cell.removeChild(existingHandle)}if(resizable){const handle=document.createElement("div");handle.setAttribute("part","resize-handle");cell.appendChild(handle)}}})}}_textAlignChanged(textAlign,_cells,_headerCell,_footerCell){if(textAlign===void 0){return}if(-1===["start","end","center"].indexOf(textAlign)){console.warn("textAlign can only be set as \"start\", \"end\" or \"center\"");return}let textAlignFallback;if("ltr"===getComputedStyle(this._grid).direction){if("start"===textAlign){textAlignFallback="left"}else if("end"===textAlign){textAlignFallback="right"}}else{if("start"===textAlign){textAlignFallback="right"}else if("end"===textAlign){textAlignFallback="left"}}this._allCells.forEach(cell=>{cell._content.style.textAlign=textAlign;if(getComputedStyle(cell._content).textAlign!==textAlign){cell._content.style.textAlign=textAlignFallback}})}_hiddenChanged(hidden,headerCell,footerCell,cells){if(this.parentElement&&this.parentElement._columnPropChanged){this.parentElement._columnPropChanged("hidden",hidden)}if(!!hidden!==!!this._previousHidden&&this._grid){if(!0===hidden){this._allCells.forEach(cell=>{if(cell._content.parentNode){cell._content.parentNode.removeChild(cell._content)}})}this._grid._debouncerHiddenChanged=Polymer.Debouncer.debounce(this._grid._debouncerHiddenChanged,Polymer.Async.animationFrame,()=>{if(this._grid&&this._grid._renderColumnTree){this._grid._renderColumnTree(this._grid._columnTree)}});this._grid._updateLastFrozen&&this._grid._updateLastFrozen();this._grid.notifyResize&&this._grid.notifyResize();this._grid._resetKeyboardNavigation&&this._grid._resetKeyboardNavigation()}this._previousHidden=hidden}};</script><dom-module id="vaadin-grid-column" assetpath="../bower_components/vaadin-grid/src/"><script>(function(){/**
     * A `<vaadin-grid-column>` is used to configure how a column in `<vaadin-grid>`
     * should look like.
     *
     * See `<vaadin-grid>` documentation and demos for instructions and examples on how
     * to configure the `<vaadin-grid-column>`.
     * ```
     *
     * @memberof Vaadin
     * @mixes Vaadin.Grid.ColumnBaseMixin
     */class GridColumnElement extends Vaadin.Grid.ColumnBaseMixin(Vaadin.DirMixin(Polymer.Element)){static get is(){return"vaadin-grid-column"}static get properties(){return{/**
           * Width of the cells for this column.
           */width:{type:String,value:"100px"},/**
           * Flex grow ratio for the cell widths. When set to 0, cell width is fixed.
           */flexGrow:{type:Number,value:1},/**
           * Custom function for rendering the cell content.
           * Receives three arguments:
           *
           * - `root` The cell content DOM element. Append your content to it.
           * - `column` The `<vaadin-grid-column>` element.
           * - `rowData` The object with the properties related with
           *   the rendered item, contains:
           *   - `rowData.index` The index of the item.
           *   - `rowData.item` The item.
           *   - `rowData.expanded` Sublevel toggle state.
           *   - `rowData.level` Level of the tree represented with a horizontal offset of the toggle button.
           *   - `rowData.selected` Selected state.
           */renderer:Function,/**
           * Path to an item sub-property whose value gets displayed in the column body cells.
           * The property name is also shown in the column header if an explicit header or renderer isn't defined.
           */path:{type:String},/**
           * Automatically sets the width of the column based on the column contents when this is set to `true`.
           *
           * For performance reasons the column width is calculated automatically only once when the grid items
           * are rendered for the first time and the calculation only considers the rows which are currently
           * rendered in DOM (a bit more than what is currently visible). If the grid is scrolled, or the cell
           * content changes, the column width might not match the contents anymore.
           *
           * Hidden columns are ignored in the calculation and their widths are not automatically updated when
           * you show a column that was initially hidden.
           *
           * You can manually trigger the auto sizing behavior again by calling `grid.recalculateColumnWidths()`.
           *
           * The column width may still grow larger when `flexGrow` is not 0.
           */autoWidth:{type:Boolean,value:!1},_bodyTemplate:{type:Object},_cells:Array}}}customElements.define(GridColumnElement.is,GridColumnElement);/**
     * @namespace Vaadin
     */window.Vaadin=window.Vaadin||{};Vaadin.GridColumnElement=GridColumnElement})();</script></dom-module><dom-module id="vaadin-grid-outer-scroller" assetpath="../bower_components/vaadin-grid/src/"><template><style>:host{display:block;height:100%;width:100%;position:absolute;top:0;box-sizing:border-box;overflow:auto;}:host([passthrough]){pointer-events:none;}</style><slot></slot></template></dom-module><script>(function(){/**
     * This Element is used internally by vaadin-grid.
     *
     * @private
     */class GridOuterScrollerElement extends class extends Polymer.Element{}{static get is(){return"vaadin-grid-outer-scroller"}static get properties(){return{scrollTarget:{type:Object},scrollHandler:{type:Object},passthrough:{type:Boolean,reflectToAttribute:!0,value:!0},outerScrolling:Boolean,noScrollbars:Boolean,_touchDevice:Boolean}}ready(){super.ready();this.addEventListener("scroll",()=>this._syncScrollTarget());this.parentElement.addEventListener("mousemove",this._onMouseMove.bind(this));// for some reason scroll bars are hidden in iOS if this style is
// added in stylesheets or before attaching.
this.style.webkitOverflowScrolling="touch";this.addEventListener("mousedown",_=>this.outerScrolling=!0);this.addEventListener("mouseup",_=>{this.outerScrolling=!1;this.scrollHandler._scrollHandler()})}_onMouseMove(e){// Ignore mousemove events on touch devices
if(!this._touchDevice){if(this.noScrollbars&&this.parentElement.hasAttribute("scroll-period")){this.passthrough=e.offsetY<=this.clientHeight-20&&e.offsetX<=this.clientWidth-20}else{this.passthrough=e.offsetY<=this.clientHeight&&e.offsetX<=this.clientWidth}}}syncOuterScroller(){this.scrollTop=this.scrollTarget.scrollTop;this.scrollLeft=this.scrollTarget.scrollLeft}_syncScrollTarget(){requestAnimationFrame(()=>{this.scrollTarget.scrollTop=this.scrollTop;this.scrollTarget.scrollLeft=this.scrollLeft;this.scrollHandler._scrollHandler()})}}customElements.define(GridOuterScrollerElement.is,GridOuterScrollerElement)})();</script><script>const VaadinGridStyles=document.createElement("dom-module");// NOTE(web-padawan): https://github.com/vaadin/vaadin-grid/issues/1514
VaadinGridStyles.appendChild(Polymer.html`
    <style>
      @keyframes vaadin-grid-appear {
        to {
          opacity: 1;
        }
      }

      :host {
        display: block;
        animation: 1ms vaadin-grid-appear;
        height: 400px;
        flex: 1 1 auto;
        align-self: stretch;
        position: relative;
      }

      :host([hidden]) {
        display: none !important;
      }

      #scroller {
        display: block;
        transform: translateY(0);
        width: auto;
        height: auto;
        position: absolute;
        top: 0;
        right: 0;
        bottom: 0;
        left: 0;
      }

      :host([height-by-rows]) {
        height: auto;
        align-self: flex-start;
        flex-grow: 0;
        width: 100%;
      }

      :host([height-by-rows]) #scroller {
        width: 100%;
        height: 100%;
        position: relative;
      }

      #table {
        display: block;
        width: 100%;
        height: 100%;
        overflow: auto;
        z-index: -2;
        position: relative;
        outline: none;
      }

      #header {
        display: block;
        position: absolute;
        top: 0;
        width: 100%;
      }

      th {
        text-align: inherit;
      }

      /* Safari doesn't work with "inherit" */
      [safari] th {
        text-align: initial;
      }

      #footer {
        display: block;
        position: absolute;
        bottom: 0;
        width: 100%;
      }

      #items {
        display: block;
        width: 100%;
        position: relative;
        z-index: -1;
      }

      #items,
      #outersizer,
      #fixedsizer {
        border-top: 0 solid transparent;
        border-bottom: 0 solid transparent;
      }

      [part~="row"] {
        display: flex;
        width: 100%;
        box-sizing: border-box;
        margin: 0;
      }

      [part~="row"][loading] [part~="body-cell"] ::slotted(vaadin-grid-cell-content) {
        opacity: 0;
      }

      #items [part~="row"] {
        position: absolute;
      }

      #items [part~="row"]:empty {
        height: 1em;
      }

      [part~="cell"]:not([part~="details-cell"]) {
        flex-shrink: 0;
        flex-grow: 1;
        box-sizing: border-box;
        display: flex;
        width: 100%;
        position: relative;
        align-items: center;
        padding: 0;
        white-space: nowrap;
      }

      [part~="details-cell"] {
        position: absolute;
        bottom: 0;
        width: 100%;
        box-sizing: border-box;
        padding: 0;
      }

      [part~="cell"] ::slotted(vaadin-grid-cell-content) {
        display: block;
        width: 100%;
        box-sizing: border-box;
        overflow: hidden;
        text-overflow: ellipsis;
      }

      [hidden] {
        display: none !important;
      }

      [frozen] {
        z-index: 2;
        will-change: transform;
      }

      #outerscroller {
        /* Needed (at least) for Android Chrome */
        z-index: 0;
      }

      #scroller:not([safari]) #outerscroller {
        /* Needed for Android Chrome (#1020). Can't be applied to Safari
        since it would re-introduce the sub-pixel overflow bug (#853) */
        will-change: transform;
      }

      [no-scrollbars]:not([safari]):not([firefox]) #outerscroller,
      [no-scrollbars][safari] #table,
      [no-scrollbars][firefox] #table {
        overflow: hidden;
      }

      [no-scrollbars]:not([safari]):not([firefox]) #outerscroller {
        pointer-events: none;
      }

      /* Reordering styles */
      :host([reordering]) [part~="cell"] ::slotted(vaadin-grid-cell-content),
      :host([reordering]) [part~="resize-handle"],
      #scroller[no-content-pointer-events] [part~="cell"] ::slotted(vaadin-grid-cell-content) {
        pointer-events: none;
      }

      [part~="reorder-ghost"] {
        visibility: hidden;
        position: fixed;
        pointer-events: none;
        opacity: 0.5;

        /* Prevent overflowing the grid in Firefox */
        top: 0;
        left: 0;
      }

      :host([reordering]) {
        -moz-user-select: none;
        -webkit-user-select: none;
        user-select: none;
      }

      #scroller[ie][column-reordering-allowed] [part~="header-cell"] {
        -ms-user-select: none;
      }

      :host([reordering]) #outerscroller {
        -webkit-overflow-scrolling: auto !important;
      }

      /* Resizing styles */
      [part~="resize-handle"] {
        position: absolute;
        top: 0;
        right: 0;
        height: 100%;
        cursor: col-resize;
        z-index: 1;
      }

      [part~="resize-handle"]::before {
        position: absolute;
        content: "";
        height: 100%;
        width: 35px;
        transform: translateX(-50%);
      }

      [last-column] [part~="resize-handle"]::before,
      [last-frozen] [part~="resize-handle"]::before {
        width: 18px;
        transform: none;
        right: 0;
      }

      #scroller[column-resizing] {
        -ms-user-select: none;
        -moz-user-select: none;
        -webkit-user-select: none;
        user-select: none;
      }

      /* Sizer styles */
      .sizer {
        display: flex;
        position: relative;
        width: 100%;
        visibility: hidden;
      }

      .sizer [part~="details-cell"] {
        display: none !important;
      }

      .sizer [part~="cell"][hidden] {
        display: none !important;
      }

      .sizer [part~="cell"] {
        display: block;
        flex-shrink: 0;
        line-height: 0;
        margin-top: -1em;
        height: 0 !important;
        min-height: 0 !important;
        max-height: 0 !important;
        padding: 0 !important;
      }

      .sizer [part~="cell"]::before {
        content: "-";
      }

      .sizer [part~="cell"] ::slotted(vaadin-grid-cell-content) {
        display: none !important;
      }

      /* Fixed mode (Tablet Edge) */
      #fixedsizer {
        position: absolute;
      }

      :not([edge][no-scrollbars]) #fixedsizer {
        display: none;
      }

      [edge][no-scrollbars] {
        /* Any value other than ‘none’ for the transform results in the creation of both a stacking context and
        a containing block. The object acts as a containing block for fixed positioned descendants. */
        transform: translateZ(0);
        overflow: hidden;
      }

      [edge][no-scrollbars] #header,
      [edge][no-scrollbars] #footer {
        position: fixed;
      }

      [edge][no-scrollbars] #items {
        position: fixed;
        width: 100%;
        will-change: transform;
      }

      /* RTL specific styles */

      :host([dir="rtl"]) [part~="reorder-ghost"] {
        left: auto;
        right: 0;
      }

      :host([dir="rtl"]) [part~="resize-handle"] {
        left: 0;
        right: auto;
      }

      :host([dir="rtl"]) [part~="resize-handle"]::before {
        transform: translateX(50%);
      }

      :host([dir="rtl"]) [last-column] [part~="resize-handle"]::before,
      :host([dir="rtl"]) [last-frozen] [part~="resize-handle"]::before {
        left: 0;
        right: auto;
      }
    </style>
  `);const safari=/^((?!chrome|android).)*safari/i.test(navigator.userAgent),firefox=-1<navigator.userAgent.toLowerCase().indexOf("firefox");if(safari||firefox){const scrollingStyles=document.createElement("style");scrollingStyles.textContent=`
      [scrolling][safari] #outerscroller,
      [scrolling][firefox] #outerscroller {
        pointer-events: auto;
      }

      [ios] #outerscroller {
        pointer-events: auto;
        z-index: -3;
      }

      [ios][scrolling] #outerscroller {
        z-index: 0;
      }

      [ios] [frozen] {
        will-change: auto;
      }
    `;VaadinGridStyles.querySelector("template").content.appendChild(scrollingStyles)}VaadinGridStyles.register("vaadin-grid-styles");</script><dom-module id="vaadin-grid" assetpath="../bower_components/vaadin-grid/src/"><template><style include="vaadin-grid-styles"></style><div id="scroller" no-scrollbars$="[[!_scrollbarWidth]]" wheel-scrolling$="[[_wheelScrolling]]" safari$="[[_safari]]" ios$="[[_ios]]" loading$="[[loading]]" edge$="[[_edge]]" firefox$="[[_firefox]]" ie$="[[_ie]]" column-reordering-allowed$="[[columnReorderingAllowed]]"><table id="table" role="grid" aria-multiselectable="true" tabindex="0"><caption id="fixedsizer" class="sizer" part="row"></caption><thead id="header" role="rowgroup"></thead><tbody id="items" role="rowgroup"></tbody><tfoot id="footer" role="rowgroup"></tfoot></table><div part="reorder-ghost"></div><vaadin-grid-outer-scroller id="outerscroller" _touch-device="[[_touchDevice]]" scroll-target="[[scrollTarget]]" scroll-handler="[[_this]]" no-scrollbars="[[!_scrollbarWidth]]"><div id="outersizer" class="sizer" part="row"></div></vaadin-grid-outer-scroller></div><slot name="nodistribute"></slot><div id="focusexit" tabindex="0"></div></template></dom-module><script>(function(){const TOUCH_DEVICE=(()=>{try{document.createEvent("TouchEvent");return!0}catch(e){return!1}})();/**
     *
     * `<vaadin-grid>` is a free, high quality data grid / data table Web Component. The content of the
     * the grid can be populated in two ways: imperatively by using renderer callback function and
     * declaratively by using Polymer's Templates.
     *
     * ### Quick Start
     *
     * Start with an assigning an array to the [`items`](#/elements/vaadin-grid#property-items) property to visualize your data.
     *
     * Use the [`<vaadin-grid-column>`](#/elements/vaadin-grid-column) element to configure the grid columns. Set `path` and `header`
     * shorthand properties for the columns to define what gets rendered in the cells of the column.
     *
     * #### Example:
     * ```html
     * <vaadin-grid>
     *   <vaadin-grid-column path="name.first" header="First name"></vaadin-grid-column>
     *   <vaadin-grid-column path="name.last" header="Last name"></vaadin-grid-column>
     *   <vaadin-grid-column path="email"></vaadin-grid-column>
     * </vaadin-grid>
     * ```
     *
     * For custom content `vaadin-grid-column` element provides you with three types of `renderer` callback functions: `headerRenderer`,
     * `renderer` and `footerRenderer`.
     *
     * Each of those renderer functions provides `root`, `column`, `rowData` arguments when applicable.
     * Generate DOM content, append it to the `root` element and control the state
     * of the host element by accessing `column`. Before generating new content,
     * users are able to check if there is already content in `root` for reusing it.
     *
     * Renderers are called on initialization of new column cells and each time the
     * related row data is updated. DOM generated during the renderer call can be reused
     * in the next renderer call and will be provided with the `root` argument.
     * On first call it will be empty.
     *
     * #### Example:
     * ```html
     * <vaadin-grid>
     *   <vaadin-grid-column></vaadin-grid-column>
     *   <vaadin-grid-column></vaadin-grid-column>
     *   <vaadin-grid-column></vaadin-grid-column>
     * </vaadin-grid>
     * ```
     * ```js
     * const grid = document.querySelector('vaadin-grid');
     * grid.items = [{'name': 'John', 'surname': 'Lennon', 'role': 'singer'},
     *               {'name': 'Ringo', 'surname': 'Starr', 'role': 'drums'}];
     *
     * const columns = grid.querySelectorAll('vaadin-grid-column');
     *
     * columns[0].headerRenderer = function(root) {
     *   root.textContent = 'Name';
     * };
     * columns[0].renderer = function(root, column, rowData) {
     *   root.textContent = rowData.item.name;
     * };
     *
     * columns[1].headerRenderer = function(root) {
     *   root.textContent = 'Surname';
     * };
     * columns[1].renderer = function(root, column, rowData) {
     *   root.textContent = rowData.item.surname;
     * };
     *
     * columns[2].headerRenderer = function(root) {
     *   root.textContent = 'Role';
     * };
     * columns[2].renderer = function(root, column, rowData) {
     *   root.textContent = rowData.item.role;
     * };
     * ```
     *
     * Alternatively, the content can be provided with Polymer's Templates:
     *
     * #### Example:
     * ```html
     * <vaadin-grid items='[{"name": "John", "surname": "Lennon", "role": "singer"},
     * {"name": "Ringo", "surname": "Starr", "role": "drums"}]'>
     *   <vaadin-grid-column>
     *     <template class="header">Name</template>
     *     <template>[[item.name]]</template>
     *   </vaadin-grid-column>
     *   <vaadin-grid-column>
     *     <template class="header">Surname</template>
     *     <template>[[item.surname]]</template>
     *   </vaadin-grid-column>
     *   <vaadin-grid-column>
     *     <template class="header">Role</template>
     *     <template>[[item.role]]</template>
     *   </vaadin-grid-column>
     * </vaadin-grid>
     * ```
     *
     * The following helper elements can be used for further customization:
     * - [`<vaadin-grid-column-group>`](#/elements/vaadin-grid-column-group)
     * - [`<vaadin-grid-filter>`](#/elements/vaadin-grid-filter)
     * - [`<vaadin-grid-sorter>`](#/elements/vaadin-grid-sorter)
     * - [`<vaadin-grid-selection-column>`](#/elements/vaadin-grid-selection-column)
     * - [`<vaadin-grid-tree-toggle>`](#/elements/vaadin-grid-tree-toggle)
     *
     * __Note that the helper elements must be explicitly imported.__
     * If you want to import everything at once you can use the `all-imports.html` bundle.
     *
     * A column template can be decorated with one the following class names to specify its purpose
     * - `header`: Marks a header template
     * - `footer`: Marks a footer template
     * - `row-details`: Marks a row details template
     *
     * The following built-in template variables can be bound to inside the column templates:
     * - `[[index]]`: Number representing the row index
     * - `[[item]]` and it's sub-properties: Data object (provided by a data provider / items array)
     * - `{{selected}}`: True if the item is selected (can be two-way bound)
     * - `{{detailsOpened}}`: True if the item has row details opened (can be two-way bound)
     * - `{{expanded}}`: True if the item has tree sublevel expanded (can be two-way bound)
     * - `[[level]]`: Number of the tree sublevel of the item, first level-items have 0
     *
     * ### Lazy Loading with Function Data Provider
     *
     * In addition to assigning an array to the items property, you can alternatively
     * provide the `<vaadin-grid>` data through the
     * [`dataProvider`](#/elements/vaadin-grid#property-dataProvider) function property.
     * The `<vaadin-grid>` calls this function lazily, only when it needs more data
     * to be displayed.
     *
     * See the [`dataProvider`](#/elements/vaadin-grid#property-dataProvider) in
     * the API reference below for the detailed data provider arguments description,
     * and the “Assigning Data” page in the demos.
     *
     * __Note that expanding the tree grid's item will trigger a call to the `dataProvider`.__
     *
     * __Also, note that when using function data providers, the total number of items
     * needs to be set manually. The total number of items can be returned
     * in the second argument of the data provider callback:__
     *
     * ```javascript
     * grid.dataProvider = function(params, callback) {
     *   var url = 'https://api.example/data' +
     *       '?page=' + params.page +        // the requested page index
     *       '&per_page=' + params.pageSize; // number of items on the page
     *   var xhr = new XMLHttpRequest();
     *   xhr.onload = function() {
     *     var response = JSON.parse(xhr.responseText);
     *     callback(
     *       response.employees, // requested page of items
     *       response.totalSize  // total number of items
     *     );
     *   };
     *   xhr.open('GET', url, true);
     *   xhr.send();
     * };
     * ```
     *
     * __Alternatively, you can use the `size` property to set the total number of items:__
     *
     * ```javascript
     * grid.size = 200; // The total number of items
     * grid.dataProvider = function(params, callback) {
     *   var url = 'https://api.example/data' +
     *       '?page=' + params.page +        // the requested page index
     *       '&per_page=' + params.pageSize; // number of items on the page
     *   var xhr = new XMLHttpRequest();
     *   xhr.onload = function() {
     *     var response = JSON.parse(xhr.responseText);
     *     callback(response.employees);
     *   };
     *   xhr.open('GET', url, true);
     *   xhr.send();
     * };
     * ```
     *
     * ### Styling
     *
     * The following shadow DOM parts are available for styling:
     *
     * Part name | Description
     * ----------------|----------------
     * `row` | Row in the internal table
     * `cell` | Cell in the internal table
     * `header-cell` | Header cell in the internal table
     * `body-cell` | Body cell in the internal table
     * `footer-cell` | Footer cell in the internal table
     * `details-cell` | Row details cell in the internal table
     * `resize-handle` | Handle for resizing the columns
     * `reorder-ghost` | Ghost element of the header cell being dragged
     *
     * The following state attributes are available for styling:
     *
     * Attribute    | Description | Part name
     * -------------|-------------|------------
     * `loading` | Set when the grid is loading data from data provider | :host
     * `interacting` | Keyboard navigation in interaction mode | :host
     * `navigating` | Keyboard navigation in navigation mode | :host
     * `overflow` | Set when rows are overflowing the grid viewport. Possible values: `top`, `bottom`, `left`, `right` | :host
     * `reordering` | Set when the grid's columns are being reordered | :host
     * `dragover` | Set when the grid (not a specific row) is dragged over | :host
     * `dragging-rows` : Set when grid rows are dragged  | :host
     * `reorder-status` | Reflects the status of a cell while columns are being reordered | cell
     * `frozen` | Frozen cell | cell
     * `last-frozen` | Last frozen cell | cell
   * * `first-column` | First visible cell on a row | cell
     * `last-column` | Last visible cell on a row | cell
     * `selected` | Selected row | row
     * `expanded` | Expanded row | row
     * `details-opened` | Row with details open | row
     * `loading` | Row that is waiting for data from data provider | row
     * `odd` | Odd row | row
     * `first` | The first body row | row
     * `dragstart` | Set for one frame when drag of a row is starting. The value is a number when multiple rows are dragged | row
     * `dragover` | Set when the row is dragged over | row
     * `drag-disabled` | Set to a row that isn't available for dragging | row
     * `drop-disabled` | Set to a row that can't be dropped on top of | row
     *
     * See [ThemableMixin – how to apply styles for shadow parts](https://github.com/vaadin/vaadin-themable-mixin/wiki)
     *
     * @memberof Vaadin
     * @mixes Vaadin.ThemableMixin
     * @mixes Vaadin.Grid.A11yMixin
     * @mixes Vaadin.Grid.ActiveItemMixin
     * @mixes Vaadin.Grid.ArrayDataProviderMixin
     * @mixes Vaadin.Grid.ColumnResizingMixin
     * @mixes Vaadin.Grid.DataProviderMixin
     * @mixes Vaadin.Grid.DynamicColumnsMixin
     * @mixes Vaadin.Grid.FilterMixin
     * @mixes Vaadin.Grid.RowDetailsMixin
     * @mixes Vaadin.Grid.ScrollMixin
     * @mixes Vaadin.Grid.SelectionMixin
     * @mixes Vaadin.Grid.SortMixin
     * @mixes Vaadin.Grid.KeyboardNavigationMixin
     * @mixes Vaadin.Grid.ColumnReorderingMixin
     * @mixes Vaadin.Grid.EventContextMixin
     * @mixes Vaadin.Grid.StylingMixin
     * @mixes Vaadin.Grid.DragAndDropMixin
     * @demo demo/index.html
     */class GridElement extends Vaadin.ElementMixin(Vaadin.ThemableMixin(Vaadin.Grid.DataProviderMixin(Vaadin.Grid.ArrayDataProviderMixin(Vaadin.Grid.DynamicColumnsMixin(Vaadin.Grid.ActiveItemMixin(Vaadin.Grid.ScrollMixin(Vaadin.Grid.SelectionMixin(Vaadin.Grid.SortMixin(Vaadin.Grid.RowDetailsMixin(Vaadin.Grid.KeyboardNavigationMixin(Vaadin.Grid.A11yMixin(Vaadin.Grid.FilterMixin(Vaadin.Grid.ColumnReorderingMixin(Vaadin.Grid.ColumnResizingMixin(Vaadin.Grid.EventContextMixin(Vaadin.Grid.DragAndDropMixin(Vaadin.Grid.StylingMixin(Vaadin.Grid.ScrollerElement)))))))))))))))))){static get is(){return"vaadin-grid"}static get version(){return"5.6.7"}static get observers(){return["_columnTreeChanged(_columnTree, _columnTree.*)"]}static get properties(){return{_this:{type:Object,value:function(){return this}},_safari:{type:Boolean,value:/^((?!chrome|android).)*safari/i.test(navigator.userAgent)},_ios:{type:Boolean,value:/iPad|iPhone|iPod/.test(navigator.userAgent)&&!window.MSStream||"MacIntel"===navigator.platform&&1<navigator.maxTouchPoints},_edge:{type:Boolean,value:"undefined"!==typeof CSS&&CSS.supports("(-ms-ime-align:auto)")},_ie:{type:Boolean,value:!!(navigator.userAgent.match(/Trident/)&&!navigator.userAgent.match(/MSIE/))},_firefox:{type:Boolean,value:-1<navigator.userAgent.toLowerCase().indexOf("firefox")},_android:{type:Boolean,value:/android/i.test(navigator.userAgent)},_touchDevice:{type:Boolean,value:TOUCH_DEVICE},/**
           * If true, the grid's height is defined by its rows.
           *
           * Effectively, this disables the grid's virtual scrolling so that all the rows are rendered in the DOM at once.
           * If the grid has a large number of items, using the feature is discouraged to avoid performance issues.
           */heightByRows:{type:Boolean,value:!1,reflectToAttribute:!0,observer:"_heightByRowsChanged"},_recalculateColumnWidthOnceLoadingFinished:{type:Boolean,value:!0}}}constructor(){super();this.addEventListener("animationend",this._onAnimationEnd)}connectedCallback(){super.connectedCallback();this.recalculateColumnWidths()}attributeChangedCallback(name,oldValue,newValue){super.attributeChangedCallback(name,oldValue,newValue);if("dir"===name){this.__isRTL="rtl"===newValue;this._updateScrollerMeasurements()}}__hasRowsWithClientHeight(){return!!Array.from(this.$.items.children).filter(row=>row.clientHeight).length}__itemsReceived(){if(this._recalculateColumnWidthOnceLoadingFinished&&!this._cache.isLoading()&&this.__hasRowsWithClientHeight()){this._recalculateColumnWidthOnceLoadingFinished=!1;this.recalculateColumnWidths()}}/**
       * @param {Array<Vaadin.GridColumnElement>} cols the columns to auto size based on their content width
       */_recalculateColumnWidths(cols){// Note: The `cols.forEach()` loops below could be implemented as a single loop but this has been
// split for performance reasons to batch these similar actions [write/read] together to avoid
// unnecessary layout trashing.
// [write] Set automatic width for all cells (breaks column alignment)
cols.forEach(col=>{col.width="auto";col._origFlexGrow=col.flexGrow;col.flexGrow=0});// [read] Measure max cell width in each column
cols.forEach(col=>{col._currentWidth=0;// Note: _allCells only contains cells which are currently rendered in DOM
col._allCells.forEach(c=>{// Add 1px buffer to the offset width to avoid too narrow columns (sub-pixel rendering)
const cellWidth=c.offsetWidth+1;col._currentWidth=Math.max(col._currentWidth,cellWidth)})});// [write] Set column widths to fit widest measured content
cols.forEach(col=>{col.width=`${col._currentWidth}px`;col.flexGrow=col._origFlexGrow;col._currentWidth=void 0;col._origFlexGrow=void 0})}/**
       * Updates the `width` of all columns which have `autoWidth` set to `true`.
       */recalculateColumnWidths(){if(!this._columnTree){return;// No columns
}if(this._cache.isLoading()){this._recalculateColumnWidthOnceLoadingFinished=!0}else{const cols=this._getColumns().filter(col=>!col.hidden&&col.autoWidth);this._recalculateColumnWidths(cols)}}_createScrollerRows(count){const rows=[];for(var i=0;i<count;i++){const row=document.createElement("tr");row.setAttribute("part","row");row.setAttribute("role","row");if(this._columnTree){this._updateRow(row,this._columnTree[this._columnTree.length-1],"body",!1,!0)}rows.push(row)}if(this._columnTree){this._columnTree[this._columnTree.length-1].forEach(c=>c.notifyPath&&c.notifyPath("_cells.*",c._cells))}Polymer.RenderStatus.beforeNextRender(this,()=>{this._updateFirstAndLastColumn();this._resetKeyboardNavigation()});return rows}_getRowTarget(){return this.$.items}_createCell(tagName){const contentId=this._contentIndex=this._contentIndex+1||0,slotName="vaadin-grid-cell-content-"+contentId,cellContent=document.createElement("vaadin-grid-cell-content");cellContent.setAttribute("slot",slotName);const cell=document.createElement(tagName);cell.id=slotName.replace("-content-","-");cell.setAttribute("tabindex","-1");cell.setAttribute("role","td"===tagName?"gridcell":"columnheader");const slot=document.createElement("slot");slot.setAttribute("name",slotName);cell.appendChild(slot);cell._content=cellContent;// With native Shadow DOM, mousedown on slotted element does not focus
// focusable slot wrapper, that is why cells are not focused with
// mousedown. Workaround: listen for mousedown and focus manually.
cellContent.addEventListener("mousedown",()=>{if(window.chrome){// Chrome bug: focusing before mouseup prevents text selection, see http://crbug.com/771903
const mouseUpListener=()=>{if(!cellContent.contains(this.getRootNode().activeElement)){cell.focus()}// If focus is in the cell content — respect it, do not change.
document.removeEventListener("mouseup",mouseUpListener,!0)};document.addEventListener("mouseup",mouseUpListener,!0)}else{// Focus on mouseup, on the other hand, removes selection on Safari.
// Watch out sync focus removal issue, only async focus works here.
setTimeout(()=>{if(!cellContent.contains(this.getRootNode().activeElement)){cell.focus()}})}});return cell}_updateRow(row,columns,section,isColumnRow,noNotify){section=section||"body";const contentsFragment=document.createDocumentFragment();Array.from(row.children).forEach(cell=>cell._vacant=!0);row.innerHTML="";if("outersizer"!==row.id&&"fixedsizer"!==row.id){row.hidden=!0}columns.filter(column=>!column.hidden).forEach((column,index,cols)=>{let cell;if("body"===section){// Body
column._cells=column._cells||[];cell=column._cells.filter(cell=>cell._vacant)[0];if(!cell){cell=this._createCell("td");column._cells.push(cell)}cell.setAttribute("part","cell body-cell");row.appendChild(cell);if(index===cols.length-1&&(this._rowDetailsTemplate||this.rowDetailsRenderer)){// Add details cell as last cell to body rows
this._detailsCells=this._detailsCells||[];const detailsCell=this._detailsCells.filter(cell=>cell._vacant)[0]||this._createCell("td");if(-1===this._detailsCells.indexOf(detailsCell)){this._detailsCells.push(detailsCell)}if(!detailsCell._content.parentElement){contentsFragment.appendChild(detailsCell._content)}this._configureDetailsCell(detailsCell);row.appendChild(detailsCell);this._a11ySetRowDetailsCell(row,detailsCell);detailsCell._vacant=!1}if(column.notifyPath&&!noNotify){column.notifyPath("_cells.*",column._cells)}}else{// Header & footer
const tagName="header"===section?"th":"td";if(isColumnRow||"vaadin-grid-column-group"===column.localName){cell=column[`_${section}Cell`]||this._createCell(tagName);cell._column=column;row.appendChild(cell);column[`_${section}Cell`]=cell}else{column._emptyCells=column._emptyCells||[];cell=column._emptyCells.filter(cell=>cell._vacant)[0]||this._createCell(tagName);cell._column=column;row.appendChild(cell);if(-1===column._emptyCells.indexOf(cell)){column._emptyCells.push(cell)}}cell.setAttribute("part",`cell ${section}-cell`);this.__updateHeaderFooterRowVisibility(row)}if(!cell._content.parentElement){contentsFragment.appendChild(cell._content)}cell._vacant=!1;cell._column=column});// Might be empty if only cache was used
this.appendChild(contentsFragment);this._frozenCellsChanged();this._updateFirstAndLastColumnForRow(row)}__updateHeaderFooterRowVisibility(row){if(!row){return}const visibleRowCells=Array.from(row.children).filter(cell=>{const column=cell._column;if(column._emptyCells&&-1<column._emptyCells.indexOf(cell)){// The cell is an "empty cell"  -> doesn't block hiding the row
return!1}if(row.parentElement===this.$.header){if(column.headerRenderer||column._headerTemplate){// The cell is the header cell of a column that has a header renderer
// or a header template -> row should be visible
return!0}if(null===column.header){// The column header is explicilty set to null -> doesn't block hiding the row
return!1}if(column.path||column.header!==void 0){// The column has an explicit non-null header or a path that generates a header
// -> row should be visible
return!0}}else{if(column.footerRenderer||column._footerTemplate){// The cell is the footer cell of a column that has a footer renderer
// or a footer template -> row should be visible
return!0}}});if(row.hidden!==!visibleRowCells.length){row.hidden=!visibleRowCells.length;this.notifyResize()}}_updateScrollerItem(row,index){this._preventScrollerRotatingCellFocus(row,index);if(!this._columnTree){return}this._toggleAttribute("first",0===index,row);this._toggleAttribute("odd",index%2,row);this._a11yUpdateRowRowindex(row,index);this._getItem(index,row)}_columnTreeChanged(columnTree,splices){this._renderColumnTree(columnTree);this.recalculateColumnWidths()}_renderColumnTree(columnTree){Array.from(this.$.items.children).forEach(row=>this._updateRow(row,columnTree[columnTree.length-1],null,!1,!0));while(this.$.header.children.length<columnTree.length){const headerRow=document.createElement("tr");headerRow.setAttribute("part","row");headerRow.setAttribute("role","row");this.$.header.appendChild(headerRow);const footerRow=document.createElement("tr");footerRow.setAttribute("part","row");footerRow.setAttribute("role","row");this.$.footer.appendChild(footerRow)}while(this.$.header.children.length>columnTree.length){this.$.header.removeChild(this.$.header.firstElementChild);this.$.footer.removeChild(this.$.footer.firstElementChild)}Array.from(this.$.header.children).forEach((headerRow,index)=>this._updateRow(headerRow,columnTree[index],"header",index===columnTree.length-1));Array.from(this.$.footer.children).forEach((footerRow,index)=>this._updateRow(footerRow,columnTree[columnTree.length-1-index],"footer",0===index));// Sizer rows
this._updateRow(this.$.outersizer,columnTree[columnTree.length-1],null,!1,!0);this._updateRow(this.$.fixedsizer,columnTree[columnTree.length-1]);this._resizeHandler();this._frozenCellsChanged();this._updateFirstAndLastColumn();this._resetKeyboardNavigation();this._a11yUpdateHeaderRows();this._a11yUpdateFooterRows()}_updateItem(row,item){row._item=item;const model=this.__getRowModel(row);this._toggleAttribute("selected",model.selected,row);this._a11yUpdateRowSelected(row,model.selected);this._a11yUpdateRowLevel(row,model.level);this._toggleAttribute("expanded",model.expanded,row);if(this._rowDetailsTemplate||this.rowDetailsRenderer){this._toggleDetailsCell(row,item)}this._generateCellClassNames(row,model);this._filterDragAndDrop(row,model);Array.from(row.children).forEach(cell=>{if(cell._renderer){const owner=cell._column||this;cell._renderer.call(owner,cell._content,owner,model)}else if(cell._instance){cell._instance.__detailsOpened__=model.detailsOpened;cell._instance.__selected__=model.selected;cell._instance.__level__=model.level;cell._instance.__expanded__=model.expanded;cell._instance.setProperties(model)}});this._debouncerUpdateHeights=Polymer.Debouncer.debounce(this._debouncerUpdateHeights,Polymer.Async.timeOut.after(1),()=>{this._updateMetrics();this._positionItems();this._updateScrollerSize()})}_resizeHandler(){this._updateDetailsCellHeights();this._accessIronListAPI(super._resizeHandler,!0);this._updateScrollerMeasurements();this._updateHeaderFooterMetrics()}_updateHeaderFooterMetrics(){const headerHeight=this.$.header.clientHeight+"px",footerHeight=this.$.footer.clientHeight+"px";[this.$.outersizer,this.$.fixedsizer,this.$.items].forEach(element=>{element.style.borderTopWidth=headerHeight;element.style.borderBottomWidth=footerHeight});Polymer.RenderStatus.afterNextRender(this.$.header,()=>{if(this._pendingScrollToIndex){this._scrollToIndex(this._pendingScrollToIndex)}})}_onAnimationEnd(e){// ShadyCSS applies scoping suffixes to animation names
if(0===e.animationName.indexOf("vaadin-grid-appear")){this._render();this._updateHeaderFooterMetrics();e.stopPropagation();this.notifyResize();this.__itemsReceived()}}_toggleAttribute(name,bool,node){if(node.hasAttribute(name)===!bool){if(bool){node.setAttribute(name,"")}else{node.removeAttribute(name)}}}__getRowModel(row){return{index:row.index,item:row._item,level:this._getIndexLevel(row.index),expanded:this._isExpanded(row._item),selected:this._isSelected(row._item),detailsOpened:!!(this._rowDetailsTemplate||this.rowDetailsRenderer)&&this._isDetailsOpened(row._item)}}/**
       * Manually invoke existing renderers for all the columns
       * (header, footer and body cells) and opened row details.
       */render(){if(this._columnTree){// header and footer renderers
this._columnTree.forEach(level=>{level.forEach(column=>column._renderHeaderAndFooter())});// body and row details renderers
this._update()}}/**
       * Updates the computed metrics and positioning of internal grid parts
       * (row/details cell positioning etc). Needs to be invoked whenever the sizing of grid
       * content changes asynchronously to ensure consistent appearance (e.g. when a
       * contained image whose bounds aren't known beforehand finishes loading).
       */notifyResize(){super.notifyResize()}_heightByRowsChanged(value,oldValue){if(value||oldValue){this.notifyResize()}}__forceReflow(){this._debouncerForceReflow=Polymer.Debouncer.debounce(this._debouncerForceReflow,Polymer.Async.animationFrame,()=>{this.$.scroller.style.overflow="hidden";setTimeout(()=>this.$.scroller.style.overflow="")})}}customElements.define(GridElement.is,GridElement);/**
     * @namespace Vaadin
     */window.Vaadin.GridElement=GridElement})();</script><dom-module id="lumo-grid-sorter" theme-for="vaadin-grid-sorter" assetpath="../bower_components/vaadin-grid/theme/lumo/"><template><style>:host{justify-content:flex-start;align-items:baseline;-webkit-user-select:none;-moz-user-select:none;user-select:none;}[part="content"]{display:inline-block;overflow:hidden;text-overflow:ellipsis;}[part="indicators"]{margin-left:var(--lumo-space-s);}:host(:not([direction])) [part="indicators"]::before{opacity:0.2;}:host([direction]){color:var(--lumo-primary-text-color);}[part="order"]{font-size:var(--lumo-font-size-xxs);line-height:1;}:host([dir="rtl"]) [part="indicators"]{margin-right:var(--lumo-space-s);margin-left:0;}</style></template></dom-module><custom-style><style>@font-face{font-family:'vaadin-grid-sorter-icons';src:url("data:application/font-woff;charset=utf-8;base64,d09GRgABAAAAAAQwAA0AAAAABuwAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAABGRlRNAAAEFAAAABkAAAAcfep+mUdERUYAAAP4AAAAHAAAAB4AJwAOT1MvMgAAAZgAAAA/AAAAYA8TBPpjbWFwAAAB7AAAAFUAAAFeF1fZ4mdhc3AAAAPwAAAACAAAAAgAAAAQZ2x5ZgAAAlgAAABcAAAAnMvguMloZWFkAAABMAAAAC8AAAA2C5Ap72hoZWEAAAFgAAAAHQAAACQGbQPHaG10eAAAAdgAAAAUAAAAHAoAAABsb2NhAAACRAAAABIAAAASAIwAYG1heHAAAAGAAAAAFgAAACAACwAKbmFtZQAAArQAAAECAAACZxWCgKhwb3N0AAADuAAAADUAAABZCrApUXicY2BkYGAA4rDECVrx/DZfGbhZGEDgyqNPOxH0/wNMq5kPALkcDEwgUQBWRA0dAHicY2BkYGA+8P8AAwMLAwgwrWZgZEAFbABY4QM8AAAAeJxjYGRgYOAAQiYGEICQSAAAAi8AFgAAeJxjYGY6yziBgZWBgWkm0xkGBoZ+CM34msGYkZMBFTAKoAkwODAwvmRiPvD/AIMDMxCD1CDJKjAwAgBktQsXAHicY2GAAMZQCM0EwqshbAALxAEKeJxjYGBgZoBgGQZGBhCIAPIYwXwWBhsgzcXAwcAEhIwMCi+Z/v/9/x+sSuElA4T9/4k4K1gHFwMMMILMY2QDYmaoABOQYGJABUA7WBiGNwAAJd4NIQAAAAAAAAAACAAIABAAGAAmAEAATgAAeJyNjLENgDAMBP9tIURJwQCMQccSZgk2i5fIYBDAidJjycXr7x5EPwE2wY8si7jmyBNXGo/bNBerxJNrpxhbO3/fEFpx8ZICpV+ghxJ74fAMe+h7Ox14AbrsHB14nK2QQWrDMBRER4mTkhQK3ZRQKOgCNk7oGQqhhEIX2WSlWEI1BAlkJ5CDdNsj5Ey9Rncdi38ES+jzNJo/HwTgATcoDEthhY3wBHc4CE+pfwsX5F/hGe7Vo/AcK/UhvMSz+mGXKhZU6pww8ISz3oWn1BvhgnwTnuEJf8Jz1OpFeIlX9YULDLdFi4ASHolkSR0iuYdjLak1vAequBhj21D61Nqyi6l3qWybGPjySbPHGScGJl6dP58MYcQRI0bts7mjebBqrFENH7t3qWtj0OuqHnXcW7b0HOTZFnKryRGW2hFX1m0O2vEM3opNMfTau+CS6Z3Vx6veNnEXY6jwDxhsc2gAAHicY2BiwA84GBgYmRiYGJkZmBlZGFkZ2djScyoLMgzZS/MyDQwMwLSrpYEBlIbxjQDrzgsuAAAAAAEAAf//AA94nGNgZGBg4AFiMSBmYmAEQnYgZgHzGAAD6wA2eJxjYGBgZACCKyoz1cD0o087YTQATOcIewAAAA==") format('woff');font-weight:normal;font-style:normal;}</style></custom-style><dom-module id="vaadin-grid-sorter" assetpath="../bower_components/vaadin-grid/src/"><template><style>:host{display:inline-flex;cursor:pointer;max-width:100%;}[part="content"]{flex:1 1 auto;}[part="indicators"]{position:relative;align-self:center;flex:none;}[part="order"]{display:inline;vertical-align:super;}[part="indicators"]::before{font-family:'vaadin-grid-sorter-icons';display:inline-block;}:host(:not([direction])) [part="indicators"]::before{content:"\e901";}:host([direction=asc]) [part="indicators"]::before{content:"\e900";}:host([direction=desc]) [part="indicators"]::before{content:"\e902";}</style><div part="content"><slot></slot></div><div part="indicators"><span part="order">[[_getDisplayOrder(_order)]]</span></div></template><script>(function(){/**
       * `<vaadin-grid-sorter>` is a helper element for the `<vaadin-grid>` that provides out-of-the-box UI controls,
       * visual feedback, and handlers for sorting the grid data.
       *
       * #### Example:
       * ```html
       * <vaadin-grid-column>
       *   <template class="header">
       *     <vaadin-grid-sorter path="name.first">First name</vaadin-grid-sorter>
       *   </template>
       *   <template>[[item.name.first]]</template>
       * </vaadin-grid-column>
       * ```
       *
       * ### Styling
       *
       * The following shadow DOM parts are available for styling:
       *
       * Part name | Description
       * ----------------|----------------
       * `content` | The slotted content wrapper
       * `indicators` | The internal sorter indicators.
       * `order` | The internal sorter order
       *
       * The following state attributes are available for styling:
       *
       * Attribute    | Description | Part name
       * -------------|-------------|------------
       * `direction` | Sort direction of a sorter | :host
       *
       * @memberof Vaadin
       */class GridSorterElement extends Vaadin.ThemableMixin(Vaadin.DirMixin(Polymer.Element)){static get is(){return"vaadin-grid-sorter"}static get properties(){return{/**
             * JS Path of the property in the item used for sorting the data.
             */path:String,/**
             * How to sort the data.
             * Possible values are `asc` to use an ascending algorithm, `desc` to sort the data in
             * descending direction, or `null` for not sorting the data.
             */direction:{type:String,reflectToAttribute:!0,notify:!0,value:null},_order:{type:Number,value:null},_isConnected:{type:Boolean,value:!1}}}static get observers(){return["_pathOrDirectionChanged(path, direction, _isConnected)","_directionOrOrderChanged(direction, _order)"]}ready(){super.ready();this.addEventListener("click",this._onClick.bind(this))}/** @protected */connectedCallback(){super.connectedCallback();this._isConnected=!0}/** @protected */disconnectedCallback(){super.disconnectedCallback();this._isConnected=!1}_pathOrDirectionChanged(path,direction,isConnected){if(path===void 0||direction===void 0||isConnected===void 0){return}if(isConnected){this.dispatchEvent(new CustomEvent("sorter-changed",{bubbles:!0,composed:!0}))}}_getDisplayOrder(order){return null===order?"":order+1}_onClick(e){const activeElement=this.getRootNode().activeElement;if(this!==activeElement&&this.contains(activeElement)){// Some focusable content inside the sorter was clicked, do nothing.
return}e.preventDefault();if("asc"===this.direction){this.direction="desc"}else if("desc"===this.direction){this.direction=null}else{this.direction="asc"}}_directionOrOrderChanged(direction,order){if(direction===void 0||order===void 0){return}// Safari has an issue with repainting shadow root element styles when a host attribute changes.
// Need this workaround (toggle any inline css property on and off) until the issue gets fixed.
var isSafari=/^((?!chrome|android).)*safari/i.test(navigator.userAgent);if(isSafari&&this.root){this.root.querySelectorAll("*").forEach(function(el){el.style["-webkit-backface-visibility"]="visible";el.style["-webkit-backface-visibility"]=""})}}}customElements.define(GridSorterElement.is,GridSorterElement);/**
       * @namespace Vaadin
       */window.Vaadin=window.Vaadin||{};Vaadin.GridSorterElement=GridSorterElement})();</script></dom-module><script>/**
   * @demo demo/index.html
   * @polymerBehavior
   */Polymer.IronControlState={properties:{/**
       * If true, the element currently has focus.
       */focused:{type:Boolean,value:!1,notify:!0,readOnly:!0,reflectToAttribute:!0},/**
       * If true, the user cannot interact with this element.
       */disabled:{type:Boolean,value:!1,notify:!0,observer:"_disabledChanged",reflectToAttribute:!0},/**
       * Value of the `tabindex` attribute before `disabled` was activated.
       * `null` means the attribute was not present.
       * @type {?string|undefined}
       */_oldTabIndex:{type:String},_boundFocusBlurHandler:{type:Function,value:function(){return this._focusBlurHandler.bind(this)}},__handleEventRetargeting:{type:Boolean,value:function(){return!this.shadowRoot&&!Polymer.Element}}},observers:["_changedControlState(focused, disabled)"],/**
     * @return {void}
     */ready:function(){this.addEventListener("focus",this._boundFocusBlurHandler,!0);this.addEventListener("blur",this._boundFocusBlurHandler,!0)},_focusBlurHandler:function(event){// In Polymer 2.0, the library takes care of retargeting events.
if(Polymer.Element){this._setFocused("focus"===event.type);return}// NOTE(cdata):  if we are in ShadowDOM land, `event.target` will
// eventually become `this` due to retargeting; if we are not in
// ShadowDOM land, `event.target` will eventually become `this` due
// to the second conditional which fires a synthetic event (that is also
// handled). In either case, we can disregard `event.path`.
if(event.target===this){this._setFocused("focus"===event.type)}else if(this.__handleEventRetargeting){var target=/** @type {Node} */Polymer.dom(event).localTarget;if(!this.isLightDescendant(target)){this.fire(event.type,{sourceEvent:event},{node:this,bubbles:event.bubbles,cancelable:event.cancelable})}}},_disabledChanged:function(disabled,old){this.setAttribute("aria-disabled",disabled?"true":"false");this.style.pointerEvents=disabled?"none":"";if(disabled){// Read the `tabindex` attribute instead of the `tabIndex` property.
// The property returns `-1` if there is no `tabindex` attribute.
// This distinction is important when restoring the value because
// leaving `-1` hides shadow root children from the tab order.
this._oldTabIndex=this.getAttribute("tabindex");this._setFocused(!1);this.tabIndex=-1;this.blur()}else if(this._oldTabIndex!==void 0){if(null===this._oldTabIndex){this.removeAttribute("tabindex")}else{this.setAttribute("tabindex",this._oldTabIndex)}}},_changedControlState:function(){// _controlStateChanged is abstract, follow-on behaviors may implement it
if(this._controlStateChanged){this._controlStateChanged()}}};</script><script>/**
   * @demo demo/index.html
   * @polymerBehavior Polymer.IronButtonState
   */Polymer.IronButtonStateImpl={properties:{/**
       * If true, the user is currently holding down the button.
       */pressed:{type:Boolean,readOnly:!0,value:!1,reflectToAttribute:!0,observer:"_pressedChanged"},/**
       * If true, the button toggles the active state with each tap or press
       * of the spacebar.
       */toggles:{type:Boolean,value:!1,reflectToAttribute:!0},/**
       * If true, the button is a toggle and is currently in the active state.
       */active:{type:Boolean,value:!1,notify:!0,reflectToAttribute:!0},/**
       * True if the element is currently being pressed by a "pointer," which
       * is loosely defined as mouse or touch input (but specifically excluding
       * keyboard input).
       */pointerDown:{type:Boolean,readOnly:!0,value:!1},/**
       * True if the input device that caused the element to receive focus
       * was a keyboard.
       */receivedFocusFromKeyboard:{type:Boolean,readOnly:!0},/**
       * The aria attribute to be set if the button is a toggle and in the
       * active state.
       */ariaActiveAttribute:{type:String,value:"aria-pressed",observer:"_ariaActiveAttributeChanged"}},listeners:{down:"_downHandler",up:"_upHandler",tap:"_tapHandler"},observers:["_focusChanged(focused)","_activeChanged(active, ariaActiveAttribute)"],/**
     * @type {!Object}
     */keyBindings:{"enter:keydown":"_asyncClick","space:keydown":"_spaceKeyDownHandler","space:keyup":"_spaceKeyUpHandler"},_mouseEventRe:/^mouse/,_tapHandler:function(){if(this.toggles){// a tap is needed to toggle the active state
this._userActivate(!this.active)}else{this.active=!1}},_focusChanged:function(focused){this._detectKeyboardFocus(focused);if(!focused){this._setPressed(!1)}},_detectKeyboardFocus:function(focused){this._setReceivedFocusFromKeyboard(!this.pointerDown&&focused)},// to emulate native checkbox, (de-)activations from a user interaction fire
// 'change' events
_userActivate:function(active){if(this.active!==active){this.active=active;this.fire("change")}},_downHandler:function(event){this._setPointerDown(!0);this._setPressed(!0);this._setReceivedFocusFromKeyboard(!1)},_upHandler:function(){this._setPointerDown(!1);this._setPressed(!1)},/**
     * @param {!KeyboardEvent} event .
     */_spaceKeyDownHandler:function(event){var keyboardEvent=event.detail.keyboardEvent,target=Polymer.dom(keyboardEvent).localTarget;// Ignore the event if this is coming from a focused light child, since that
// element will deal with it.
if(this.isLightDescendant(/** @type {Node} */target))return;keyboardEvent.preventDefault();keyboardEvent.stopImmediatePropagation();this._setPressed(!0)},/**
     * @param {!KeyboardEvent} event .
     */_spaceKeyUpHandler:function(event){var keyboardEvent=event.detail.keyboardEvent,target=Polymer.dom(keyboardEvent).localTarget;// Ignore the event if this is coming from a focused light child, since that
// element will deal with it.
if(this.isLightDescendant(/** @type {Node} */target))return;if(this.pressed){this._asyncClick()}this._setPressed(!1)},// trigger click asynchronously, the asynchrony is useful to allow one
// event handler to unwind before triggering another event
_asyncClick:function(){this.async(function(){this.click()},1)},// any of these changes are considered a change to button state
_pressedChanged:function(pressed){this._changedButtonState()},_ariaActiveAttributeChanged:function(value,oldValue){if(oldValue&&oldValue!=value&&this.hasAttribute(oldValue)){this.removeAttribute(oldValue)}},_activeChanged:function(active,ariaActiveAttribute){if(this.toggles){this.setAttribute(this.ariaActiveAttribute,active?"true":"false")}else{this.removeAttribute(this.ariaActiveAttribute)}this._changedButtonState()},_controlStateChanged:function(){if(this.disabled){this._setPressed(!1)}else{this._changedButtonState()}},// provide hook for follow-on behaviors to react to button-state
_changedButtonState:function(){if(this._buttonStateChanged){this._buttonStateChanged();// abstract
}}};/** @polymerBehavior */Polymer.IronButtonState=[Polymer.IronA11yKeysBehavior,Polymer.IronButtonStateImpl];</script><dom-module id="paper-ripple" assetpath="../bower_components/paper-ripple/"><template><style>:host{display:block;position:absolute;border-radius:inherit;overflow:hidden;top:0;left:0;right:0;bottom:0;pointer-events:none;}:host([animating]){-webkit-transform:translate(0, 0);transform:translate3d(0, 0, 0);}#background,
      #waves,
      .wave-container,
      .wave{pointer-events:none;position:absolute;top:0;left:0;width:100%;height:100%;}#background,
      .wave{opacity:0;}#waves,
      .wave{overflow:hidden;}.wave-container,
      .wave{border-radius:50%;}:host(.circle) #background,
      :host(.circle) #waves{border-radius:50%;}:host(.circle) .wave-container{overflow:hidden;}</style><div id="background"></div><div id="waves"></div></template></dom-module><script>(function(){'use strict';var Utility={distance:function(x1,y1,x2,y2){var xDelta=x1-x2,yDelta=y1-y2;return Math.sqrt(xDelta*xDelta+yDelta*yDelta)},now:window.performance&&window.performance.now?window.performance.now.bind(window.performance):Date.now};/**
   * @param {HTMLElement} element
   * @constructor
   */function ElementMetrics(element){this.element=element;this.width=this.boundingRect.width;this.height=this.boundingRect.height;this.size=Math.max(this.width,this.height)}ElementMetrics.prototype={get boundingRect(){return this.element.getBoundingClientRect()},furthestCornerDistanceFrom:function(x,y){var topLeft=Utility.distance(x,y,0,0),topRight=Utility.distance(x,y,this.width,0),bottomLeft=Utility.distance(x,y,0,this.height),bottomRight=Utility.distance(x,y,this.width,this.height);return Math.max(topLeft,topRight,bottomLeft,bottomRight)}};/**
   * @param {HTMLElement} element
   * @constructor
   */function Ripple(element){this.element=element;this.color=window.getComputedStyle(element).color;this.wave=document.createElement("div");this.waveContainer=document.createElement("div");this.wave.style.backgroundColor=this.color;this.wave.classList.add("wave");this.waveContainer.classList.add("wave-container");Polymer.dom(this.waveContainer).appendChild(this.wave);this.resetInteractionState()}Ripple.MAX_RADIUS=300;Ripple.prototype={get recenters(){return this.element.recenters},get center(){return this.element.center},get mouseDownElapsed(){var elapsed;if(!this.mouseDownStart){return 0}elapsed=Utility.now()-this.mouseDownStart;if(this.mouseUpStart){elapsed-=this.mouseUpElapsed}return elapsed},get mouseUpElapsed(){return this.mouseUpStart?Utility.now()-this.mouseUpStart:0},get mouseDownElapsedSeconds(){return this.mouseDownElapsed/1e3},get mouseUpElapsedSeconds(){return this.mouseUpElapsed/1e3},get mouseInteractionSeconds(){return this.mouseDownElapsedSeconds+this.mouseUpElapsedSeconds},get initialOpacity(){return this.element.initialOpacity},get opacityDecayVelocity(){return this.element.opacityDecayVelocity},get radius(){var width2=this.containerMetrics.width*this.containerMetrics.width,height2=this.containerMetrics.height*this.containerMetrics.height,waveRadius=1.1*Math.min(Math.sqrt(width2+height2),Ripple.MAX_RADIUS)+5,duration=1.1-.2*(waveRadius/Ripple.MAX_RADIUS),timeNow=this.mouseInteractionSeconds/duration,size=waveRadius*(1-Math.pow(80,-timeNow));return Math.abs(size)},get opacity(){if(!this.mouseUpStart){return this.initialOpacity}return Math.max(0,this.initialOpacity-this.mouseUpElapsedSeconds*this.opacityDecayVelocity)},get outerOpacity(){// Linear increase in background opacity, capped at the opacity
// of the wavefront (waveOpacity).
var outerOpacity=.3*this.mouseUpElapsedSeconds,waveOpacity=this.opacity;return Math.max(0,Math.min(outerOpacity,waveOpacity))},get isOpacityFullyDecayed(){return .01>this.opacity&&this.radius>=Math.min(this.maxRadius,Ripple.MAX_RADIUS)},get isRestingAtMaxRadius(){return this.opacity>=this.initialOpacity&&this.radius>=Math.min(this.maxRadius,Ripple.MAX_RADIUS)},get isAnimationComplete(){return this.mouseUpStart?this.isOpacityFullyDecayed:this.isRestingAtMaxRadius},get translationFraction(){return Math.min(1,2*(this.radius/this.containerMetrics.size)/Math.sqrt(2))},get xNow(){if(this.xEnd){return this.xStart+this.translationFraction*(this.xEnd-this.xStart)}return this.xStart},get yNow(){if(this.yEnd){return this.yStart+this.translationFraction*(this.yEnd-this.yStart)}return this.yStart},get isMouseDown(){return this.mouseDownStart&&!this.mouseUpStart},resetInteractionState:function(){this.maxRadius=0;this.mouseDownStart=0;this.mouseUpStart=0;this.xStart=0;this.yStart=0;this.xEnd=0;this.yEnd=0;this.slideDistance=0;this.containerMetrics=new ElementMetrics(this.element)},draw:function(){var scale,dx,dy;this.wave.style.opacity=this.opacity;scale=this.radius/(this.containerMetrics.size/2);dx=this.xNow-this.containerMetrics.width/2;dy=this.yNow-this.containerMetrics.height/2;// 2d transform for safari because of border-radius and overflow:hidden
// clipping bug. https://bugs.webkit.org/show_bug.cgi?id=98538
this.waveContainer.style.webkitTransform="translate("+dx+"px, "+dy+"px)";this.waveContainer.style.transform="translate3d("+dx+"px, "+dy+"px, 0)";this.wave.style.webkitTransform="scale("+scale+","+scale+")";this.wave.style.transform="scale3d("+scale+","+scale+",1)"},/** @param {Event=} event */downAction:function(event){var xCenter=this.containerMetrics.width/2,yCenter=this.containerMetrics.height/2;this.resetInteractionState();this.mouseDownStart=Utility.now();if(this.center){this.xStart=xCenter;this.yStart=yCenter;this.slideDistance=Utility.distance(this.xStart,this.yStart,this.xEnd,this.yEnd)}else{this.xStart=event?event.detail.x-this.containerMetrics.boundingRect.left:this.containerMetrics.width/2;this.yStart=event?event.detail.y-this.containerMetrics.boundingRect.top:this.containerMetrics.height/2}if(this.recenters){this.xEnd=xCenter;this.yEnd=yCenter;this.slideDistance=Utility.distance(this.xStart,this.yStart,this.xEnd,this.yEnd)}this.maxRadius=this.containerMetrics.furthestCornerDistanceFrom(this.xStart,this.yStart);this.waveContainer.style.top=(this.containerMetrics.height-this.containerMetrics.size)/2+"px";this.waveContainer.style.left=(this.containerMetrics.width-this.containerMetrics.size)/2+"px";this.waveContainer.style.width=this.containerMetrics.size+"px";this.waveContainer.style.height=this.containerMetrics.size+"px"},/** @param {Event=} event */upAction:function(event){if(!this.isMouseDown){return}this.mouseUpStart=Utility.now()},remove:function(){Polymer.dom(this.waveContainer.parentNode).removeChild(this.waveContainer)}};Polymer({is:"paper-ripple",behaviors:[Polymer.IronA11yKeysBehavior],properties:{/**
       * The initial opacity set on the wave.
       *
       * @attribute initialOpacity
       * @type number
       * @default 0.25
       */initialOpacity:{type:Number,value:.25},/**
       * How fast (opacity per second) the wave fades out.
       *
       * @attribute opacityDecayVelocity
       * @type number
       * @default 0.8
       */opacityDecayVelocity:{type:Number,value:.8},/**
       * If true, ripples will exhibit a gravitational pull towards
       * the center of their container as they fade away.
       *
       * @attribute recenters
       * @type boolean
       * @default false
       */recenters:{type:Boolean,value:!1},/**
       * If true, ripples will center inside its container
       *
       * @attribute recenters
       * @type boolean
       * @default false
       */center:{type:Boolean,value:!1},/**
       * A list of the visual ripples.
       *
       * @attribute ripples
       * @type Array
       * @default []
       */ripples:{type:Array,value:function(){return[]}},/**
       * True when there are visible ripples animating within the
       * element.
       */animating:{type:Boolean,readOnly:!0,reflectToAttribute:!0,value:!1},/**
       * If true, the ripple will remain in the "down" state until `holdDown`
       * is set to false again.
       */holdDown:{type:Boolean,value:!1,observer:"_holdDownChanged"},/**
       * If true, the ripple will not generate a ripple effect
       * via pointer interaction.
       * Calling ripple's imperative api like `simulatedRipple` will
       * still generate the ripple effect.
       */noink:{type:Boolean,value:!1},_animating:{type:Boolean},_boundAnimate:{type:Function,value:function(){return this.animate.bind(this)}}},get target(){return this.keyEventTarget},/**
     * @type {!Object}
     */keyBindings:{"enter:keydown":"_onEnterKeydown","space:keydown":"_onSpaceKeydown","space:keyup":"_onSpaceKeyup"},attached:function(){// Set up a11yKeysBehavior to listen to key events on the target,
// so that space and enter activate the ripple even if the target doesn't
// handle key events. The key handlers deal with `noink` themselves.
if(11==this.parentNode.nodeType){// DOCUMENT_FRAGMENT_NODE
this.keyEventTarget=Polymer.dom(this).getOwnerRoot().host}else{this.keyEventTarget=this.parentNode}var keyEventTarget=/** @type {!EventTarget} */this.keyEventTarget;this.listen(keyEventTarget,"up","uiUpAction");this.listen(keyEventTarget,"down","uiDownAction")},detached:function(){this.unlisten(this.keyEventTarget,"up","uiUpAction");this.unlisten(this.keyEventTarget,"down","uiDownAction");this.keyEventTarget=null},get shouldKeepAnimating(){for(var index=0;index<this.ripples.length;++index){if(!this.ripples[index].isAnimationComplete){return!0}}return!1},simulatedRipple:function(){this.downAction(null);// Please see polymer/polymer#1305
this.async(function(){this.upAction()},1)},/**
     * Provokes a ripple down effect via a UI event,
     * respecting the `noink` property.
     * @param {Event=} event
     */uiDownAction:function(event){if(!this.noink){this.downAction(event)}},/**
     * Provokes a ripple down effect via a UI event,
     * *not* respecting the `noink` property.
     * @param {Event=} event
     */downAction:function(event){if(this.holdDown&&0<this.ripples.length){return}var ripple=this.addRipple();ripple.downAction(event);if(!this._animating){this._animating=!0;this.animate()}},/**
     * Provokes a ripple up effect via a UI event,
     * respecting the `noink` property.
     * @param {Event=} event
     */uiUpAction:function(event){if(!this.noink){this.upAction(event)}},/**
     * Provokes a ripple up effect via a UI event,
     * *not* respecting the `noink` property.
     * @param {Event=} event
     */upAction:function(event){if(this.holdDown){return}this.ripples.forEach(function(ripple){ripple.upAction(event)});this._animating=!0;this.animate()},onAnimationComplete:function(){this._animating=!1;this.$.background.style.backgroundColor=null;this.fire("transitionend")},addRipple:function(){var ripple=new Ripple(this);Polymer.dom(this.$.waves).appendChild(ripple.waveContainer);this.$.background.style.backgroundColor=ripple.color;this.ripples.push(ripple);this._setAnimating(!0);return ripple},removeRipple:function(ripple){var rippleIndex=this.ripples.indexOf(ripple);if(0>rippleIndex){return}this.ripples.splice(rippleIndex,1);ripple.remove();if(!this.ripples.length){this._setAnimating(!1)}},/**
     * This conflicts with Element#antimate().
     * https://developer.mozilla.org/en-US/docs/Web/API/Element/animate
     * @suppress {checkTypes}
     */animate:function(){if(!this._animating){return}var index,ripple;for(index=0;index<this.ripples.length;++index){ripple=this.ripples[index];ripple.draw();this.$.background.style.opacity=ripple.outerOpacity;if(ripple.isOpacityFullyDecayed&&!ripple.isRestingAtMaxRadius){this.removeRipple(ripple)}}if(!this.shouldKeepAnimating&&0===this.ripples.length){this.onAnimationComplete()}else{window.requestAnimationFrame(this._boundAnimate)}},_onEnterKeydown:function(){this.uiDownAction();this.async(this.uiUpAction,1)},_onSpaceKeydown:function(){this.uiDownAction()},_onSpaceKeyup:function(){this.uiUpAction()},// note: holdDown does not respect noink since it can be a focus based
// effect.
_holdDownChanged:function(newVal,oldVal){if(oldVal===void 0){return}if(newVal){this.downAction()}else{this.upAction()}}/**
    Fired when the animation finishes.
    This is useful if you want to wait until
    the ripple animation finishes to perform some action.

    @event transitionend
    @param {{node: Object}} detail Contains the animated node.
    */})})();</script><script>/**
   * `Polymer.PaperRippleBehavior` dynamically implements a ripple
   * when the element has focus via pointer or keyboard.
   *
   * NOTE: This behavior is intended to be used in conjunction with and after
   * `Polymer.IronButtonState` and `Polymer.IronControlState`.
   *
   * @polymerBehavior Polymer.PaperRippleBehavior
   */Polymer.PaperRippleBehavior={properties:{/**
       * If true, the element will not produce a ripple effect when interacted
       * with via the pointer.
       */noink:{type:Boolean,observer:"_noinkChanged"},/**
       * @type {Element|undefined}
       */_rippleContainer:{type:Object}},/**
     * Ensures a `<paper-ripple>` element is available when the element is
     * focused.
     */_buttonStateChanged:function(){if(this.focused){this.ensureRipple()}},/**
     * In addition to the functionality provided in `IronButtonState`, ensures
     * a ripple effect is created when the element is in a `pressed` state.
     */_downHandler:function(event){Polymer.IronButtonStateImpl._downHandler.call(this,event);if(this.pressed){this.ensureRipple(event)}},/**
     * Ensures this element contains a ripple effect. For startup efficiency
     * the ripple effect is dynamically on demand when needed.
     * @param {!Event=} optTriggeringEvent (optional) event that triggered the
     * ripple.
     */ensureRipple:function(optTriggeringEvent){if(!this.hasRipple()){this._ripple=this._createRipple();this._ripple.noink=this.noink;var rippleContainer=this._rippleContainer||this.root;if(rippleContainer){Polymer.dom(rippleContainer).appendChild(this._ripple)}if(optTriggeringEvent){// Check if the event happened inside of the ripple container
// Fall back to host instead of the root because distributed text
// nodes are not valid event targets
var domContainer=Polymer.dom(this._rippleContainer||this),target=Polymer.dom(optTriggeringEvent).rootTarget;if(domContainer.deepContains(/** @type {Node} */target)){this._ripple.uiDownAction(optTriggeringEvent)}}}},/**
     * Returns the `<paper-ripple>` element used by this element to create
     * ripple effects. The element's ripple is created on demand, when
     * necessary, and calling this method will force the
     * ripple to be created.
     */getRipple:function(){this.ensureRipple();return this._ripple},/**
     * Returns true if this element currently contains a ripple effect.
     * @return {boolean}
     */hasRipple:function(){return!!this._ripple},/**
     * Create the element's ripple effect via creating a `<paper-ripple>`.
     * Override this method to customize the ripple element.
     * @return {!PaperRippleElement} Returns a `<paper-ripple>` element.
     */_createRipple:function(){var element=/** @type {!PaperRippleElement} */document.createElement("paper-ripple");return element},_noinkChanged:function(noink){if(this.hasRipple()){this._ripple.noink=noink}}};</script><dom-module id="paper-icon-button-light" assetpath="../bower_components/paper-icon-button/"><template strip-whitespace=""><style>:host{display:inline-block;position:relative;width:24px;height:24px;}paper-ripple{opacity:0.6;color:currentColor;@apply --paper-icon-button-light-ripple;}:host > ::slotted(button){position:relative;width:100%;height:100%;margin:0;padding:0;background:none;border:none;outline:none;vertical-align:middle;color:inherit;cursor:pointer;-webkit-tap-highlight-color:rgba(0, 0, 0, 0);-webkit-tap-highlight-color:transparent;}:host > ::slotted(button[disabled]){color:#9b9b9b;pointer-events:none;cursor:auto;}</style><slot></slot></template><script>Polymer({is:"paper-icon-button-light",behaviors:[Polymer.PaperRippleBehavior],ready:function(){Polymer.RenderStatus.afterNextRender(this,()=>{// Add lazy host listeners
this.addEventListener("down",this._rippleDown.bind(this));this.addEventListener("up",this._rippleUp.bind(this));// Assume the button has already been distributed.
var button=this.getEffectiveChildren()[0];this._rippleContainer=button;// We need to set the focus/blur listeners on the distributed button,
// not the host, since the host isn't focusable.
button.addEventListener("focus",this._rippleDown.bind(this));button.addEventListener("blur",this._rippleUp.bind(this))})},_rippleDown:function(){this.getRipple().uiDownAction()},_rippleUp:function(){this.getRipple().uiUpAction()},/**
       * @param {...*} var_args
       */ensureRipple:function(var_args){var lastRipple=this._ripple;Polymer.PaperRippleBehavior.ensureRipple.apply(this,arguments);if(this._ripple&&this._ripple!==lastRipple){this._ripple.center=!0;this._ripple.classList.add("circle")}}});</script></dom-module><script>/**
   * The `iron-iconset-svg` element allows users to define their own icon sets
   * that contain svg icons. The svg icon elements should be children of the
   * `iron-iconset-svg` element. Multiple icons should be given distinct id's.
   *
   * Using svg elements to create icons has a few advantages over traditional
   * bitmap graphics like jpg or png. Icons that use svg are vector based so
   * they are resolution independent and should look good on any device. They
   * are stylable via css. Icons can be themed, colorized, and even animated.
   *
   * Example:
   *
   *     <iron-iconset-svg name="my-svg-icons" size="24">
   *       <svg>
   *         <defs>
   *           <g id="shape">
   *             <rect x="12" y="0" width="12" height="24" />
   *             <circle cx="12" cy="12" r="12" />
   *           </g>
   *         </defs>
   *       </svg>
   *     </iron-iconset-svg>
   *
   * This will automatically register the icon set "my-svg-icons" to the iconset
   * database.  To use these icons from within another element, make a
   * `iron-iconset` element and call the `byId` method
   * to retrieve a given iconset. To apply a particular icon inside an
   * element use the `applyIcon` method. For example:
   *
   *     iconset.applyIcon(iconNode, 'car');
   *
   * @element iron-iconset-svg
   * @demo demo/index.html
   * @implements {Polymer.Iconset}
   */Polymer({is:"iron-iconset-svg",properties:{/**
       * The name of the iconset.
       */name:{type:String,observer:"_nameChanged"},/**
       * The size of an individual icon. Note that icons must be square.
       */size:{type:Number,value:24},/**
       * Set to true to enable mirroring of icons where specified when they are
       * stamped. Icons that should be mirrored should be decorated with a
       * `mirror-in-rtl` attribute.
       *
       * NOTE: For performance reasons, direction will be resolved once per
       * document per iconset, so moving icons in and out of RTL subtrees will
       * not cause their mirrored state to change.
       */rtlMirroring:{type:Boolean,value:!1},/**
       * Set to true to measure RTL based on the dir attribute on the body or
       * html elements (measured on document.body or document.documentElement as
       * available).
       */useGlobalRtlAttribute:{type:Boolean,value:!1}},created:function(){this._meta=new Polymer.IronMeta({type:"iconset",key:null,value:null})},attached:function(){this.style.display="none"},/**
     * Construct an array of all icon names in this iconset.
     *
     * @return {!Array} Array of icon names.
     */getIconNames:function(){this._icons=this._createIconMap();return Object.keys(this._icons).map(function(n){return this.name+":"+n},this)},/**
     * Applies an icon to the given element.
     *
     * An svg icon is prepended to the element's shadowRoot if it exists,
     * otherwise to the element itself.
     *
     * If RTL mirroring is enabled, and the icon is marked to be mirrored in
     * RTL, the element will be tested (once and only once ever for each
     * iconset) to determine the direction of the subtree the element is in.
     * This direction will apply to all future icon applications, although only
     * icons marked to be mirrored will be affected.
     *
     * @method applyIcon
     * @param {Element} element Element to which the icon is applied.
     * @param {string} iconName Name of the icon to apply.
     * @return {?Element} The svg element which renders the icon.
     */applyIcon:function(element,iconName){// Remove old svg element
this.removeIcon(element);// install new svg element
var svg=this._cloneIcon(iconName,this.rtlMirroring&&this._targetIsRTL(element));if(svg){// insert svg element into shadow root, if it exists
var pde=Polymer.dom(element.root||element);pde.insertBefore(svg,pde.childNodes[0]);return element._svgIcon=svg}return null},/**
     * Remove an icon from the given element by undoing the changes effected
     * by `applyIcon`.
     *
     * @param {Element} element The element from which the icon is removed.
     */removeIcon:function(element){// Remove old svg element
if(element._svgIcon){Polymer.dom(element.root||element).removeChild(element._svgIcon);element._svgIcon=null}},/**
     * Measures and memoizes the direction of the element. Note that this
     * measurement is only done once and the result is memoized for future
     * invocations.
     */_targetIsRTL:function(target){if(null==this.__targetIsRTL){if(this.useGlobalRtlAttribute){var globalElement=document.body&&document.body.hasAttribute("dir")?document.body:document.documentElement;this.__targetIsRTL="rtl"===globalElement.getAttribute("dir")}else{if(target&&target.nodeType!==Node.ELEMENT_NODE){target=target.host}this.__targetIsRTL=target&&"rtl"===window.getComputedStyle(target).direction}}return this.__targetIsRTL},/**
     *
     * When name is changed, register iconset metadata
     *
     */_nameChanged:function(){this._meta.value=null;this._meta.key=this.name;this._meta.value=this;this.async(function(){this.fire("iron-iconset-added",this,{node:window})})},/**
     * Create a map of child SVG elements by id.
     *
     * @return {!Object} Map of id's to SVG elements.
     */_createIconMap:function(){// Objects chained to Object.prototype (`{}`) have members. Specifically,
// on FF there is a `watch` method that confuses the icon map, so we
// need to use a null-based object here.
var icons=Object.create(null);Polymer.dom(this).querySelectorAll("[id]").forEach(function(icon){icons[icon.id]=icon});return icons},/**
     * Produce installable clone of the SVG element matching `id` in this
     * iconset, or `undefined` if there is no matching element.
     *
     * @return {Element} Returns an installable clone of the SVG element
     * matching `id`.
     */_cloneIcon:function(id,mirrorAllowed){// create the icon map on-demand, since the iconset itself has no discrete
// signal to know when it's children are fully parsed
this._icons=this._icons||this._createIconMap();return this._prepareSvgClone(this._icons[id],this.size,mirrorAllowed)},/**
     * @param {Element} sourceSvg
     * @param {number} size
     * @param {Boolean} mirrorAllowed
     * @return {Element}
     */_prepareSvgClone:function(sourceSvg,size,mirrorAllowed){if(sourceSvg){var content=sourceSvg.cloneNode(!0),svg=document.createElementNS("http://www.w3.org/2000/svg","svg"),viewBox=content.getAttribute("viewBox")||"0 0 "+size+" "+size,cssText="pointer-events: none; display: block; width: 100%; height: 100%;";if(mirrorAllowed&&content.hasAttribute("mirror-in-rtl")){cssText+="-webkit-transform:scale(-1,1);transform:scale(-1,1);transform-origin:center;"}svg.setAttribute("viewBox",viewBox);svg.setAttribute("preserveAspectRatio","xMidYMid meet");svg.setAttribute("focusable","false");// TODO(dfreedm): `pointer-events: none` works around
// https://crbug.com/370136
// TODO(sjmiles): inline style may not be ideal, but avoids requiring a
// shadow-root
svg.style.cssText=cssText;svg.appendChild(content).removeAttribute("id");return svg}return null}});</script><iron-iconset-svg size="24" name="expense-manager"><svg><defs><g id="add"><path d="M19 13h-6v6h-2v-6H5v-2h6V5h2v6h6v2z"></path></g><g id="filters"><path d="M10 18h4v-2h-4v2zM3 6v2h18V6H3zm3 7h12v-2H6v2z"></path></g></defs></svg></iron-iconset-svg><dom-module id="expenses-list"><template><style>:host{position:relative;display:flex;flex-direction:column;}#add-button{position:absolute;height:var(--lumo-size-xl);width:var(--lumo-size-xl);right:32px;bottom:32px;z-index:1;background:var(--lumo-error-color);color:var(--lumo-error-contrast-color);box-shadow:var(--lumo-box-shadow-m);border-radius:50%;}#expenses{flex:auto;height:0.001px;border:0;}vaadin-grid .status{text-transform:capitalize;}vaadin-grid .status-new{color:var(--lumo-error-color);font-weight:500;}vaadin-grid .status-in_progress{font-weight:500;font-style:italic;text-transform:capitalize;}vaadin-grid .total{text-align:right;}vaadin-grid#expenses .cell.last{padding-right:24px;}vaadin-grid#expenses .numeric{text-align:right;}vaadin-grid#expenses .comment{text-overflow:ellipsis;}</style><vaadin-grid items="[[expenses]]" id="expenses" active-item="{{activeItem}}"><vaadin-grid-column width="8em" frozen=""><template class="header"><vaadin-grid-sorter path="date" direction="desc"><div class="header-cell">Date</div></vaadin-grid-sorter></template><template>[[_formatDate(item.date)]]</template></vaadin-grid-column><vaadin-grid-column width="8em" flex-grow="2"><template class="header"><vaadin-grid-sorter path="merchant"><div class="header-cell">Merchant</div></vaadin-grid-sorter></template><template>[[item.merchant]]</template></vaadin-grid-column><vaadin-grid-column width="6em"><template class="header"><vaadin-grid-sorter path="total" class="numeric"><div class="header-cell">Total</div></vaadin-grid-sorter></template><template><span class="total">[[_formatTotal(item.total)]]</span></template></vaadin-grid-column><vaadin-grid-column width="8em"><template class="header"><vaadin-grid-sorter path="status"><div class="header-cell">Status</div></vaadin-grid-sorter></template><template><span class$="status-[[item.status]] status">[[_formatStatus(item.status)]]</span></template></vaadin-grid-column><vaadin-grid-column width="14em" flex-grow="3"><template class="header"><vaadin-grid-sorter path="comment"><div class="header-cell">Comment</div></vaadin-grid-sorter></template><template><div class="comment">[[item.comment]]</div></template></vaadin-grid-column></vaadin-grid><paper-icon-button-light on-click="_showExpenseEditor" id="add-button"><button aria-label="Add expense"><iron-icon icon="expense-manager:add"></iron-icon></button></paper-icon-button-light></template><script>(function(){/**
       * @memberof ExpenseManager
       */class ExpensesListElement extends ExpenseManager.ReduxMixin(Polymer.Element){static get is(){return"expenses-list"}static get properties(){return{/**
             * The list of expenses.
             * @type {Array}
             */expenses:{type:Array,statePath:ExpenseManager.select.expenses},/**
             * The selected expense object.
             * @type {Array}
             */activeItem:{observer:"_activeItemChanged"}}}_showExpenseEditor(){this.dispatch("editExpense")}/**
         * @param {Object|null} expense the selected expense, if any.
         */_activeItemChanged(expense){if(this.expenses&&0<this.expenses.length){// don't trigger on init
this.$.expenses.selectedItems=expense?[expense]:[];this.dispatch("editExpense",expense)}}/**
         * @param {number} total an expense amount to format.
         * @return {string} a formatted amount.
         */_formatTotal(total){if(total){return"$"+total.toFixed(2)}}/**
         * @param {string} status an expense status to format.
         * @return {string} a formatted status.
         */_formatStatus(status){if(status){return status.replace("_"," ")}}/**
         * @param {string} date an expense date to format.
         * @return {string} a formatted date.
         */_formatDate(date){if(date){return window.ExpenseManager.dateHelpers.format(date)}}}customElements.define(ExpensesListElement.is,ExpensesListElement);/**
       * @namespace ExpenseManager
       */window.ExpenseManager=window.ExpenseManager||{};ExpenseManager.ExpensesListElement=ExpensesListElement})();</script></dom-module><dom-module id="content-panel"><template><style>:host{display:flex;height:100%;}:host([tablet]){flex-direction:column;}expenses-list{flex:1;height:100%;}history-panel{box-shadow:var(--lumo-shade-50pct) 6px 0 16px -10px inset;z-index:1;}history-panel[tablet]{box-shadow:var(--lumo-shade-50pct) 0 6px 16px -10px inset;}</style><expenses-list></expenses-list><history-panel phone="[[phone]]" tablet="[[tablet]]"></history-panel></template><script>(function(){/**
       * @memberof ExpenseManager
       * @mixes ExpenseManager.ResponsiveMixin
       */class ContentPanelElement extends ExpenseManager.ResponsiveMixin(Polymer.Element){static get is(){return"content-panel"}}customElements.define(ContentPanelElement.is,ContentPanelElement);/**
       * @namespace ExpenseManager
       */window.ExpenseManager=window.ExpenseManager||{};ExpenseManager.ContentPanelElement=ContentPanelElement})();</script></dom-module><dom-module id="option-group"><template><style include="lumo-color lumo-typography">:host{display:block;color:var(--lumo-body-text-color);}.caption{margin-top:var(--lumo-space-m);margin-bottom:var(--lumo-space-xs);color:var(--lumo-secondary-text-color);font-weight:500;font-size:var(--lumo-font-size-s);}</style><div class="caption">[[caption]]</div><template is="dom-repeat" items="[[items]]"><vaadin-checkbox checked="[[_isChecked(item, value)]]" data-value$="[[_getValue(item)]]" on-checked-changed="_updateValue">[[_getLabel(item)]]</vaadin-checkbox></template></template><script>(function(){/**
       * @memberof ExpenseManager
       */class OptionGroupElement extends Polymer.Element{static get is(){return"option-group"}static get properties(){return{/**
             * The list of available options.
             * @type {Array<object|string>}
             */items:Array,/**
             * The string indicating the sub-property which should be used as a label of the item.
             */labelPath:String,/**
             * The string indicating the sub-property which should be used as a value of the item.
             */valuePath:String,/**
             * The list of values corresponding to the given options.
             */value:{type:Array,notify:!0,value:()=>[]},/**
             * The caption describing the options group.
             */caption:String}}/**
         * Detects whether the given item is checked or not.
         *
         * @param {Object} item the item to compare.
         * @return {boolean} true if the option for given item is checked.
         */_isChecked(item){return this.value.some(val=>{return val===this._getValue(item)})}/**
         * Evaluates the actual value for given item.
         *
         * @param {Object|string} item the item get value from.
         * @return {string} the item value.
         */_getValue(item){return this.valuePath?item[this.valuePath]:item}/**
         * Evaluates the actual label for given item.
         *
         * @param {Object|string} item the item get label from.
         * @return {string} the item label.
         */_getLabel(item){return this.labelPath?item[this.labelPath]:item}/**
         * Fills the list of checked options.
         */_updateValue(){this.value=[...this.shadowRoot.querySelectorAll("vaadin-checkbox")].filter(cb=>cb.checked).map(cb=>cb.dataset.value)}}customElements.define(OptionGroupElement.is,OptionGroupElement);/**
       * @namespace ExpenseManager
       */window.ExpenseManager=window.ExpenseManager||{};ExpenseManager.OptionGroupElement=OptionGroupElement})();</script></dom-module><dom-module id="search-filters"><template><style include="shared-styles">:host{display:block;padding:var(--lumo-space-wide-l);width:inherit;overflow:auto;-webkit-overflow-scrolling:touch;}:host([phone]){width:auto;padding:0 var(--lumo-space-m);}:host([phone]) .filters{width:auto;}.title:not([hidden]){display:flex;}.buttons:not([hidden]){display:flex;justify-content:space-between;margin-top:var(--lumo-space-l);}.filters{display:flex;flex-direction:column;padding-bottom:var(--lumo-space-m);}.row{display:flex;align-items:baseline;}.row vaadin-text-field{min-width:0;flex:auto;}.row .delimiter{padding:0 var(--lumo-space-s);}.title{justify-content:space-between;align-items:baseline;}</style><div class="filters"><div class="title section-title" hidden="[[phone]]"><span>Filter Expenses</span><vaadin-button on-click="_clearFilters" theme="tertiary-inline small">Clear Filters</vaadin-button></div><vaadin-date-picker label="From" value="{{filters.start}}" max="[[filters.end]]"></vaadin-date-picker><vaadin-date-picker label="To" value="{{filters.end}}" min="[[filters.start]]"></vaadin-date-picker><div class="row"><vaadin-text-field label="Min" value="{{filters.min}}" pattern="[0-9]+"><div slot="prefix">$</div></vaadin-text-field><span class="delimiter">–</span><vaadin-text-field label="Max" value="{{filters.max}}" pattern="[0-9]+"></vaadin-text-field></div><vaadin-combo-box label="Merchant" items="{{merchants}}" value="{{filters.merchant}}"></vaadin-combo-box><option-group caption="Status" value="{{filters.status}}" items="[[statusOptions]]" label-path="label" value-path="name"></option-group><div class="buttons" hidden="[[!phone]]"><vaadin-button on-click="_clearFilters" theme="tertiary">Clear Filters</vaadin-button><vaadin-button on-click="_hideFilters">Done</vaadin-button></div></div></template><script>(function(){/**
       * @memberof ExpenseManager
       * @mixes ExpenseManager.ResponsiveMixin
       */class SearchFiltersElement extends ExpenseManager.ReduxMixin(ExpenseManager.ResponsiveMixin(Polymer.Element)){static get is(){return"search-filters"}static get properties(){return{/**
             * The list of original filters.
             */srcFilters:{type:Object,statePath:"filters.filters",observer:"_srcFiltersChanged"},/**
             * The list of filters modified by user.
             */filters:Object,/**
             * The list of available merchants.
             * @type {Array<string>}
             */merchants:{type:Array,statePath:ExpenseManager.select.merchants},/**
             * The list of available statuses.
             * @type {Array<{name: string, label: string}>}
             */statusOptions:{type:Array,value:()=>ExpenseManager.constants.statuses}}}static get observers(){return["_filtersChanged(filters.*)"]}_srcFiltersChanged(srcFilters){this.filters=Object.assign({},srcFilters)}_filtersChanged(){// Ugh. Will do as a object equals
if(JSON.stringify(this.filters)!==JSON.stringify(this.srcFilters)){this.dispatch("filtersUpdated",this.filters)}}_hideFilters(){this.dispatch("hideFilters")}_clearFilters(){this.dispatch("clearFilters")}}customElements.define(SearchFiltersElement.is,SearchFiltersElement);/**
       * @namespace ExpenseManager
       */window.ExpenseManager=window.ExpenseManager||{};ExpenseManager.SearchFiltersElement=SearchFiltersElement})();</script></dom-module><dom-module id="filters-toolbar"><template><style include="lumo-color lumo-typography">:host{display:flex;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;background-color:var(--lumo-base-color);background-image:linear-gradient(var(--lumo-shade-5pct) 0%, var(--lumo-shade-5pct) 100%);color:var(--lumo-body-text-color);position:relative;z-index:2;}:host([phone]){flex-direction:column;}.toolbar{display:flex;flex-shrink:0;padding:0 var(--lumo-space-m);height:var(--lumo-size-xl);justify-content:space-between;align-items:center;}.toolbar[hidden]{display:none;}#filters{transition:max-height 400ms cubic-bezier(0.4, 0, 0.2, 1);}.count{position:absolute;top:4px;right:-4px;z-index:1;width:16px;height:16px;overflow:hidden;text-align:center;border-radius:50%;color:var(--lumo-error-contrast-color);background-color:var(--lumo-error-color);font-family:var(--lumo-font-family);font-size:var(--lumo-font-size-xs);line-height:var(--lumo-line-height-xs);transform:scale(0);transition:all 400ms cubic-bezier(0.4, 0, 0.2, 1);}.count[has-filters]{transform:scale(1);}.total{line-height:var(--lumo-line-height-xs);}</style><div class="toolbar" hidden="[[!phone]]"><div class="total"><small>To be reimbursed</small><div class="sum">$[[totalOwed]]</div></div><vaadin-button theme="tertiary" on-click="_toggleFilters"><iron-icon icon="expense-manager:filters" slot="suffix"></iron-icon><span>Filters</span><div class="count" slot="suffix" has-filters$="[[_hasFilters(appliedFilters)]]">[[appliedFilters]]</div></vaadin-button></div><search-filters phone="[[phone]]" tablet="[[tablet]]" id="filters"></search-filters></template><script>(function(){/**
       * @memberof ExpenseManager
       * @mixes ExpenseManager.ResponsiveMixin
       */class FiltersToolbarElement extends ExpenseManager.ReduxMixin(ExpenseManager.ResponsiveMixin(Polymer.Element)){static get is(){return"filters-toolbar"}static get properties(){return{/**
             * Whether the filters block is expanded.
             */expanded:{type:Boolean,value:!1,statePath:"filters.filtersVisible"},/**
             * The total owed amount.
             */totalOwed:{type:Number,statePath:ExpenseManager.select.total},/**
             * The count of applied filters.
             */appliedFilters:{type:Number,statePath:ExpenseManager.select.appliedFilters}}}static get observers(){return["_updateVisibility(phone, tablet, expanded)"]}_toggleFilters(){this.dispatch("toggleFilters")}/**
         * @param {string} appliedFilters a number of applied filters
         * @return {boolean} true if there s at least one filter applied.
         */_hasFilters(appliedFilters){return 0<appliedFilters}/**
         * @param {string} phone whether the screen matches the phone breakpoint.
         * @param {string} tablet whether the screen matches the tablet breakpoint.
         * @param {string} expanded true if the filters block is expanded.
         */_updateVisibility(phone,tablet,expanded){if(phone){if(expanded){requestAnimationFrame(()=>this.$.filters.style.maxHeight=this.$.filters.scrollHeight+"px")}else{this.$.filters.style.maxHeight="0"}}else{this.$.filters.style.maxHeight="none"}}}customElements.define(FiltersToolbarElement.is,FiltersToolbarElement);/**
       * @namespace ExpenseManager
       */window.ExpenseManager=window.ExpenseManager||{};ExpenseManager.FiltersToolbarElement=FiltersToolbarElement})();</script></dom-module></div><dom-module id="overview-page"><template><style include="lumo-color">:host{display:block;}:host([phone]) .content{flex-direction:column;}.content{display:flex;flex:auto;height:0.001px;background:var(--lumo-base-color);}filters-toolbar[phone]{width:auto;box-shadow:var(--lumo-shade-50pct) 0 -10px 6px -10px inset;}filters-toolbar{width:300px;box-shadow:inset -4px 0 16px -9px var(--lumo-shade-50pct);}@media (max-width: 1124px){.content{padding-right:0;}}content-panel{flex:1;}</style><app-header-layout fullbleed=""><app-header slot="header" fixed="" condenses=""><nav-bar theme="dark"></nav-bar></app-header><div class="content"><filters-toolbar phone="[[phone]]" tablet="[[tablet]]"></filters-toolbar><content-panel phone="[[phone]]" tablet="[[tablet]]"></content-panel></div></app-header-layout><iron-media-query query="(max-width: 900px)" query-matches="{{phone}}"></iron-media-query><iron-media-query query="(max-width: 1124px)" query-matches="{{tablet}}"></iron-media-query><expense-editor></expense-editor><info-dialog></info-dialog></template><script>(function(){/**
       * @memberof ExpenseManager
       * @mixes ExpenseManager.ResponsiveMixin
       */class OverviewPageElement extends ExpenseManager.ReduxMixin(ExpenseManager.ResponsiveMixin(Polymer.Element)){static get is(){return"overview-page"}}customElements.define(OverviewPageElement.is,OverviewPageElement);/**
       * @namespace ExpenseManager
       */window.ExpenseManager=window.ExpenseManager||{};ExpenseManager.OverviewPageElement=OverviewPageElement})();</script></dom-module></body></html>